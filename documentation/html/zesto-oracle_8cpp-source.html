<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>IRIS: zesto-oracle.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_014faa727c0b2aaba2cbdd8f326de4f6.html">source</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_4516642e80adc9bf50ea604a2fbf2492.html">zesto</a>
  </div>
</div>
<div class="contents">
<h1>zesto-oracle.cpp</h1><a href="zesto-oracle_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* zesto-oracle.cpp - Zesto oracle functional simulator class</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright © 2009 by Gabriel H. Loh and the Georgia Tech Research Corporation</span>
<a name="l00004"></a>00004 <span class="comment"> * Atlanta, GA  30332-0415</span>
<a name="l00005"></a>00005 <span class="comment"> * All Rights Reserved.</span>
<a name="l00006"></a>00006 <span class="comment"> * </span>
<a name="l00007"></a>00007 <span class="comment"> * THIS IS A LEGAL DOCUMENT BY DOWNLOADING ZESTO, YOU ARE AGREEING TO THESE</span>
<a name="l00008"></a>00008 <span class="comment"> * TERMS AND CONDITIONS.</span>
<a name="l00009"></a>00009 <span class="comment"> * </span>
<a name="l00010"></a>00010 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span>
<a name="l00011"></a>00011 <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<a name="l00012"></a>00012 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<a name="l00013"></a>00013 <span class="comment"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR CONTRIBUTORS BE</span>
<a name="l00014"></a>00014 <span class="comment"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<a name="l00015"></a>00015 <span class="comment"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a name="l00016"></a>00016 <span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a name="l00017"></a>00017 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a name="l00018"></a>00018 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a name="l00019"></a>00019 <span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a name="l00020"></a>00020 <span class="comment"> * POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00021"></a>00021 <span class="comment"> * </span>
<a name="l00022"></a>00022 <span class="comment"> * NOTE: Portions of this release are directly derived from the SimpleScalar</span>
<a name="l00023"></a>00023 <span class="comment"> * Toolset (property of SimpleScalar LLC), and as such, those portions are</span>
<a name="l00024"></a>00024 <span class="comment"> * bound by the corresponding legal terms and conditions.  All source files</span>
<a name="l00025"></a>00025 <span class="comment"> * derived directly or in part from the SimpleScalar Toolset bear the original</span>
<a name="l00026"></a>00026 <span class="comment"> * user agreement.</span>
<a name="l00027"></a>00027 <span class="comment"> * </span>
<a name="l00028"></a>00028 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00029"></a>00029 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00030"></a>00030 <span class="comment"> * </span>
<a name="l00031"></a>00031 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
<a name="l00032"></a>00032 <span class="comment"> * this list of conditions and the following disclaimer.</span>
<a name="l00033"></a>00033 <span class="comment"> * </span>
<a name="l00034"></a>00034 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<a name="l00035"></a>00035 <span class="comment"> * this list of conditions and the following disclaimer in the documentation</span>
<a name="l00036"></a>00036 <span class="comment"> * and/or other materials provided with the distribution.</span>
<a name="l00037"></a>00037 <span class="comment"> * </span>
<a name="l00038"></a>00038 <span class="comment"> * 3. Neither the name of the Georgia Tech Research Corporation nor the names of</span>
<a name="l00039"></a>00039 <span class="comment"> * its contributors may be used to endorse or promote products derived from</span>
<a name="l00040"></a>00040 <span class="comment"> * this software without specific prior written permission.</span>
<a name="l00041"></a>00041 <span class="comment"> * </span>
<a name="l00042"></a>00042 <span class="comment"> * 4. Zesto is distributed freely for commercial and non-commercial use.  Note,</span>
<a name="l00043"></a>00043 <span class="comment"> * however, that the portions derived from the SimpleScalar Toolset are bound</span>
<a name="l00044"></a>00044 <span class="comment"> * by the terms and agreements set forth by SimpleScalar, LLC.  In particular:</span>
<a name="l00045"></a>00045 <span class="comment"> * </span>
<a name="l00046"></a>00046 <span class="comment"> *   "Nonprofit and noncommercial use is encouraged. SimpleScalar may be</span>
<a name="l00047"></a>00047 <span class="comment"> *   downloaded, compiled, executed, copied, and modified solely for nonprofit,</span>
<a name="l00048"></a>00048 <span class="comment"> *   educational, noncommercial research, and noncommercial scholarship</span>
<a name="l00049"></a>00049 <span class="comment"> *   purposes provided that this notice in its entirety accompanies all copies.</span>
<a name="l00050"></a>00050 <span class="comment"> *   Copies of the modified software can be delivered to persons who use it</span>
<a name="l00051"></a>00051 <span class="comment"> *   solely for nonprofit, educational, noncommercial research, and</span>
<a name="l00052"></a>00052 <span class="comment"> *   noncommercial scholarship purposes provided that this notice in its</span>
<a name="l00053"></a>00053 <span class="comment"> *   entirety accompanies all copies."</span>
<a name="l00054"></a>00054 <span class="comment"> * </span>
<a name="l00055"></a>00055 <span class="comment"> * User is responsible for reading and adhering to the terms set forth by</span>
<a name="l00056"></a>00056 <span class="comment"> * SimpleScalar, LLC where appropriate.</span>
<a name="l00057"></a>00057 <span class="comment"> * </span>
<a name="l00058"></a>00058 <span class="comment"> * 5. No nonprofit user may place any restrictions on the use of this software,</span>
<a name="l00059"></a>00059 <span class="comment"> * including as modified by the user, by any other authorized user.</span>
<a name="l00060"></a>00060 <span class="comment"> * </span>
<a name="l00061"></a>00061 <span class="comment"> * 6. Noncommercial and nonprofit users may distribute copies of Zesto in</span>
<a name="l00062"></a>00062 <span class="comment"> * compiled or executable form as set forth in Section 2, provided that either:</span>
<a name="l00063"></a>00063 <span class="comment"> * (A) it is accompanied by the corresponding machine-readable source code, or</span>
<a name="l00064"></a>00064 <span class="comment"> * (B) it is accompanied by a written offer, with no time limit, to give anyone</span>
<a name="l00065"></a>00065 <span class="comment"> * a machine-readable copy of the corresponding source code in return for</span>
<a name="l00066"></a>00066 <span class="comment"> * reimbursement of the cost of distribution. This written offer must permit</span>
<a name="l00067"></a>00067 <span class="comment"> * verbatim duplication by anyone, or (C) it is distributed by someone who</span>
<a name="l00068"></a>00068 <span class="comment"> * received only the executable form, and is accompanied by a copy of the</span>
<a name="l00069"></a>00069 <span class="comment"> * written offer of source code.</span>
<a name="l00070"></a>00070 <span class="comment"> * </span>
<a name="l00071"></a>00071 <span class="comment"> * 7. Zesto was developed by Gabriel H. Loh, Ph.D.  US Mail: 266 Ferst Drive,</span>
<a name="l00072"></a>00072 <span class="comment"> * Georgia Institute of Technology, Atlanta, GA 30332-0765</span>
<a name="l00073"></a>00073 <span class="comment"> *</span>
<a name="l00074"></a>00074 <span class="comment"> * NOTE: This file (zesto-oracle.cpp) contains code directly and</span>
<a name="l00075"></a>00075 <span class="comment"> * indirectly derived from previous SimpleScalar source files.</span>
<a name="l00076"></a>00076 <span class="comment"> * These sections are demarkated with "&lt;SIMPLESCALAR&gt;" and</span>
<a name="l00077"></a>00077 <span class="comment"> * "&lt;/SIMPLESCALAR&gt;" to specify the start and end, respectively, of</span>
<a name="l00078"></a>00078 <span class="comment"> * such source code.  Such code is bound by the combination of terms</span>
<a name="l00079"></a>00079 <span class="comment"> * and agreements from both Zesto and SimpleScalar.  In case of any</span>
<a name="l00080"></a>00080 <span class="comment"> * conflicting terms (for example, but not limited to, use by</span>
<a name="l00081"></a>00081 <span class="comment"> * commercial entities), the more restrictive terms shall take</span>
<a name="l00082"></a>00082 <span class="comment"> * precedence (e.g., commercial and for-profit entities may not</span>
<a name="l00083"></a>00083 <span class="comment"> * make use of the code without a license from SimpleScalar, LLC).</span>
<a name="l00084"></a>00084 <span class="comment"> * The SimpleScalar terms and agreements are replicated below as per</span>
<a name="l00085"></a>00085 <span class="comment"> * their original requirements.</span>
<a name="l00086"></a>00086 <span class="comment"> *</span>
<a name="l00087"></a>00087 <span class="comment"> * SimpleScalar Ô Tool Suite</span>
<a name="l00088"></a>00088 <span class="comment"> * © 1994-2003 Todd M. Austin, Ph.D. and SimpleScalar, LLC</span>
<a name="l00089"></a>00089 <span class="comment"> * All Rights Reserved.</span>
<a name="l00090"></a>00090 <span class="comment"> * </span>
<a name="l00091"></a>00091 <span class="comment"> * THIS IS A LEGAL DOCUMENT BY DOWNLOADING SIMPLESCALAR, YOU ARE AGREEING TO</span>
<a name="l00092"></a>00092 <span class="comment"> * THESE TERMS AND CONDITIONS.</span>
<a name="l00093"></a>00093 <span class="comment"> * </span>
<a name="l00094"></a>00094 <span class="comment"> * No portion of this work may be used by any commercial entity, or for any</span>
<a name="l00095"></a>00095 <span class="comment"> * commercial purpose, without the prior, written permission of SimpleScalar,</span>
<a name="l00096"></a>00096 <span class="comment"> * LLC (info@simplescalar.com). Nonprofit and noncommercial use is permitted as</span>
<a name="l00097"></a>00097 <span class="comment"> * described below.</span>
<a name="l00098"></a>00098 <span class="comment"> * </span>
<a name="l00099"></a>00099 <span class="comment"> * 1. SimpleScalar is provided AS IS, with no warranty of any kind, express or</span>
<a name="l00100"></a>00100 <span class="comment"> * implied. The user of the program accepts full responsibility for the</span>
<a name="l00101"></a>00101 <span class="comment"> * application of the program and the use of any results.</span>
<a name="l00102"></a>00102 <span class="comment"> * </span>
<a name="l00103"></a>00103 <span class="comment"> * 2. Nonprofit and noncommercial use is encouraged.  SimpleScalar may be</span>
<a name="l00104"></a>00104 <span class="comment"> * downloaded, compiled, executed, copied, and modified solely for nonprofit,</span>
<a name="l00105"></a>00105 <span class="comment"> * educational, noncommercial research, and noncommercial scholarship purposes</span>
<a name="l00106"></a>00106 <span class="comment"> * provided that this notice in its entirety accompanies all copies. Copies of</span>
<a name="l00107"></a>00107 <span class="comment"> * the modified software can be delivered to persons who use it solely for</span>
<a name="l00108"></a>00108 <span class="comment"> * nonprofit, educational, noncommercial research, and noncommercial</span>
<a name="l00109"></a>00109 <span class="comment"> * scholarship purposes provided that this notice in its entirety accompanies</span>
<a name="l00110"></a>00110 <span class="comment"> * all copies.</span>
<a name="l00111"></a>00111 <span class="comment"> * </span>
<a name="l00112"></a>00112 <span class="comment"> * 3. ALL COMMERCIAL USE, AND ALL USE BY FOR PROFIT ENTITIES, IS EXPRESSLY</span>
<a name="l00113"></a>00113 <span class="comment"> * PROHIBITED WITHOUT A LICENSE FROM SIMPLESCALAR, LLC (info@simplescalar.com).</span>
<a name="l00114"></a>00114 <span class="comment"> * </span>
<a name="l00115"></a>00115 <span class="comment"> * 4. No nonprofit user may place any restrictions on the use of this software,</span>
<a name="l00116"></a>00116 <span class="comment"> * including as modified by the user, by any other authorized user.</span>
<a name="l00117"></a>00117 <span class="comment"> * </span>
<a name="l00118"></a>00118 <span class="comment"> * 5. Noncommercial and nonprofit users may distribute copies of SimpleScalar</span>
<a name="l00119"></a>00119 <span class="comment"> * in compiled or executable form as set forth in Section 2, provided that</span>
<a name="l00120"></a>00120 <span class="comment"> * either: (A) it is accompanied by the corresponding machine-readable source</span>
<a name="l00121"></a>00121 <span class="comment"> * code, or (B) it is accompanied by a written offer, with no time limit, to</span>
<a name="l00122"></a>00122 <span class="comment"> * give anyone a machine-readable copy of the corresponding source code in</span>
<a name="l00123"></a>00123 <span class="comment"> * return for reimbursement of the cost of distribution. This written offer</span>
<a name="l00124"></a>00124 <span class="comment"> * must permit verbatim duplication by anyone, or (C) it is distributed by</span>
<a name="l00125"></a>00125 <span class="comment"> * someone who received only the executable form, and is accompanied by a copy</span>
<a name="l00126"></a>00126 <span class="comment"> * of the written offer of source code.</span>
<a name="l00127"></a>00127 <span class="comment"> * </span>
<a name="l00128"></a>00128 <span class="comment"> * 6. SimpleScalar was developed by Todd M. Austin, Ph.D. The tool suite is</span>
<a name="l00129"></a>00129 <span class="comment"> * currently maintained by SimpleScalar LLC (info@simplescalar.com). US Mail:</span>
<a name="l00130"></a>00130 <span class="comment"> * 2395 Timbercrest Court, Ann Arbor, MI 48105.</span>
<a name="l00131"></a>00131 <span class="comment"> * </span>
<a name="l00132"></a>00132 <span class="comment"> * Copyright © 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.</span>
<a name="l00133"></a>00133 <span class="comment"> */</span>
<a name="l00134"></a><a class="code" href="zesto-oracle_8cpp.html#205e53e866813d3a0aab9decb7becf26">00134</a> <span class="preprocessor">#define ZESTO_ORACLE_C</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
<a name="l00137"></a>00137 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00138"></a>00138 <span class="preprocessor">#include &lt;sys/io.h&gt;</span>
<a name="l00139"></a>00139 <span class="preprocessor">#include "<a class="code" href="zesto-qsim_8h.html">zesto-qsim.h</a>"</span>
<a name="l00140"></a>00140 <span class="preprocessor">#include "<a class="code" href="misc_8h.html">misc.h</a>"</span>
<a name="l00141"></a>00141 <span class="preprocessor">#include "<a class="code" href="thread_8h.html">thread.h</a>"</span>
<a name="l00142"></a>00142 <span class="preprocessor">#include "<a class="code" href="syscall_8h.html">syscall.h</a>"</span>
<a name="l00143"></a>00143 <span class="preprocessor">#include "<a class="code" href="sim_8h.html">sim.h</a>"</span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="preprocessor">#include "<a class="code" href="zesto-core_8h.html">zesto-core.h</a>"</span>
<a name="l00146"></a>00146 <span class="preprocessor">#include "<a class="code" href="zesto-opts_8h.html">zesto-opts.h</a>"</span>
<a name="l00147"></a>00147 <span class="preprocessor">#include "<a class="code" href="zesto-oracle_8h.html">zesto-oracle.h</a>"</span>
<a name="l00148"></a>00148 <span class="preprocessor">#include "<a class="code" href="zesto-fetch_8h.html">zesto-fetch.h</a>"</span>
<a name="l00149"></a>00149 <span class="preprocessor">#include "<a class="code" href="zesto-bpred_8h.html">zesto-bpred.h</a>"</span>
<a name="l00150"></a>00150 <span class="preprocessor">#include "<a class="code" href="zesto-decode_8h.html">zesto-decode.h</a>"</span>
<a name="l00151"></a>00151 <span class="preprocessor">#include "<a class="code" href="zesto-alloc_8h.html">zesto-alloc.h</a>"</span>
<a name="l00152"></a>00152 <span class="preprocessor">#include "<a class="code" href="zesto-exec_8h.html">zesto-exec.h</a>"</span>
<a name="l00153"></a>00153 <span class="preprocessor">#include "<a class="code" href="zesto-commit_8h.html">zesto-commit.h</a>"</span>
<a name="l00154"></a>00154 <span class="preprocessor">#include "<a class="code" href="zesto-cache_8h.html">zesto-cache.h</a>"</span>
<a name="l00155"></a>00155 <span class="preprocessor">#include "<a class="code" href="zesto-uncore_8h.html">zesto-uncore.h</a>"</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="preprocessor">#ifdef USE_PIN_TRACES</span>
<a name="l00159"></a><a class="code" href="zesto-oracle_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">00159</a> <span class="preprocessor"></span><a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> <a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[16];
<a name="l00160"></a><a class="code" href="zesto-oracle_8cpp.html#38a36f4cd3940833135cd0c497f726f4">00160</a> <span class="keywordtype">bool</span> <a class="code" href="sim-zesto_8cpp.html#38a36f4cd3940833135cd0c497f726f4">use_stored_nextPC</a>[16];
<a name="l00161"></a>00161 <span class="preprocessor">#else</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="comment">//extern class Vm *v_ptr;</span>
<a name="l00163"></a>00163 <span class="comment">//extern class VmQ *vq_ptr;</span>
<a name="l00164"></a>00164 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TIME_QUANTUM = 0x00ff;
<a name="l00165"></a>00165 CDomain *cd=NULL;
<a name="l00166"></a>00166 <span class="preprocessor">#endif</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keywordtype">bool</span> <a class="code" href="classcore__oracle__t.html#b19f952d312b7f51f6b5c7e6cabfac7b">core_oracle_t::static_members_initialized</a> = <span class="keyword">false</span>;
<a name="l00170"></a>00170  <span class="comment">/* for decode.dep_map */</span>
<a name="l00171"></a>00171 <span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1map__node__t.html">core_oracle_t::map_node_t</a> * <a class="code" href="classcore__oracle__t.html#ed152af32c6f582d03ee8a88f2f399a3">core_oracle_t::map_free_pool</a> = NULL;
<a name="l00172"></a>00172 <span class="keywordtype">int</span> <a class="code" href="classcore__oracle__t.html#2387b57848be51fa71ac1bd00797b4f9">core_oracle_t::map_free_pool_debt</a> = 0;
<a name="l00173"></a>00173 <span class="comment">/* for oracle spec-memory map */</span>
<a name="l00174"></a>00174 <span class="keyword">struct </span><a class="code" href="structspec__byte__t.html">spec_byte_t</a> * <a class="code" href="classcore__oracle__t.html#40543fe5b0ca253b04d69a6f6e69ca10">core_oracle_t::spec_mem_free_pool</a> = NULL;
<a name="l00175"></a>00175 <span class="keywordtype">int</span> <a class="code" href="classcore__oracle__t.html#d0134179be9ff7029eba7c0dc3b448d4">core_oracle_t::spec_mem_pool_debt</a> = 0;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="comment">/* CONSTRUCTOR */</span>
<a name="l00178"></a><a class="code" href="classcore__oracle__t.html#ee5b386437040a0500ffbc2a677a52d3">00178</a> <a class="code" href="classcore__oracle__t.html#ee5b386437040a0500ffbc2a677a52d3">core_oracle_t::core_oracle_t</a>(<span class="keyword">struct</span> <a class="code" href="classcore__t.html">core_t</a> * <span class="keyword">const</span> arg_core):
<a name="l00179"></a>00179   spec_mode(false), hosed(false), MopQ(NULL), MopQ_head(0), MopQ_tail(0),
<a name="l00180"></a>00180   MopQ_num(0), current_Mop(NULL), mem_req_free_pool(NULL),
<a name="l00181"></a>00181   syscall_mem_req_head(NULL), syscall_mem_req_tail(NULL), syscall_mem_reqs(0),
<a name="l00182"></a>00182   syscall_remaining_delay(0)
<a name="l00183"></a>00183 {
<a name="l00184"></a>00184   <span class="comment">/* MopQ should be large enough to support all in-flight</span>
<a name="l00185"></a>00185 <span class="comment">     instructions.  We assume one entry per "slot" in the machine</span>
<a name="l00186"></a>00186 <span class="comment">     (even though in uop-based structures, multiple slots may</span>
<a name="l00187"></a>00187 <span class="comment">     correspond to a single Mop), and then add a few and round up</span>
<a name="l00188"></a>00188 <span class="comment">     just in case. */</span>
<a name="l00189"></a>00189   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a> = arg_core;
<a name="l00190"></a>00190   memset(&amp;<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>,0,<span class="keyword">sizeof</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>));
<a name="l00191"></a>00191   memset(&amp;<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>,0,<span class="keyword">sizeof</span>(<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>));
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="keyword">struct </span><a class="code" href="structcore__knobs__t.html">core_knobs_t</a> * <a class="code" href="sim-zesto_8cpp.html#89a180011adecec49b08c8ef843388fa">knobs</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#a397a3f36f045e3c2a19dafc16dab1c1">knobs</a>;
<a name="l00195"></a>00195   <span class="keywordtype">int</span> temp_MopQ_size = knobs-&gt;<a class="code" href="structcore__knobs__t.html#2b7876a4f411b3ae2041c14a7cae699e">commit</a>.<a class="code" href="structcore__knobs__t.html#8648564800ae0fe984ac1f418deace94">ROB_size</a> +
<a name="l00196"></a>00196                   knobs-&gt;<a class="code" href="structcore__knobs__t.html#59dbf024a4199a4119773f12776f2e06">alloc</a>.<a class="code" href="structcore__knobs__t.html#0b2a5addcef411c228190e315c0ac716">depth</a> * knobs-&gt;<a class="code" href="structcore__knobs__t.html#59dbf024a4199a4119773f12776f2e06">alloc</a>.<a class="code" href="structcore__knobs__t.html#b58b777420f6904e072325942a0c2415">width</a> +
<a name="l00197"></a>00197                   knobs-&gt;<a class="code" href="structcore__knobs__t.html#6dc1fa40282035ef593c34664e66c2a1">decode</a>.<a class="code" href="structcore__knobs__t.html#afce6ee11bf69be92bb7e2f779f58981">uopQ_size</a> + knobs-&gt;<a class="code" href="structcore__knobs__t.html#6dc1fa40282035ef593c34664e66c2a1">decode</a>.<a class="code" href="structcore__knobs__t.html#0b2a5addcef411c228190e315c0ac716">depth</a> * knobs-&gt;<a class="code" href="structcore__knobs__t.html#6dc1fa40282035ef593c34664e66c2a1">decode</a>.<a class="code" href="structcore__knobs__t.html#b58b777420f6904e072325942a0c2415">width</a> +
<a name="l00198"></a>00198                   knobs-&gt;<a class="code" href="structcore__knobs__t.html#7255d0ea236298f95bb8fb003a06c613">fetch</a>.<a class="code" href="structcore__knobs__t.html#2e52f47618b01dd4f95b250f0a6d0337">IQ_size</a> + knobs-&gt;<a class="code" href="structcore__knobs__t.html#7255d0ea236298f95bb8fb003a06c613">fetch</a>.<a class="code" href="structcore__knobs__t.html#0b2a5addcef411c228190e315c0ac716">depth</a> * knobs-&gt;<a class="code" href="structcore__knobs__t.html#7255d0ea236298f95bb8fb003a06c613">fetch</a>.<a class="code" href="structcore__knobs__t.html#b58b777420f6904e072325942a0c2415">width</a> +
<a name="l00199"></a>00199                   knobs-&gt;<a class="code" href="structcore__knobs__t.html#7255d0ea236298f95bb8fb003a06c613">fetch</a>.<a class="code" href="structcore__knobs__t.html#f97a040f494d7b834ea43c3e0f396000">byteQ_size</a> + 64;
<a name="l00200"></a>00200   <a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a> = 1 &lt;&lt; ((int)ceil(log(temp_MopQ_size)/log(2.0)));
<a name="l00201"></a>00201 
<a name="l00202"></a>00202   <span class="comment">//MopQ = (struct Mop_t *)calloc(MopQ_size,sizeof(*MopQ));</span>
<a name="l00203"></a>00203   posix_memalign((<span class="keywordtype">void</span>**)&amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>,16,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>*<span class="keyword">sizeof</span>(*MopQ));
<a name="l00204"></a>00204   <span class="keywordflow">if</span>(!MopQ)
<a name="l00205"></a>00205     <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"failed to calloc MopQ"</span>);
<a name="l00206"></a>00206   memset(MopQ,0,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>*<span class="keyword">sizeof</span>(*MopQ));
<a name="l00207"></a>00207   assert(<span class="keyword">sizeof</span>(*MopQ) % 16 == 0); <span class="comment">// size of Mop is mult of 16</span>
<a name="l00208"></a>00208   assert(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a>) % 16 == 0); <span class="comment">// size of uop is mult of 16</span>
<a name="l00209"></a>00209   <span class="comment">/* head, tail and num will have been calloc'd to zero */</span>
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   <span class="comment">/* This shouldn't be necessary, but I threw it in because valgrind</span>
<a name="l00212"></a>00212 <span class="comment">     (--tool=memcheck) was reporting that Mop-&gt;uop was being used</span>
<a name="l00213"></a>00213 <span class="comment">     uninitialized. */</span>
<a name="l00214"></a>00214   <span class="keywordtype">int</span> i;
<a name="l00215"></a>00215   <span class="keywordflow">for</span>(i=0;i&lt;<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>;i++)
<a name="l00216"></a>00216     MopQ[i].uop = NULL;
<a name="l00217"></a>00217 }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="comment">// DEBUG</span>
<a name="l00220"></a><a class="code" href="zesto-oracle_8cpp.html#4f7a5d6cac7682f923ed4e3a7234921f">00220</a> <span class="keyword">static</span> <a class="code" href="host_8h.html#14de020ee0096509154b24721dbc901a">counter_t</a> <a class="code" href="zesto-oracle_8cpp.html#4f7a5d6cac7682f923ed4e3a7234921f">syscall_mem_accesses</a> = 0;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="comment">/* register oracle-related stats in the stat-database (sdb) */</span>
<a name="l00223"></a>00223 <span class="keywordtype">void</span>
<a name="l00224"></a><a class="code" href="classcore__oracle__t.html#7d71b6dc91df7d7d00820e3aea46f576">00224</a> <a class="code" href="classcore__oracle__t.html#7d71b6dc91df7d7d00820e3aea46f576">core_oracle_t::reg_stats</a>(<span class="keyword">struct</span> <a class="code" href="structstat__sdb__t.html">stat_sdb_t</a> * <span class="keyword">const</span> sdb)
<a name="l00225"></a>00225 {
<a name="l00226"></a>00226   <span class="keywordtype">char</span> buf[1024];
<a name="l00227"></a>00227   <span class="keywordtype">char</span> buf2[1024];
<a name="l00228"></a>00228   <span class="keyword">struct </span><a class="code" href="structthread__t.html">thread_t</a> * arch = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <a class="code" href="zesto_2stats_8h.html#ed9b9c4535e4fc2e59a090d6e8157d4f">stat_reg_note</a>(sdb,<span class="stringliteral">"\n#### ORACLE STATS ####"</span>);
<a name="l00231"></a>00231   sprintf(buf,<span class="stringliteral">"c%d.oracle_num_insn"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00232"></a>00232   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_insn - c%d.oracle_insn_undo"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00233"></a>00233   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"number of instructions executed by oracle"</span>, buf2, <span class="stringliteral">"%12.0f"</span>);
<a name="l00234"></a>00234   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_insn"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00235"></a>00235   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of instructions executed by oracle, including misspec"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#94cb8397eca3462590b990f8e428e0be">oracle_total_insn</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#94cb8397eca3462590b990f8e428e0be">oracle_total_insn</a>, NULL);
<a name="l00236"></a>00236   sprintf(buf,<span class="stringliteral">"c%d.oracle_insn_undo"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00237"></a>00237   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">false</span>, buf, <span class="stringliteral">"total number of instructions undone by oracle (misspeculated insts)"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#4297d18ae42208a6fe8d25fe88ab13c7">oracle_inst_undo</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#4297d18ae42208a6fe8d25fe88ab13c7">oracle_inst_undo</a>, NULL);
<a name="l00238"></a>00238   sprintf(buf,<span class="stringliteral">"c%d.oracle_num_uops"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00239"></a>00239   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_uops - c%d.oracle_uop_undo"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00240"></a>00240   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"number of uops executed by oracle"</span>, buf2, <span class="stringliteral">"%12.0f"</span>);
<a name="l00241"></a>00241   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_uops"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00242"></a>00242   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of uops executed by oracle, including misspec"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#9c6c4ccf8310d7a378ea90b01555d141">oracle_total_uops</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#9c6c4ccf8310d7a378ea90b01555d141">oracle_total_uops</a>, NULL);
<a name="l00243"></a>00243   sprintf(buf,<span class="stringliteral">"c%d.oracle_uop_undo"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00244"></a>00244   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">false</span>, buf, <span class="stringliteral">"total number of uops undone by oracle"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#73d06bc16b62c80eb6e6bb28f4494a98">oracle_uop_undo</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#73d06bc16b62c80eb6e6bb28f4494a98">oracle_uop_undo</a>, NULL);
<a name="l00245"></a>00245   sprintf(buf,<span class="stringliteral">"c%d.oracle_num_eff_uops"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00246"></a>00246   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_eff_uops - c%d.oracle_eff_uop_undo"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00247"></a>00247   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"number of effective uops executed by oracle"</span>, buf2, <span class="stringliteral">"%12.0f"</span>);
<a name="l00248"></a>00248   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_eff_uops"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00249"></a>00249   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of effective uops executed by oracle, including misspec"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#8c9802fcef07a9344070d45736f9af17">oracle_total_eff_uops</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#8c9802fcef07a9344070d45736f9af17">oracle_total_eff_uops</a>, NULL);
<a name="l00250"></a>00250   sprintf(buf,<span class="stringliteral">"c%d.oracle_eff_uop_undo"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00251"></a>00251   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">false</span>, buf, <span class="stringliteral">"total number of effective uops undone by oracle"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#f45e29e7af5cc3d2d4642fde587eb4c7">oracle_eff_uop_undo</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#f45e29e7af5cc3d2d4642fde587eb4c7">oracle_eff_uop_undo</a>, NULL);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   sprintf(buf,<span class="stringliteral">"c%d.oracle_IPC"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00254"></a>00254   sprintf(buf2,<span class="stringliteral">"c%d.oracle_num_insn / c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00255"></a>00255   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"IPC at oracle"</span>, buf2, NULL);
<a name="l00256"></a>00256   sprintf(buf,<span class="stringliteral">"c%d.oracle_uPC"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00257"></a>00257   sprintf(buf2,<span class="stringliteral">"c%d.oracle_num_uops / c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00258"></a>00258   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"uPC at oracle"</span>, buf2, NULL);
<a name="l00259"></a>00259   sprintf(buf,<span class="stringliteral">"c%d.oracle_euPC"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00260"></a>00260   sprintf(buf2,<span class="stringliteral">"c%d.oracle_num_eff_uops / c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00261"></a>00261   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"euPC at oracle"</span>, buf2, NULL);
<a name="l00262"></a>00262   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_IPC"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00263"></a>00263   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_insn / c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00264"></a>00264   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"IPC at oracle, including wrong-path"</span>, buf2, NULL);
<a name="l00265"></a>00265   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_uPC"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00266"></a>00266   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_uops / c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00267"></a>00267   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"uPC at oracle, including wrong-path"</span>, buf2, NULL);
<a name="l00268"></a>00268   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_euPC"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00269"></a>00269   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_eff_uops / c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00270"></a>00270   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"euPC at oracle, including wrong-path"</span>, buf2, NULL);
<a name="l00271"></a>00271   sprintf(buf,<span class="stringliteral">"c%d.avg_oracle_flowlen"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00272"></a>00272   sprintf(buf2,<span class="stringliteral">"c%d.oracle_num_uops / c%d.oracle_num_insn"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00273"></a>00273   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"uops per instruction at oracle"</span>, buf2, NULL);
<a name="l00274"></a>00274   sprintf(buf,<span class="stringliteral">"c%d.avg_oracle_eff_flowlen"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00275"></a>00275   sprintf(buf2,<span class="stringliteral">"c%d.oracle_num_eff_uops / c%d.oracle_num_insn"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00276"></a>00276   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"effective uops per instruction at oracle"</span>, buf2, NULL);
<a name="l00277"></a>00277   sprintf(buf,<span class="stringliteral">"c%d.avg_oracle_total_flowlen"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00278"></a>00278   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_uops / c%d.oracle_total_insn"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00279"></a>00279   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"uops per instruction at oracle, including wrong-path"</span>, buf2, NULL);
<a name="l00280"></a>00280   sprintf(buf,<span class="stringliteral">"c%d.avg_oracle_total_eff_flowlen"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00281"></a>00281   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_eff_uops / c%d.oracle_total_insn"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00282"></a>00282   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"effective uops per instruction at oracle, including wrong-path"</span>, buf2, NULL);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   sprintf(buf,<span class="stringliteral">"c%d.oracle_num_refs"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00285"></a>00285   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of loads and stores executed by oracle"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#9d38f70d7711758002a9f0a103dbddf0">oracle_num_refs</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#9d38f70d7711758002a9f0a103dbddf0">oracle_num_refs</a>, NULL);
<a name="l00286"></a>00286   sprintf(buf,<span class="stringliteral">"c%d.oracle_num_loads"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00287"></a>00287   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of loads executed by oracle"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#b0f22a4d1fc67a8007391bf9d139cbab">oracle_num_loads</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#b0f22a4d1fc67a8007391bf9d139cbab">oracle_num_loads</a>, NULL);
<a name="l00288"></a>00288   sprintf(buf2,<span class="stringliteral">"c%d.oracle_num_refs - c%d.oracle_num_loads"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00289"></a>00289   sprintf(buf,<span class="stringliteral">"c%d.oracle_num_stores"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00290"></a>00290   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of stores executed by oracle"</span>, buf2, <span class="stringliteral">"%12.0f"</span>);
<a name="l00291"></a>00291   sprintf(buf,<span class="stringliteral">"c%d.oracle_num_branches"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00292"></a>00292   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of branches executed by oracle"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#41f068fd35eac1ec28b4fe69b88d1edd">oracle_num_branches</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#41f068fd35eac1ec28b4fe69b88d1edd">oracle_num_branches</a>, NULL);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_refs"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00296"></a>00296   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of loads and stores executed by oracle, including wrong-path"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7fe9765f24e107db96dbb0fb43085d11">oracle_total_refs</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7fe9765f24e107db96dbb0fb43085d11">oracle_total_refs</a>, NULL);
<a name="l00297"></a>00297   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_loads"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00298"></a>00298   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of loads executed by oracle, including wrong-path"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7e3c8f66ac3b8562f5f65a84c99a19c9">oracle_total_loads</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7e3c8f66ac3b8562f5f65a84c99a19c9">oracle_total_loads</a>, NULL);
<a name="l00299"></a>00299   sprintf(buf2,<span class="stringliteral">"c%d.oracle_total_refs - c%d.oracle_total_loads"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00300"></a>00300   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_stores"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00301"></a>00301   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of stores executed by oracle, including wrong-path"</span>, buf2, <span class="stringliteral">"%12.0f"</span>);
<a name="l00302"></a>00302   sprintf(buf,<span class="stringliteral">"c%d.oracle_total_branches"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00303"></a>00303   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total number of branches executed by oracle, including wrong-path"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#437c271d49060c1283eb8a894ca5dda4">oracle_total_branches</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#437c271d49060c1283eb8a894ca5dda4">oracle_total_branches</a>, NULL);
<a name="l00304"></a>00304   sprintf(buf,<span class="stringliteral">"c%d.MopQ_occupancy"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00305"></a>00305   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total oracle MopQ occupancy"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#0fe73f7da6d6422f041b6e1f59fe1a91">MopQ_occupancy</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#0fe73f7da6d6422f041b6e1f59fe1a91">MopQ_occupancy</a>, NULL);
<a name="l00306"></a>00306   sprintf(buf,<span class="stringliteral">"c%d.MopQ_avg"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00307"></a>00307   sprintf(buf2,<span class="stringliteral">"c%d.MopQ_occupancy/c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00308"></a>00308   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"average oracle MopQ occupancy"</span>, buf2, NULL);
<a name="l00309"></a>00309   sprintf(buf,<span class="stringliteral">"c%d.MopQ_full"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00310"></a>00310   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total cycles oracle MopQ was full"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#a9e4d315b27d71b8bafcdf8edb1d0682">MopQ_full_cycles</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#a9e4d315b27d71b8bafcdf8edb1d0682">MopQ_full_cycles</a>, NULL);
<a name="l00311"></a>00311   sprintf(buf,<span class="stringliteral">"c%d.MopQ_frac_full"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00312"></a>00312   sprintf(buf2,<span class="stringliteral">"c%d.MopQ_full/c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00313"></a>00313   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"fraction of cycles oracle MopQ was full"</span>, buf2, NULL);
<a name="l00314"></a>00314   sprintf(buf,<span class="stringliteral">"c%d.oracle_bogus_cycles"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00315"></a>00315   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"total cycles oracle stalled on invalid wrong-path insts"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7cf3db555f89a1f97af10c481a820d51">oracle_bogus_cycles</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7cf3db555f89a1f97af10c481a820d51">oracle_bogus_cycles</a>, NULL);
<a name="l00316"></a>00316   sprintf(buf,<span class="stringliteral">"c%d.oracle_frac_bogus"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00317"></a>00317   sprintf(buf2,<span class="stringliteral">"c%d.oracle_bogus_cycles/c%d.sim_cycle"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00318"></a>00318   <a class="code" href="zesto_2stats_8h.html#f2f491659903b1b21de69fe6c767a64a">stat_reg_formula</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"fraction of cycles oracle stalled on invalid wrong-path insts"</span>, buf2, NULL);
<a name="l00319"></a>00319   sprintf(buf,<span class="stringliteral">"c%d.oracle_emergency_recoveries"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00320"></a>00320   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"number of times this thread underwent an emergency recovery"</span>, &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#ad184ce68308f37e1fb07a5eab624314">num_emergency_recoveries</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#ad184ce68308f37e1fb07a5eab624314">num_emergency_recoveries</a>, NULL);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   <span class="comment">// DEBUG</span>
<a name="l00323"></a>00323   sprintf(buf,<span class="stringliteral">"c%d.syscall_mem_accesses"</span>,arch-&gt;<a class="code" href="structthread__t.html#96d4de2e7317c46b7f55f1ca2ef6a350">id</a>);
<a name="l00324"></a>00324   <a class="code" href="machine_8h.html#d5b220607569cd144bbc637326632a1d">stat_reg_counter</a>(sdb, <span class="keyword">true</span>, buf, <span class="stringliteral">"memory accesses made by system calls"</span>, &amp;<a class="code" href="zesto-oracle_8cpp.html#4f7a5d6cac7682f923ed4e3a7234921f">syscall_mem_accesses</a>, <a class="code" href="zesto-oracle_8cpp.html#4f7a5d6cac7682f923ed4e3a7234921f">syscall_mem_accesses</a>, NULL);
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00327"></a><a class="code" href="classcore__oracle__t.html#494a10decdeba4a3f043cce0186d806a">00327</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#494a10decdeba4a3f043cce0186d806a">core_oracle_t::update_occupancy</a>(<span class="keywordtype">void</span>)
<a name="l00328"></a>00328 {
<a name="l00329"></a>00329     <span class="comment">/* MopQ */</span>
<a name="l00330"></a>00330   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#0fe73f7da6d6422f041b6e1f59fe1a91">MopQ_occupancy</a> += <a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a>;
<a name="l00331"></a>00331   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> &gt;= <a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>)
<a name="l00332"></a>00332     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#a9e4d315b27d71b8bafcdf8edb1d0682">MopQ_full_cycles</a>++;
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a><a class="code" href="classcore__oracle__t.html#476405605981d10733d94063d4441dfe">00335</a> <span class="keyword">struct </span><a class="code" href="structMop__t.html">Mop_t</a> * <a class="code" href="classcore__oracle__t.html#476405605981d10733d94063d4441dfe">core_oracle_t::get_Mop</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> index)
<a name="l00336"></a>00336 {
<a name="l00337"></a>00337   <span class="keywordflow">return</span> &amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[index];
<a name="l00338"></a>00338 }
<a name="l00339"></a>00339 
<a name="l00340"></a><a class="code" href="classcore__oracle__t.html#2c1b1e382fd5cd3a13a52560adf9ce7b">00340</a> <span class="keywordtype">int</span> <a class="code" href="classcore__oracle__t.html#2c1b1e382fd5cd3a13a52560adf9ce7b">core_oracle_t::get_index</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> Mop)
<a name="l00341"></a>00341 {
<a name="l00342"></a>00342   <span class="keywordflow">return</span> Mop - <a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>;
<a name="l00343"></a>00343 }
<a name="l00344"></a>00344 
<a name="l00345"></a><a class="code" href="classcore__oracle__t.html#3d8ea00f353d569980869333b7a92668">00345</a> <span class="keywordtype">int</span> <a class="code" href="classcore__oracle__t.html#3d8ea00f353d569980869333b7a92668">core_oracle_t::next_index</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> index)
<a name="l00346"></a>00346 {
<a name="l00347"></a>00347   <span class="keywordflow">return</span> <a class="code" href="misc_8h.html#ec0decc56f83415e5cd152f876e5dde1">modinc</a>(index,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//return (index+1)%MopQ_size;</span>
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="comment">/* create a new entry in the spec_mem table, insert the entry,</span>
<a name="l00351"></a>00351 <span class="comment">   and return a pointer to the entry. */</span>
<a name="l00352"></a><a class="code" href="classcore__oracle__t.html#f60392fcde2b50e69bf96ef7fa845463">00352</a> <span class="keyword">struct </span><a class="code" href="structspec__byte__t.html">spec_byte_t</a> * <a class="code" href="classcore__oracle__t.html#f60392fcde2b50e69bf96ef7fa845463">core_oracle_t::spec_write_byte</a>(
<a name="l00353"></a>00353     <span class="keyword">const</span> <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> <a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a>,
<a name="l00354"></a>00354     <span class="keyword">const</span> <a class="code" href="host_8h.html#780bd50362a995b802eb8e00f4b0c200">byte_t</a> <a class="code" href="structspec__byte__t.html#529d3138d7fe5292c57c89dea4c355f7">val</a>)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356   <span class="keywordtype">int</span> index = addr &amp; <a class="code" href="zesto-oracle_8h.html#d2111e2165e4a519d36c3f3af50d557e">MEM_HASH_MASK</a>;
<a name="l00357"></a>00357   <span class="keyword">struct </span><a class="code" href="structspec__byte__t.html">spec_byte_t</a> * p = <a class="code" href="classcore__oracle__t.html#b4d62e47b0d6399f7fc7738eb0864f17">get_spec_mem_node</a>();
<a name="l00358"></a>00358   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a>)
<a name="l00359"></a>00359     <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a>-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a> = p;
<a name="l00360"></a>00360   p-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a> = <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a>;
<a name="l00361"></a>00361   <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a> = p;
<a name="l00362"></a>00362   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#6e2657bc63a3f2e608a24a83ae33b9da">head</a> == NULL)
<a name="l00363"></a>00363     <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#6e2657bc63a3f2e608a24a83ae33b9da">head</a> = p;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   p-&gt;<a class="code" href="structspec__byte__t.html#529d3138d7fe5292c57c89dea4c355f7">val</a> = val;
<a name="l00366"></a>00366   p-&gt;<a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a> = addr;
<a name="l00367"></a>00367   <span class="keywordflow">return</span> p;
<a name="l00368"></a>00368 }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="comment">/* return true/false if byte is in table (read from most recent).</span>
<a name="l00371"></a>00371 <span class="comment">   If present, store value in valp. */</span>
<a name="l00372"></a><a class="code" href="classcore__oracle__t.html#24e69274c807607f5ef86295f46eafbf">00372</a> <span class="keywordtype">bool</span> <a class="code" href="classcore__oracle__t.html#24e69274c807607f5ef86295f46eafbf">core_oracle_t::spec_read_byte</a>(
<a name="l00373"></a>00373     <span class="keyword">const</span> <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> <a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a>,
<a name="l00374"></a>00374     <a class="code" href="host_8h.html#780bd50362a995b802eb8e00f4b0c200">byte_t</a> * <span class="keyword">const</span> valp)
<a name="l00375"></a>00375 {
<a name="l00376"></a>00376   <span class="keywordtype">int</span> index = addr &amp; <a class="code" href="zesto-oracle_8h.html#d2111e2165e4a519d36c3f3af50d557e">MEM_HASH_MASK</a>;
<a name="l00377"></a>00377   <span class="keyword">struct </span><a class="code" href="structspec__byte__t.html">spec_byte_t</a> * p = <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a>;
<a name="l00378"></a>00378   <span class="keywordflow">while</span>(p)
<a name="l00379"></a>00379   {
<a name="l00380"></a>00380     <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a> == addr)
<a name="l00381"></a>00381     {
<a name="l00382"></a>00382       *valp = p-&gt;<a class="code" href="structspec__byte__t.html#529d3138d7fe5292c57c89dea4c355f7">val</a>;
<a name="l00383"></a>00383       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00384"></a>00384     }
<a name="l00385"></a>00385     p = p-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a>;
<a name="l00386"></a>00386   }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">/* wrapper so that system call's memory accesses get filtered</span>
<a name="l00392"></a>00392 <span class="comment">   through the cache hierarchy. */</span>
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="keyword">enum</span> <a class="code" href="machine_8h.html#a85392bc9273ef092efe1e9f7422b321">md_fault_type</a>
<a name="l00395"></a><a class="code" href="classcore__oracle__t.html#e266894eeb549a7421ac488d9b18edaf">00395</a> <a class="code" href="classcore__oracle__t.html#e266894eeb549a7421ac488d9b18edaf">core_oracle_t::syscall_mem_access</a>(
<a name="l00396"></a>00396     <span class="keywordtype">int</span> thread_id,
<a name="l00397"></a>00397     <span class="keyword">struct</span> <a class="code" href="structmem__t.html">mem_t</a> *mem,          <span class="comment">/* memory space to access */</span>
<a name="l00398"></a>00398     <span class="keyword">enum</span> <a class="code" href="memory_8h.html#19bf2c6deec285a5faced04c2a2f4b80">mem_cmd</a> cmd,           <span class="comment">/* Read (from sim mem) or Write */</span>
<a name="l00399"></a>00399     <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> <a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a>,             <span class="comment">/* target address to access */</span>
<a name="l00400"></a>00400     <span class="keywordtype">void</span> *vp,                   <span class="comment">/* host memory address to access */</span>
<a name="l00401"></a>00401     <span class="keywordtype">int</span> nbytes)                 <span class="comment">/* number of bytes to access */</span>
<a name="l00402"></a>00402 {
<a name="l00403"></a>00403   <span class="keyword">struct </span><a class="code" href="classcore__t.html">core_t</a> * <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a> = <a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[<a class="code" href="sim-zesto_8cpp.html#f227be61b1f91b71aafae105501d92f7">threads</a>[thread_id]-&gt;<a class="code" href="structthread__t.html#fe142c06b5866f3f0c7cecdcb09dd4b2">current_core</a>];
<a name="l00404"></a>00404   <span class="keywordflow">if</span>(core-&gt;<a class="code" href="classcore__t.html#a397a3f36f045e3c2a19dafc16dab1c1">knobs</a>-&gt;<a class="code" href="structcore__knobs__t.html#cb7140c829f3ecf6ce521d84c327ecb5">memory</a>.<a class="code" href="structcore__knobs__t.html#ad3ab7d73fa5b10b6db7b4892dbbf581">syscall_memory_latency</a>)
<a name="l00405"></a>00405   {
<a name="l00406"></a>00406     <span class="keyword">struct </span><a class="code" href="classcore__oracle__t.html">core_oracle_t</a> * O = core-&gt;<a class="code" href="classcore__t.html#e4ae7e910eea6077916a780537d3210e">oracle</a>;
<a name="l00407"></a>00407     <span class="keyword">enum</span> <a class="code" href="config_2zesto-cache_8h.html#aa2f5ac205a00e5df606ccf951edb255">cache_command</a> c_cmd = (cmd==<a class="code" href="memory_8h.html#19bf2c6deec285a5faced04c2a2f4b80809abe96853e69894bbf8e5730b31348">Read</a>)?<a class="code" href="config_2zesto-cache_8h.html#aa2f5ac205a00e5df606ccf951edb255a614c7f88fbcfcc7dc4e5e9fd697f585">CACHE_READ</a>:<a class="code" href="config_2zesto-cache_8h.html#aa2f5ac205a00e5df606ccf951edb255f31232fbf9e45b41922cf68b09a4a201">CACHE_WRITE</a>;
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     <span class="comment">/* The system call accesses perform the reads/writes</span>
<a name="l00410"></a>00410 <span class="comment">       one byte at a time.  As such, check to see if we</span>
<a name="l00411"></a>00411 <span class="comment">       have back-to-back reads (or writes) to the same</span>
<a name="l00412"></a>00412 <span class="comment">       eight-byte chunk; if so, don't record the subsequent</span>
<a name="l00413"></a>00413 <span class="comment">       access(es) as separate events. */</span>
<a name="l00414"></a>00414     <span class="keywordtype">bool</span> same_access = <span class="keyword">false</span>;
<a name="l00415"></a>00415     <span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html">syscall_mem_req_t</a> * p;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417     <span class="keywordflow">if</span>(O-&gt;<a class="code" href="classcore__oracle__t.html#e0056b27f0e80b013e332555b9779ea0">syscall_mem_req_tail</a>)
<a name="l00418"></a>00418     {
<a name="l00419"></a>00419       p = O-&gt;<a class="code" href="classcore__oracle__t.html#e0056b27f0e80b013e332555b9779ea0">syscall_mem_req_tail</a>;
<a name="l00420"></a>00420       <span class="keywordflow">if</span>((p-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#9544e5f91f355559225644a61ba800a8">thread_id</a> == thread_id) &amp;&amp;
<a name="l00421"></a>00421          (p-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#7e5aefa4c37d59dce5e49925b902d283">cmd</a> == c_cmd) &amp;&amp; ((p-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#eccaddae80488cb6b3851a8a257e268d">addr</a>&amp;~0x7) == (addr&amp;~0x7)))
<a name="l00422"></a>00422          same_access = <span class="keyword">true</span>;
<a name="l00423"></a>00423     }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="keywordflow">if</span>(!same_access)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       <a class="code" href="zesto-oracle_8cpp.html#4f7a5d6cac7682f923ed4e3a7234921f">syscall_mem_accesses</a>++;
<a name="l00428"></a>00428       <span class="keywordflow">if</span>(O-&gt;<a class="code" href="classcore__oracle__t.html#05c50ff07efc7d5f8fbf6bbfbb492b58">mem_req_free_pool</a>)
<a name="l00429"></a>00429       {
<a name="l00430"></a>00430         p = O-&gt;<a class="code" href="classcore__oracle__t.html#05c50ff07efc7d5f8fbf6bbfbb492b58">mem_req_free_pool</a>;
<a name="l00431"></a>00431         O-&gt;<a class="code" href="classcore__oracle__t.html#05c50ff07efc7d5f8fbf6bbfbb492b58">mem_req_free_pool</a> = O-&gt;<a class="code" href="classcore__oracle__t.html#05c50ff07efc7d5f8fbf6bbfbb492b58">mem_req_free_pool</a>-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#c50033a7073082da37aeaa3983e8b0ad">next</a>;
<a name="l00432"></a>00432       }
<a name="l00433"></a>00433       <span class="keywordflow">else</span>
<a name="l00434"></a>00434       {
<a name="l00435"></a>00435         p = (<span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html">syscall_mem_req_t</a>*) calloc(1,<span class="keyword">sizeof</span>(*p));
<a name="l00436"></a>00436         <span class="keywordflow">if</span>(!p)
<a name="l00437"></a>00437           <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"cannot calloc syscall memory request struct"</span>);
<a name="l00438"></a>00438       }
<a name="l00439"></a>00439       p-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#c50033a7073082da37aeaa3983e8b0ad">next</a> = NULL;
<a name="l00440"></a>00440       p-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#eccaddae80488cb6b3851a8a257e268d">addr</a> = addr;
<a name="l00441"></a>00441       p-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#9544e5f91f355559225644a61ba800a8">thread_id</a> = thread_id;
<a name="l00442"></a>00442       p-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#7e5aefa4c37d59dce5e49925b902d283">cmd</a> = c_cmd;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444       <span class="keywordflow">if</span>(O-&gt;<a class="code" href="classcore__oracle__t.html#e0056b27f0e80b013e332555b9779ea0">syscall_mem_req_tail</a>) <span class="comment">/* append to list if any */</span>
<a name="l00445"></a>00445       {
<a name="l00446"></a>00446         assert(O-&gt;<a class="code" href="classcore__oracle__t.html#ff4556f23f40969aeb29752f6320806c">syscall_mem_req_head</a>);
<a name="l00447"></a>00447         O-&gt;<a class="code" href="classcore__oracle__t.html#e0056b27f0e80b013e332555b9779ea0">syscall_mem_req_tail</a>-&gt;<a class="code" href="structcore__oracle__t_1_1syscall__mem__req__t.html#c50033a7073082da37aeaa3983e8b0ad">next</a> = p;
<a name="l00448"></a>00448         O-&gt;<a class="code" href="classcore__oracle__t.html#e0056b27f0e80b013e332555b9779ea0">syscall_mem_req_tail</a> = p;
<a name="l00449"></a>00449       }
<a name="l00450"></a>00450       <span class="keywordflow">else</span> <span class="comment">/* else start new list */</span>
<a name="l00451"></a>00451       {
<a name="l00452"></a>00452         O-&gt;<a class="code" href="classcore__oracle__t.html#ff4556f23f40969aeb29752f6320806c">syscall_mem_req_head</a> = p;
<a name="l00453"></a>00453         O-&gt;<a class="code" href="classcore__oracle__t.html#e0056b27f0e80b013e332555b9779ea0">syscall_mem_req_tail</a> = p;
<a name="l00454"></a>00454       }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456       O-&gt;<a class="code" href="classcore__oracle__t.html#fb70d110090a9c1d7d257ef63d95dd51">syscall_mem_reqs</a>++;
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458   }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   <span class="keywordflow">return</span> <a class="code" href="memory_8h.html#2b4368bb43fd552750bdf3f6e59b7c46">mem_access</a>(thread_id,mem,cmd,addr,vp,nbytes);
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="comment">/* dummy callbacks for system call memory requests */</span>
<a name="l00464"></a><a class="code" href="classcore__oracle__t.html#0f8c8d4e3eb748b911028d64d2a086d8">00464</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#0f8c8d4e3eb748b911028d64d2a086d8">core_oracle_t::syscall_callback</a>(<span class="keywordtype">void</span> * <span class="keyword">const</span> op)
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466   <span class="comment">/* nada */</span>
<a name="l00467"></a>00467 }
<a name="l00468"></a>00468 
<a name="l00469"></a><a class="code" href="classcore__oracle__t.html#a288707f42533b1b2397e9b9b59c2e0f">00469</a> <span class="keywordtype">bool</span> <a class="code" href="classcore__oracle__t.html#a288707f42533b1b2397e9b9b59c2e0f">core_oracle_t::syscall_translated_callback</a>(<span class="keywordtype">void</span> * <span class="keyword">const</span> op, <span class="keyword">const</span> <a class="code" href="zesto-structs_8h.html#12ad2f48066289fd2855fccc710cc150">seq_t</a> action_id)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00472"></a>00472 }
<a name="l00473"></a>00473 
<a name="l00474"></a><a class="code" href="classcore__oracle__t.html#16826da0aea8695f558397af8c0be45b">00474</a> <a class="code" href="zesto-structs_8h.html#12ad2f48066289fd2855fccc710cc150">seq_t</a> <a class="code" href="classcore__oracle__t.html#16826da0aea8695f558397af8c0be45b">core_oracle_t::syscall_get_action_id</a>(<span class="keywordtype">void</span> * <span class="keyword">const</span> op)
<a name="l00475"></a>00475 {
<a name="l00476"></a>00476   <span class="keywordflow">return</span> <a class="code" href="classcore__oracle__t.html#7ae3e4395fe930b73847748c92d269de">DUMMY_SYSCALL_ACTION_ID</a>;
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="comment">/*----------------*/</span>
<a name="l00480"></a>00480  <span class="comment">/* &lt;SIMPLESCALAR&gt; */</span>
<a name="l00481"></a>00481 <span class="comment">/*----------------*/</span>
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="comment">/**********************************************************/</span>
<a name="l00484"></a>00484 <span class="comment">/* CODE FOR ACTUAL ORACLE EXECUTION, RECOVERY, AND COMMIT */</span>
<a name="l00485"></a>00485 <span class="comment">/**********************************************************/</span>
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="comment">/*</span>
<a name="l00488"></a>00488 <span class="comment"> * oracle's register accessors</span>
<a name="l00489"></a>00489 <span class="comment"> */</span>
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="comment">/* general purpose registers */</span>
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="preprocessor">#if defined(TARGET_X86)</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span><span class="comment">/* current program counter */</span>
<a name="l00495"></a><a class="code" href="zesto-oracle_8cpp.html#47928f393a8ffdecfa07271f22beb34b">00495</a> <span class="preprocessor">#define CPC            (thread-&gt;regs.regs_PC)</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>
<a name="l00497"></a>00497 <span class="comment">/* next program counter */</span>
<a name="l00498"></a><a class="code" href="zesto-oracle_8cpp.html#6bc40f3f63777e2bd9deb13953e38b2d">00498</a> <span class="preprocessor">#define NPC            (thread-&gt;regs.regs_NPC)</span>
<a name="l00499"></a><a class="code" href="zesto-oracle_8cpp.html#865b63e02a03e6220f36dfedfaf171f0">00499</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_NPC(EXPR)        (thread-&gt;regs.regs_NPC )// = (EXPR))</span>
<a name="l00500"></a><a class="code" href="zesto-oracle_8cpp.html#237e92c04084e04a6903083038b0d2b3">00500</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_NPC_D(EXPR)         SET_NPC(EXPR)</span>
<a name="l00501"></a><a class="code" href="zesto-oracle_8cpp.html#5df75989ea017f05abfeeaaca9c34c4b">00501</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_NPC_V(EXPR)                            \</span>
<a name="l00502"></a>00502 <span class="preprocessor">  ((Mop-&gt;fetch.inst.mode &amp; MODE_OPER32) ? SET_NPC((EXPR)) : SET_NPC((EXPR) &amp; 0xffff))</span>
<a name="l00503"></a>00503 <span class="preprocessor"></span>
<a name="l00504"></a>00504                                                  <span class="comment">/* general purpose registers */</span>
<a name="l00505"></a><a class="code" href="zesto-oracle_8cpp.html#950ef2d9ae345ed861765730157d37d2">00505</a> <span class="preprocessor">#define _HI(N)            ((N) &amp; 0x04)</span>
<a name="l00506"></a><a class="code" href="zesto-oracle_8cpp.html#711eed827b7f6cfec827e05579cd2b66">00506</a> <span class="preprocessor"></span><span class="preprocessor">#define _ID(N)            ((N) &amp; 0x03)</span>
<a name="l00507"></a><a class="code" href="zesto-oracle_8cpp.html#93a68b4412d259f67d1257b64267534d">00507</a> <span class="preprocessor"></span><span class="preprocessor">#define _ARCH(N)        ((N) &lt; MD_REG_TMP0)</span>
<a name="l00508"></a>00508 <span class="preprocessor"></span>
<a name="l00509"></a>00509                                                  <span class="comment">/* segment registers ; UCSD*/</span>
<a name="l00510"></a><a class="code" href="zesto-oracle_8cpp.html#a3788cd9050f7482f9bd8ac25e0ecf5b">00510</a> <span class="preprocessor">#define SEG_W(N)        (thread-&gt;regs.regs_S.w[N])</span>
<a name="l00511"></a><a class="code" href="zesto-oracle_8cpp.html#0e4a1562565f347b84caa32963258150">00511</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_SEG_W(N,EXPR)    (thread-&gt;regs.regs_S.w[N] = (EXPR))</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>
<a name="l00513"></a><a class="code" href="zesto-oracle_8cpp.html#841ea8fd08139832b659b3ff0d6f0e3d">00513</a> <span class="preprocessor">#define GPR_B(N)        (_ARCH(N)                \</span>
<a name="l00514"></a>00514 <span class="preprocessor">    ? (_HI(N)                \</span>
<a name="l00515"></a>00515 <span class="preprocessor">      ? thread-&gt;regs.regs_R.b[_ID(N)].hi        \</span>
<a name="l00516"></a>00516 <span class="preprocessor">      : thread-&gt;regs.regs_R.b[_ID(N)].lo)      \</span>
<a name="l00517"></a>00517 <span class="preprocessor">    : thread-&gt;regs.regs_R.b[N].lo)</span>
<a name="l00518"></a><a class="code" href="zesto-oracle_8cpp.html#d033dd2415fd695c9d1e8318b6341a2e">00518</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR_B(N,EXPR)    (_ARCH(N)                   \</span>
<a name="l00519"></a>00519 <span class="preprocessor">    ? (_HI(N)                   \</span>
<a name="l00520"></a>00520 <span class="preprocessor">      ? (thread-&gt;regs.regs_R.b[_ID(N)].hi = (EXPR))  \</span>
<a name="l00521"></a>00521 <span class="preprocessor">      : (thread-&gt;regs.regs_R.b[_ID(N)].lo = (EXPR))) \</span>
<a name="l00522"></a>00522 <span class="preprocessor">    : (thread-&gt;regs.regs_R.b[N].lo = (EXPR)))</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span>
<a name="l00524"></a><a class="code" href="zesto-oracle_8cpp.html#49937247dbcf35e59ac3a4103e47259f">00524</a> <span class="preprocessor">#define GPR_W(N)        (thread-&gt;regs.regs_R.w[N].lo)</span>
<a name="l00525"></a><a class="code" href="zesto-oracle_8cpp.html#94bc1db9dcc4e27b6f9dc9b181c1f188">00525</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR_W(N,EXPR)    (thread-&gt;regs.regs_R.w[N].lo = (EXPR))</span>
<a name="l00526"></a>00526 <span class="preprocessor"></span>
<a name="l00527"></a><a class="code" href="zesto-oracle_8cpp.html#47f414f821791526173fe7d70d726fb2">00527</a> <span class="preprocessor">#define GPR_D(N)        (thread-&gt;regs.regs_R.dw[N])</span>
<a name="l00528"></a><a class="code" href="zesto-oracle_8cpp.html#f479882a574ad1c3e8028a799c3c031d">00528</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR_D(N,EXPR)    (thread-&gt;regs.regs_R.dw[N] = (EXPR))</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span>
<a name="l00530"></a>00530                                                  <span class="comment">/* FIXME: move these to the DEF file? */</span>
<a name="l00531"></a><a class="code" href="zesto-oracle_8cpp.html#643f69abe43c44c53ccb513dc75b8edd">00531</a> <span class="preprocessor">#define GPR_V(N)        ((Mop-&gt;fetch.inst.mode &amp; MODE_OPER32)        \</span>
<a name="l00532"></a>00532 <span class="preprocessor">    ? GPR_D(N)                \</span>
<a name="l00533"></a>00533 <span class="preprocessor">    : (dword_t)GPR_W(N))</span>
<a name="l00534"></a><a class="code" href="zesto-oracle_8cpp.html#94ea2069d35ea9a6666a46dd573c310d">00534</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR_V(N,EXPR)    ((Mop-&gt;fetch.inst.mode &amp; MODE_OPER32)        \</span>
<a name="l00535"></a>00535 <span class="preprocessor">    ? SET_GPR_D(N, EXPR)            \</span>
<a name="l00536"></a>00536 <span class="preprocessor">    : SET_GPR_W(N, EXPR))</span>
<a name="l00537"></a>00537 <span class="preprocessor"></span>
<a name="l00538"></a><a class="code" href="zesto-oracle_8cpp.html#fe3b1fb9d4a9bfd28f1f0536e6a52094">00538</a> <span class="preprocessor">#define GPR_A(N)        ((Mop-&gt;fetch.inst.mode &amp; MODE_ADDR32)        \</span>
<a name="l00539"></a>00539 <span class="preprocessor">    ? GPR_D(N)                \</span>
<a name="l00540"></a>00540 <span class="preprocessor">    : (dword_t)GPR_W(N))</span>
<a name="l00541"></a><a class="code" href="zesto-oracle_8cpp.html#aaad11abd50c2dc2ff406fa27cf7678f">00541</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR_A(N,EXPR)    ((Mop-&gt;fetch.inst.mode &amp; MODE_ADDR32)        \</span>
<a name="l00542"></a>00542 <span class="preprocessor">    ? SET_GPR_D(N, EXPR)            \</span>
<a name="l00543"></a>00543 <span class="preprocessor">    : SET_GPR_W(N, EXPR))</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span>
<a name="l00545"></a><a class="code" href="zesto-oracle_8cpp.html#7533b70fb575778a0b20811f5a9c8bb4">00545</a> <span class="preprocessor">#define GPR_S(N)        ((Mop-&gt;fetch.inst.mode &amp; MODE_STACK32)        \</span>
<a name="l00546"></a>00546 <span class="preprocessor">    ? GPR_D(N)                \</span>
<a name="l00547"></a>00547 <span class="preprocessor">    : (dword_t)GPR_W(N))</span>
<a name="l00548"></a><a class="code" href="zesto-oracle_8cpp.html#36c3c33eb0e30cbae3b64c6d0803eae4">00548</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR_S(N,EXPR)    ((Mop-&gt;fetch.inst.mode &amp; MODE_STACK32)        \</span>
<a name="l00549"></a>00549 <span class="preprocessor">    ? SET_GPR_D(N, EXPR)            \</span>
<a name="l00550"></a>00550 <span class="preprocessor">    : SET_GPR_W(N, EXPR))</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span>
<a name="l00552"></a>00552 <span class="comment">/* these are to read/write a 32-bit register corresponding</span>
<a name="l00553"></a>00553 <span class="comment">   to an 8-bit register name (AL/AH/BL/...) */</span>
<a name="l00554"></a><a class="code" href="zesto-oracle_8cpp.html#df3fe7e9d48738a5f50cdcf7267799f7">00554</a> <span class="preprocessor">#define GPR_DB(N)               (_ARCH(N)                               \</span>
<a name="l00555"></a>00555 <span class="preprocessor">    ? thread-&gt;regs.regs_R.dw[_ID(N)]            \</span>
<a name="l00556"></a>00556 <span class="preprocessor">    : thread-&gt;regs.regs_R.dw[N])</span>
<a name="l00557"></a><a class="code" href="zesto-oracle_8cpp.html#156362c48d8e9d87140ae34017f84c4a">00557</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR_DB(N,EXPR)      (_ARCH(N)                                  \</span>
<a name="l00558"></a>00558 <span class="preprocessor">    ? (thread-&gt;regs.regs_R.dw[_ID(N)] = (EXPR))  \</span>
<a name="l00559"></a>00559 <span class="preprocessor">    : (thread-&gt;regs.regs_R.dw[N] = (EXPR)))</span>
<a name="l00560"></a>00560 <span class="preprocessor"></span>
<a name="l00561"></a><a class="code" href="zesto-oracle_8cpp.html#33a09842f2467a215179ba1c4e09653f">00561</a> <span class="preprocessor">#define GPR(N)                  GPR_D(N)</span>
<a name="l00562"></a><a class="code" href="zesto-oracle_8cpp.html#68fae1b429c1b8849ca83f455ad6ea38">00562</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_GPR(N,EXPR)         SET_GPR_D(N,EXPR)</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span>
<a name="l00564"></a><a class="code" href="zesto-oracle_8cpp.html#369389eba049ae8bd5b4de5d660b861f">00564</a> <span class="preprocessor">#define AFLAGS(MSK)        (thread-&gt;regs.regs_C.aflags &amp; (MSK))</span>
<a name="l00565"></a><a class="code" href="zesto-oracle_8cpp.html#c5654cb73f3268e0390e1bd8382c6ad8">00565</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_AFLAGS(EXPR,MSK)    (assert(((EXPR) &amp; ~(MSK)) == 0),    \</span>
<a name="l00566"></a>00566 <span class="preprocessor">    thread-&gt;regs.regs_C.aflags =            \</span>
<a name="l00567"></a>00567 <span class="preprocessor">    ((thread-&gt;regs.regs_C.aflags &amp; ~(MSK))    \</span>
<a name="l00568"></a>00568 <span class="preprocessor">     | ((EXPR) &amp; (MSK))))</span>
<a name="l00569"></a><a class="code" href="zesto-oracle_8cpp.html#ae73cec06b7c25168fc7f1e419d980c4">00569</a> <span class="preprocessor"></span><span class="preprocessor">#define DAFLAGS(MSK) (MSK)</span>
<a name="l00570"></a>00570 <span class="preprocessor"></span>
<a name="l00571"></a><a class="code" href="zesto-oracle_8cpp.html#1a0c942425e8394d87a1262793048912">00571</a> <span class="preprocessor">#define FSW(MSK)        (thread-&gt;regs.regs_C.fsw &amp; (MSK))</span>
<a name="l00572"></a><a class="code" href="zesto-oracle_8cpp.html#9896e158582eb11c95d07047c3fec101">00572</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_FSW(EXPR,MSK)    (assert(((EXPR) &amp; ~(MSK)) == 0),    \</span>
<a name="l00573"></a>00573 <span class="preprocessor">    thread-&gt;regs.regs_C.fsw =            \</span>
<a name="l00574"></a>00574 <span class="preprocessor">    ((thread-&gt;regs.regs_C.fsw &amp; ~(MSK))        \</span>
<a name="l00575"></a>00575 <span class="preprocessor">     | ((EXPR) &amp; (MSK))))</span>
<a name="l00576"></a>00576 <span class="preprocessor"></span>
<a name="l00577"></a>00577                                                  <span class="comment">/* added by cristiano */</span>
<a name="l00578"></a><a class="code" href="zesto-oracle_8cpp.html#9fbb923f79e2e5cdd6c74c94705b21cb">00578</a> <span class="preprocessor">#define CWD(MSK)                (thread-&gt;regs.regs_C.cwd &amp; (MSK))</span>
<a name="l00579"></a><a class="code" href="zesto-oracle_8cpp.html#8071d6de21b945570bfac9589dd49f79">00579</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_CWD(EXPR,MSK)       (assert(((EXPR) &amp; ~(MSK)) == 0),        \</span>
<a name="l00580"></a>00580 <span class="preprocessor">    thread-&gt;regs.regs_C.cwd =                      \</span>
<a name="l00581"></a>00581 <span class="preprocessor">    ((thread-&gt;regs.regs_C.cwd &amp; ~(MSK))            \</span>
<a name="l00582"></a>00582 <span class="preprocessor">     | ((EXPR) &amp; (MSK))))</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span>
<a name="l00584"></a>00584                                                  <span class="comment">/* floating point registers, L-&gt;word, F-&gt;single-prec, D-&gt;double-prec */</span>
<a name="l00585"></a>00585                                                  <span class="comment">/* FIXME: bad overlap, also need to support stack indexing... */</span>
<a name="l00586"></a><a class="code" href="zesto-oracle_8cpp.html#4c385ed05e0bd8490781f35a122a0241">00586</a> <span class="preprocessor">#define _FPARCH(N)      ((N) &lt; MD_REG_FTMP0)</span>
<a name="l00587"></a><a class="code" href="zesto-oracle_8cpp.html#9adbd7a2d18e1ad0c7ae0fe923acad93">00587</a> <span class="preprocessor"></span><span class="preprocessor">#define F2P(N)          (_FPARCH(N) ? ((FSW_TOP(thread-&gt;regs.regs_C.fsw) + (N)) &amp; 0x07) : (N))</span>
<a name="l00588"></a><a class="code" href="zesto-oracle_8cpp.html#fcb75f93887802ec859d1129462e2bc7">00588</a> <span class="preprocessor"></span><span class="preprocessor">#define FPR(N)            (thread-&gt;regs.regs_F.e[F2P(N)])</span>
<a name="l00589"></a><a class="code" href="zesto-oracle_8cpp.html#d1f2e24af906596ccab8c65a695dce70">00589</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_FPR(N,EXPR)        (thread-&gt;regs.regs_F.e[F2P(N)] = (EXPR))</span>
<a name="l00590"></a>00590 <span class="preprocessor"></span>
<a name="l00591"></a><a class="code" href="zesto-oracle_8cpp.html#327a614a72ecd9c0b62884060a1bb259">00591</a> <span class="preprocessor">#define FPSTACK_POP()   SET_FSW_TOP(thread-&gt;regs.regs_C.fsw, (FSW_TOP(thread-&gt;regs.regs_C.fsw) + 1) &amp; 0x07)</span>
<a name="l00592"></a><a class="code" href="zesto-oracle_8cpp.html#33f3b84a911da7e5f45c0ef7c72d2cd1">00592</a> <span class="preprocessor"></span><span class="preprocessor">#define FPSTACK_PUSH()  SET_FSW_TOP(thread-&gt;regs.regs_C.fsw, (FSW_TOP(thread-&gt;regs.regs_C.fsw) + 7) &amp; 0x07)</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span>
<a name="l00594"></a><a class="code" href="zesto-oracle_8cpp.html#a751a02ae08302c577ec12f2ca780b81">00594</a> <span class="preprocessor">#define FPSTACK_IMPL(OP)                            \</span>
<a name="l00595"></a>00595 <span class="preprocessor">{                                    \</span>
<a name="l00596"></a>00596 <span class="preprocessor">  </span><span class="comment">/* if ((OP) == fpstk_nop) - already checked before call of macro */</span>                        \
<a name="l00597"></a>00597   <span class="comment">/* ; */</span>                            \
<a name="l00598"></a>00598   <span class="comment">/* else */</span> if ((OP) == fpstk_pop)                        \
<a name="l00599"></a>00599     SET_FSW_TOP(thread-&gt;regs.regs_C.fsw, (FSW_TOP(thread-&gt;regs.regs_C.fsw)+1)&amp;0x07);\
<a name="l00600"></a>00600   else if ((OP) == fpstk_poppop)                    \
<a name="l00601"></a>00601     SET_FSW_TOP(thread-&gt;regs.regs_C.fsw, (FSW_TOP(thread-&gt;regs.regs_C.fsw)+2)&amp;0x07);\
<a name="l00602"></a>00602   else if ((OP) == fpstk_push)                    \
<a name="l00603"></a>00603     SET_FSW_TOP(thread-&gt;regs.regs_C.fsw, (FSW_TOP(thread-&gt;regs.regs_C.fsw)+7)&amp;0x07);\
<a name="l00604"></a>00604   else                                \
<a name="l00605"></a>00605   panic("bogus FP stack operation");                \
<a name="l00606"></a>00606 }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 <span class="preprocessor">#else</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span><span class="preprocessor">#error No ISA target defined (only x86 supported) ...</span>
<a name="l00610"></a>00610 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 <span class="comment">/* speculative memory state accessor macros */</span>
<a name="l00615"></a>00615 <span class="preprocessor">#ifdef TARGET_X86</span>
<a name="l00616"></a>00616 <span class="preprocessor"></span>
<a name="l00617"></a><a class="code" href="zesto-oracle_8cpp.html#2967bbef616af8861c316b12b5ca3203">00617</a> <span class="preprocessor">#define READ_BYTE(SRC, FAULT)     ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (SRC), uop-&gt;decode.mem_size = 1, XMEM_READ_BYTE(thread-&gt;mem, (SRC)))</span>
<a name="l00618"></a><a class="code" href="zesto-oracle_8cpp.html#6a5dc8a34de59be3e818f3e4e548f6c8">00618</a> <span class="preprocessor"></span><span class="preprocessor">#define READ_WORD(SRC, FAULT)     ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (SRC), uop-&gt;decode.mem_size = 2, XMEM_READ_WORD(thread-&gt;mem, (SRC)))</span>
<a name="l00619"></a><a class="code" href="zesto-oracle_8cpp.html#a2ff7b45c340039544196f5da2de752b">00619</a> <span class="preprocessor"></span><span class="preprocessor">#define READ_DWORD(SRC, FAULT)     ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (SRC), uop-&gt;decode.mem_size = 4, XMEM_READ_DWORD(thread-&gt;mem, (SRC)))</span>
<a name="l00620"></a><a class="code" href="zesto-oracle_8cpp.html#7c5f5d585d91dff10f5b6ca754b421f6">00620</a> <span class="preprocessor"></span><span class="preprocessor">#define READ_QWORD(SRC, FAULT)    ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (SRC), uop-&gt;decode.mem_size = 8, XMEM_READ_QWORD(thread-&gt;mem, (SRC)))</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span>
<a name="l00622"></a><a class="code" href="zesto-oracle_8cpp.html#fc76adbab625381a0c38c41c059ca331">00622</a> <span class="preprocessor">#define WRITE_BYTE(SRC, DST, FAULT)   ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (DST), uop-&gt;decode.mem_size = 1, XMEM_WRITE_BYTE(thread-&gt;mem, (DST), (SRC)))</span>
<a name="l00623"></a><a class="code" href="zesto-oracle_8cpp.html#39396193613c8f3b1a09a4ff205c16da">00623</a> <span class="preprocessor"></span><span class="preprocessor">#define WRITE_WORD(SRC, DST, FAULT)   ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (DST), uop-&gt;decode.mem_size = 2, XMEM_WRITE_WORD(thread-&gt;mem, (DST), (SRC)))</span>
<a name="l00624"></a><a class="code" href="zesto-oracle_8cpp.html#76efb0aae9cc59d15bad44bbdeca75d5">00624</a> <span class="preprocessor"></span><span class="preprocessor">#define WRITE_DWORD(SRC, DST, FAULT)   ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (DST), uop-&gt;decode.mem_size = 4, XMEM_WRITE_DWORD(thread-&gt;mem, (DST), (SRC)))</span>
<a name="l00625"></a><a class="code" href="zesto-oracle_8cpp.html#973ac8efc8287f3aebe50e8cf1aef741">00625</a> <span class="preprocessor"></span><span class="preprocessor">#define WRITE_QWORD(SRC, DST, FAULT)  ((FAULT) = md_fault_none, uop-&gt;oracle.virt_addr = (DST), uop-&gt;decode.mem_size = 8, XMEM_WRITE_QWORD(thread-&gt;mem, (DST), (SRC)))</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span>
<a name="l00627"></a>00627 <span class="comment">/* this is for FSTE */</span>
<a name="l00628"></a><a class="code" href="zesto-oracle_8cpp.html#5d75212fc6c9f2094fabfe9c7cbe8e35">00628</a> <span class="preprocessor">#define WRITE_DWORD2(SRC, DST, FAULT)   (uop-&gt;decode.mem_size = 12, XMEM_WRITE_DWORD2(thread-&gt;mem, (DST), (SRC)))</span>
<a name="l00629"></a>00629 <span class="preprocessor"></span>
<a name="l00630"></a>00630 <span class="preprocessor">#else </span><span class="comment">/* !TARGET_X86 */</span>
<a name="l00631"></a>00631 <span class="preprocessor">#error No ISA target defined (only x86 supported) ...</span>
<a name="l00632"></a>00632 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00633"></a>00633 <span class="preprocessor"></span>
<a name="l00634"></a>00634                                                  <span class="comment">/* system call handler macro */</span>
<a name="l00635"></a><a class="code" href="zesto-oracle_8cpp.html#72bc0399d2dd2ad179b9c5f0505551e2">00635</a> <span class="preprocessor">#define SYSCALL(INST)     unsigned int tni=0</span>
<a name="l00636"></a>00636 <span class="preprocessor"></span>
<a name="l00637"></a>00637   <span class="comment">/*-----------------*/</span>
<a name="l00638"></a>00638  <span class="comment">/* &lt;/SIMPLESCALAR&gt; */</span>
<a name="l00639"></a>00639 <span class="comment">/*-----------------*/</span>
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="comment">/* Inst/uop execution functions: doing this allows you to actually</span>
<a name="l00643"></a>00643 <span class="comment">   compile this file (zesto-oracle.c) with optimizations turned on</span>
<a name="l00644"></a>00644 <span class="comment">   (e.g. gcc -O3), since without it, the giant switch was making gcc</span>
<a name="l00645"></a>00645 <span class="comment">   run out of memory. */</span>
<a name="l00646"></a><a class="code" href="zesto-oracle_8cpp.html#0d06a1978d25d25a08e7365790bb9cea">00646</a> <span class="preprocessor">#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,I1,I2,I3,OFLAGS,IFLAGS)\</span>
<a name="l00647"></a>00647 <span class="preprocessor">static inline void SYMCAT(OP,_IMPL_FUNC)(struct thread_t * const thread, struct core_t * const core, struct Mop_t * const Mop, struct uop_t * const uop, bool * const bogus)               \</span>
<a name="l00648"></a>00648 <span class="preprocessor">     SYMCAT(OP,_IMPL)</span>
<a name="l00649"></a><a class="code" href="zesto-oracle_8cpp.html#f554fbf4d732dcec84d863e7903d8c86">00649</a> <span class="preprocessor"></span><span class="preprocessor">#define DEFUOP(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,I1,I2,I3,OFLAGS,IFLAGS)\</span>
<a name="l00650"></a>00650 <span class="preprocessor">static inline void SYMCAT(OP,_IMPL_FUNC)(struct thread_t * const thread, struct core_t * const core, struct Mop_t * const Mop, struct uop_t * const uop, bool * const bogus)               \</span>
<a name="l00651"></a>00651 <span class="preprocessor">     SYMCAT(OP,_IMPL)</span>
<a name="l00652"></a><a class="code" href="zesto-oracle_8cpp.html#e2e57a47696d1134596738df09c2a5f2">00652</a> <span class="preprocessor"></span><span class="preprocessor">#define DEFLINK(OP,MSK,NAME,MASK,SHIFT)</span>
<a name="l00653"></a><a class="code" href="zesto-oracle_8cpp.html#39a7648865000d8fa2ae64257cb18132">00653</a> <span class="preprocessor"></span><span class="preprocessor">#define CONNECT(OP)</span>
<a name="l00654"></a><a class="code" href="zesto-oracle_8cpp.html#598ae1e60cce3e06a2f531d8a3de36a1">00654</a> <span class="preprocessor"></span><span class="preprocessor">#define DECLARE_FAULT(FAULT)                        \</span>
<a name="l00655"></a>00655 <span class="preprocessor">      { uop-&gt;oracle.fault = (FAULT); return; }</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span><span class="preprocessor">#include "machine.def"</span>
<a name="l00657"></a>00657 <span class="preprocessor">#undef DEFINST</span>
<a name="l00658"></a>00658 <span class="preprocessor"></span><span class="preprocessor">#undef DEFUOP</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span><span class="preprocessor">#undef DEFLINK</span>
<a name="l00660"></a>00660 <span class="preprocessor"></span><span class="preprocessor">#undef DECLARE_FAULT</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span>
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="comment">/* The following code is derived from the original execution</span>
<a name="l00664"></a>00664 <span class="comment">   code in the SimpleScalar/x86 pre-release, but it has been</span>
<a name="l00665"></a>00665 <span class="comment">   extensively modified for the way we're doing things in Zesto.</span>
<a name="l00666"></a>00666 <span class="comment">   Major changes include the handling of REP instructions and</span>
<a name="l00667"></a>00667 <span class="comment">   handling of execution down wrong control paths. */</span>
<a name="l00668"></a>00668 <span class="keyword">struct </span><a class="code" href="structMop__t.html">Mop_t</a> *
<a name="l00669"></a><a class="code" href="classcore__oracle__t.html#1ac2b1204cef575e22d1d03c3ce4cff9">00669</a> <a class="code" href="classcore__oracle__t.html#1ac2b1204cef575e22d1d03c3ce4cff9">core_oracle_t::exec</a>(<span class="keyword">const</span> <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> requested_PC)
<a name="l00670"></a>00670 {
<a name="l00671"></a>00671   <span class="keyword">struct </span><a class="code" href="structthread__t.html">thread_t</a> * thread = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>;
<a name="l00672"></a>00672   <span class="keyword">struct </span><a class="code" href="structcore__knobs__t.html">core_knobs_t</a> * <a class="code" href="sim-zesto_8cpp.html#89a180011adecec49b08c8ef843388fa">knobs</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#a397a3f36f045e3c2a19dafc16dab1c1">knobs</a>;
<a name="l00673"></a>00673   <span class="keywordtype">int</span> flow_index = 0;        <span class="comment">/* index into flowtab */</span>
<a name="l00674"></a>00674   <a class="code" href="machine_8h.html#48101d661bf0d09982b8eae832f2df44">uop_inst_t</a> flowtab[<a class="code" href="machine_8h.html#b5025b1f354449f9b67d69c6c7271a48">MD_MAX_FLOWLEN</a>+2];    <span class="comment">/* table of uops, +2 for REP control uops */</span>
<a name="l00675"></a>00675   <span class="keyword">struct </span><a class="code" href="structMop__t.html">Mop_t</a> * Mop = NULL;
<a name="l00676"></a>00676   <span class="keywordtype">bool</span> * bogus = &amp;<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#ced0dd38e3004abe40e9eeb7ab865c1f">bogus</a>;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678   <span class="keywordtype">int</span> wrote_spec_mem = <span class="keyword">false</span>;
<a name="l00679"></a>00679 
<a name="l00681"></a>00681 
<a name="l00682"></a>00682   
<a name="l00683"></a>00683   <span class="keywordflow">if</span>(*bogus) <span class="comment">/* are we on a wrong path and fetched bogus insts? */</span>
<a name="l00684"></a>00684   {
<a name="l00685"></a>00685     assert(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>);
<a name="l00686"></a>00686     <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7cf3db555f89a1f97af10c481a820d51">oracle_bogus_cycles</a>++;)
<a name="l00687"></a>00687     <span class="keywordflow">return</span> NULL;
<a name="l00688"></a>00688   }
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   <span class="comment">//if(core-&gt;stat.oracle_total_insn &gt; 20000000)</span>
<a name="l00691"></a>00691         <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#68240450aa17761096c76bb4732a4e64">uncore</a>-&gt;<a class="code" href="classuncore__t.html#e029dbd483564fa07f30996f3e2d84ab">log_trace</a>=<span class="keyword">true</span>;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 <span class="comment">//  /* process the memory requests generated by the system call*/</span>
<a name="l00694"></a>00694 <span class="comment">//  if(syscall_mem_reqs &gt; 0)</span>
<a name="l00695"></a>00695 <span class="comment">//  {</span>
<a name="l00696"></a>00696 <span class="comment">//    if(MopQ_num &lt;= 1)</span>
<a name="l00697"></a>00697 <span class="comment">//    {</span>
<a name="l00698"></a>00698 <span class="comment">//      struct syscall_mem_req_t * p = syscall_mem_req_head;</span>
<a name="l00699"></a>00699 <span class="comment">//      assert(p);</span>
<a name="l00700"></a>00700 <span class="comment">//</span>
<a name="l00701"></a>00701 <span class="comment">//      /* wait N cycles between launching successive memory requests */</span>
<a name="l00702"></a>00702 <span class="comment">//      if(knobs-&gt;memory.syscall_memory_latency &amp;&amp; syscall_remaining_delay &gt; 0)</span>
<a name="l00703"></a>00703 <span class="comment">//      {</span>
<a name="l00704"></a>00704 <span class="comment">//        syscall_remaining_delay --;</span>
<a name="l00705"></a>00705 <span class="comment">//        return NULL;</span>
<a name="l00706"></a>00706 <span class="comment">//      }</span>
<a name="l00707"></a>00707 <span class="comment">//</span>
<a name="l00708"></a>00708 <span class="comment">//      if(!cache_enqueuable(core-&gt;memory.DL1,core-&gt;current_thread-&gt;id,p-&gt;addr))</span>
<a name="l00709"></a>00709 <span class="comment">//        return NULL;</span>
<a name="l00710"></a>00710 <span class="comment">//</span>
<a name="l00711"></a>00711 <span class="comment">//      cache_enqueue(core,core-&gt;memory.DL1,NULL,p-&gt;cmd,core-&gt;current_thread-&gt;id,0,p-&gt;addr,DUMMY_SYSCALL_ACTION_ID,0,NO_MSHR,(void*)DUMMY_SYSCALL_OP,syscall_callback,NULL,syscall_translated_callback,syscall_get_action_id);</span>
<a name="l00712"></a>00712 <span class="comment">//      core-&gt;exec-&gt;update_last_completed(sim_cycle);</span>
<a name="l00713"></a>00713 <span class="comment">//      syscall_remaining_delay = knobs-&gt;memory.syscall_memory_latency - 1; /* credit this cycle */</span>
<a name="l00714"></a>00714 <span class="comment">//</span>
<a name="l00715"></a>00715 <span class="comment">//    /* successfully enqueued the request, so remove the request from</span>
<a name="l00716"></a>00716 <span class="comment">//         the list */</span>
<a name="l00717"></a>00717 <span class="comment">//    syscall_mem_req_head = p-&gt;next;</span>
<a name="l00718"></a>00718 <span class="comment">//    syscall_mem_reqs--;</span>
<a name="l00719"></a>00719 <span class="comment">//    if(syscall_mem_req_head == NULL)</span>
<a name="l00720"></a>00720 <span class="comment">//      {</span>
<a name="l00721"></a>00721 <span class="comment">//        syscall_mem_req_tail = NULL;</span>
<a name="l00722"></a>00722 <span class="comment">//        assert(syscall_mem_reqs == 0);</span>
<a name="l00723"></a>00723 <span class="comment">//      }</span>
<a name="l00724"></a>00724 <span class="comment">//</span>
<a name="l00725"></a>00725 <span class="comment">//      /* put back into free pool */</span>
<a name="l00726"></a>00726 <span class="comment">//      p-&gt;next = mem_req_free_pool;</span>
<a name="l00727"></a>00727 <span class="comment">//      mem_req_free_pool = p;</span>
<a name="l00728"></a>00728 <span class="comment">//</span>
<a name="l00729"></a>00729 <span class="comment">//      assert(syscall_mem_reqs &gt;= 0);</span>
<a name="l00730"></a>00730 <span class="comment">//</span>
<a name="l00731"></a>00731 <span class="comment">//      return NULL;</span>
<a name="l00732"></a>00732 <span class="comment">//    }</span>
<a name="l00733"></a>00733 <span class="comment">//    else</span>
<a name="l00734"></a>00734 <span class="comment">//      return NULL;</span>
<a name="l00735"></a>00735 <span class="comment">//  }</span>
<a name="l00736"></a>00736 <span class="comment">//  assert(syscall_mem_reqs == 0);</span>
<a name="l00737"></a>00737 
<a name="l00738"></a>00738   <span class="comment">//if(sim_cycle==2599461)</span>
<a name="l00739"></a>00739         <span class="comment">//exit(0);  </span>
<a name="l00740"></a>00740 
<a name="l00741"></a>00741   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>) <span class="comment">/* we already have a Mop */</span>
<a name="l00742"></a>00742   {    
<a name="l00743"></a>00743     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#2ac0786c8628d0e7042cdc07a8d6fcdd">is_trap</a>) <span class="comment">/* this isn't necessary, but it saves us redecoding the trap over and over again */</span>
<a name="l00744"></a>00744     {
<a name="l00746"></a>00746       <span class="comment">/* make sure pipeline has drained */</span>
<a name="l00747"></a>00747       <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> &gt; 1) <span class="comment">/* 1 since the trap itself is in the MopQ */</span>
<a name="l00748"></a>00748       {
<a name="l00750"></a>00750           <span class="keywordflow">return</span> NULL;
<a name="l00751"></a>00751       }
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753     <span class="keywordflow">else</span>
<a name="l00754"></a>00754     {
<a name="l00755"></a>00755             <span class="comment">//fprintf(stdout,"\nI am here Crossed current_Mop is not a TRAP\n ");</span>
<a name="l00756"></a>00756             assert(<a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>-&gt;<a class="code" href="structuop__t.html#b61a7ea0dc1ac39e3e55da42e98454f0">timing</a>.<a class="code" href="structuop__t.html#0d34db19472056540aed52be61665241">when_ready</a> == <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>);
<a name="l00757"></a>00757             assert(<a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>-&gt;<a class="code" href="structuop__t.html#b61a7ea0dc1ac39e3e55da42e98454f0">timing</a>.<a class="code" href="structuop__t.html#780ed24e3aa8b3709e7a93c88ff31132">when_issued</a> == <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>);
<a name="l00758"></a>00758             assert(<a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>-&gt;<a class="code" href="structuop__t.html#b61a7ea0dc1ac39e3e55da42e98454f0">timing</a>.<a class="code" href="structuop__t.html#6a823830b3496618e63ce4486f60fe8c">when_exec</a> == <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>);
<a name="l00759"></a>00759             assert(<a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>-&gt;<a class="code" href="structuop__t.html#b61a7ea0dc1ac39e3e55da42e98454f0">timing</a>.<a class="code" href="structuop__t.html#bad67330b68f9df896e3846b50df1f14">when_completed</a> == <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>);
<a name="l00760"></a>00760     }
<a name="l00763"></a>00763     <span class="keywordflow">return</span> <a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>;
<a name="l00764"></a>00764   }
<a name="l00765"></a>00765   <span class="keywordflow">else</span>
<a name="l00766"></a>00766   {
<a name="l00767"></a>00767     Mop = &amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[<a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a>];
<a name="l00768"></a>00768   }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770   
<a name="l00771"></a>00771   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> &gt;= <a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>)
<a name="l00772"></a>00772   {
<a name="l00773"></a>00773     <span class="comment">/* warnonce("MopQ full: consider increasing MopQ size"); */</span>
<a name="l00774"></a>00774     <span class="keywordflow">return</span> NULL;
<a name="l00775"></a>00775   }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777   <span class="comment">/* reset Mop state; we return the uop array here (rather than when the Mop is</span>
<a name="l00778"></a>00778 <span class="comment">     committed) just to leave information around to help debug insts that have</span>
<a name="l00779"></a>00779 <span class="comment">     already committed. */</span>
<a name="l00780"></a>00780   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>)
<a name="l00781"></a>00781     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#466dcf5a0ecb9fd32ad557561286dfc9">return_uop_array</a>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>);
<a name="l00782"></a>00782   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#d9a45d86038d1410219106b4d6757052">zero_Mop</a>(Mop);
<a name="l00783"></a>00783   Mop-&gt;<a class="code" href="structMop__t.html#7cbb20c576aa6fff6bfcbd39a074528f">timing</a>.<a class="code" href="structMop__t.html#074734a2c4989bb09528dc993321a01b">when_fetch_started</a> = <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>;
<a name="l00784"></a>00784   Mop-&gt;<a class="code" href="structMop__t.html#7cbb20c576aa6fff6bfcbd39a074528f">timing</a>.<a class="code" href="structMop__t.html#9e740f401f882c0173adc702cea64834">when_fetched</a> = <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>;
<a name="l00785"></a>00785   Mop-&gt;<a class="code" href="structMop__t.html#7cbb20c576aa6fff6bfcbd39a074528f">timing</a>.<a class="code" href="structMop__t.html#7c4a056d45928f498938f5a5b96bc3f0">when_MS_started</a> = <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>;
<a name="l00786"></a>00786   Mop-&gt;<a class="code" href="structMop__t.html#7cbb20c576aa6fff6bfcbd39a074528f">timing</a>.<a class="code" href="structMop__t.html#d07da636f69ae00564cc491a2efc2a95">when_decode_started</a> = <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>;
<a name="l00787"></a>00787   Mop-&gt;<a class="code" href="structMop__t.html#7cbb20c576aa6fff6bfcbd39a074528f">timing</a>.<a class="code" href="structMop__t.html#d1e4ae6820210aefb1091db30d72f2a8">when_decode_finished</a> = <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>;
<a name="l00788"></a>00788   Mop-&gt;<a class="code" href="structMop__t.html#7cbb20c576aa6fff6bfcbd39a074528f">timing</a>.<a class="code" href="structMop__t.html#bb62262ae07e9e18cb4869c709e366ad">when_commit_started</a> = <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>;
<a name="l00789"></a>00789   Mop-&gt;<a class="code" href="structMop__t.html#7cbb20c576aa6fff6bfcbd39a074528f">timing</a>.<a class="code" href="structMop__t.html#e1bbc6ef1aa73472c028b716fc3c5ef8">when_commit_finished</a> = <a class="code" href="host_8h.html#d6479e80718c30aee08a7e9cc5cf9668">TICK_T_MAX</a>;
<a name="l00790"></a>00790   Mop-&gt;<a class="code" href="structMop__t.html#9de159d013ea3a9cca480a4d459d5eb4">valid</a> = <span class="keyword">true</span>;
<a name="l00791"></a>00791   Mop-&gt;<a class="code" href="structMop__t.html#2ab1350e46f43d1327adc1457ac77372">core</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   <span class="comment">/* go to next instruction */</span>
<a name="l00794"></a>00794   <span class="keywordflow">if</span>(requested_PC != thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>)
<a name="l00795"></a>00795   {
<a name="l00798"></a>00798         
<a name="l00799"></a>00799     <a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a> = <span class="keyword">true</span>;
<a name="l00801"></a>00801   }
<a name="l00802"></a>00802   Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#92d2861b39c23b47dd58854da3288e81">spec_mode</a> = <a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804   thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> = requested_PC;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l00807"></a>00807   {
<a name="l00808"></a>00808         Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#cd464d5bc7356337ebd2ce89f968991c">code</a>[0]=<a class="code" href="machine_8h.html#0fffd32d95bb6273df749071509e6476">MD_NOP_INST</a>.<a class="code" href="structmd__inst__t.html#cd464d5bc7356337ebd2ce89f968991c">code</a>[0];
<a name="l00809"></a>00809         <a class="code" href="machine_8h.html#7d127ef0f1f9750b48bb0085c83af02a">MD_SET_OPCODE_DURING_FETCH</a>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a>, Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>);
<a name="l00810"></a>00810         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a> == <a class="code" href="machine_8h.html#f9cc7c84fab2d337413c6ba6ecf4924223a4605400bf2f908b89da0d2aa728be">OP_NA</a>)
<a name="l00811"></a>00811                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a> = NOP;
<a name="l00812"></a>00812         Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> = <a class="code" href="machine_8h.html#9b0f21d8388c386bb4159d06bcf1ed72">MD_OP_FLAGS</a>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a>);
<a name="l00813"></a>00813         thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>=thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>;
<a name="l00814"></a>00814   }
<a name="l00815"></a>00815   <span class="keywordflow">else</span>
<a name="l00816"></a>00816   {
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 refetch_nextPC:
<a name="l00819"></a>00819         <span class="comment">/* get the next instruction to execute */</span>
<a name="l00820"></a>00820         <span class="comment">/* read raw bytes from virtual memory */</span>
<a name="l00821"></a>00821         <a class="code" href="zesto-oracle_8h.html#465a782fc5c7f5e58a637011cd6c26ed">MD_FETCH_INST</a>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>, thread-&gt;<a class="code" href="structthread__t.html#5a5007f71bf42d78ac7305cd30f7dd3f">mem</a>, thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>, <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#3a8653bac0ed9aefff8d1679ca81546f">id</a>);
<a name="l00822"></a>00822         <span class="comment">/* then decode the instruction */</span>
<a name="l00823"></a>00823         <a class="code" href="machine_8h.html#7d127ef0f1f9750b48bb0085c83af02a">MD_SET_OPCODE_DURING_FETCH</a>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a>, Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>);
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#5dad80b28e8ae15c2bd387663d32fb7e">len</a>=Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#d7a24ed96b5a93217bf1cbd39c2bb859">qemu_len</a>;
<a name="l00829"></a>00829 
<a name="l00830"></a>00830         <span class="comment">/*Copying the Physical and virtual address of fetch.inst into the Macro-op struct addr</span>
<a name="l00831"></a>00831 <span class="comment">        This is not necessary but is more cleaner to add an addr struct to handle pagetables*/</span>
<a name="l00832"></a>00832         <span class="comment">//Mop-&gt;addr.vaddr=Mop-&gt;fetch.inst.vaddr;</span>
<a name="l00833"></a>00833         <span class="comment">//Mop-&gt;addr.paddr=Mop-&gt;fetch.inst.paddr;</span>
<a name="l00834"></a>00834    
<a name="l00835"></a>00835 
<a name="l00836"></a>00836         <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> nextPC,<a class="code" href="structMop__t.html#5645e3dfe55b1b6b2206ffb38379c44d">PC</a>;
<a name="l00837"></a>00837         <a class="code" href="zesto-oracle_8h.html#486f7c7db21691d4d34a7818717e98b8">MD_FETCH_NEXT_PC</a>(nextPC,<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#3a8653bac0ed9aefff8d1679ca81546f">id</a>);
<a name="l00838"></a>00838         <span class="keywordflow">if</span>(nextPC==0)
<a name="l00839"></a>00839         {
<a name="l00840"></a>00840                 thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a> = thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> + <a class="code" href="machine_8h.html#14c2828e3f3d84cfb676273b5dfc5bf8">MD_INST_SIZE</a>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>);
<a name="l00841"></a>00841                 <span class="comment">//fprintf(stdout,"\n[%lld]Oracle nextPC is zero!! Adding inst.len %llx Instr Length: %d",sim_cycle,thread-&gt;regs.regs_NPC,Mop-&gt;fetch.inst.len);</span>
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843         <span class="keywordflow">else</span>
<a name="l00844"></a>00844         {
<a name="l00845"></a>00845                 thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>=nextPC;
<a name="l00847"></a>00847         }
<a name="l00848"></a>00848         <span class="comment">/* convert XCHG X,X to NOPs (XCHG EAX,EAX already identified-as/synonomous-with NOP) */</span>
<a name="l00849"></a>00849         <span class="keywordflow">if</span>( ((Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a> == XCHG_RMvRv) || (Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a> == XCHG_RMbRb)) &amp;&amp; (<a class="code" href="machine_8h.html#5c71a5e59a53413cd6c270266d63b031">R</a>==<a class="code" href="machine_8h.html#4608958cdf4c8b8ff0a6e301c4c23ae1">RM</a>))
<a name="l00850"></a>00850                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a> = NOP;
<a name="l00851"></a>00851         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a> == <a class="code" href="machine_8h.html#f9cc7c84fab2d337413c6ba6ecf4924223a4605400bf2f908b89da0d2aa728be">OP_NA</a>)
<a name="l00852"></a>00852                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a> = NOP;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#4d78627f97c622df4b1a9ea232bdc5ce">rep_seq</a> = thread-&gt;<a class="code" href="structthread__t.html#d907b780c1717ccfc70ddc4c6f56d17b">rep_sequence</a>;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856         Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> = <a class="code" href="machine_8h.html#9b0f21d8388c386bb4159d06bcf1ed72">MD_OP_FLAGS</a>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#59504c7680bff25f84fca7951439626a">op</a>);
<a name="l00857"></a>00857         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a>)
<a name="l00858"></a>00858                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> |= <a class="code" href="machine_8h.html#bfe46b85c1701b4a87f12f7e62f2fa09">F_COND</a>|<a class="code" href="machine_8h.html#366552bee0ef835c75db8fedf12c11f7">F_CTRL</a>;
<a name="l00859"></a>00859         Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#64bb9f9c135012445c43e8823e98bb3d">is_ctrl</a> = !!(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> &amp; <a class="code" href="machine_8h.html#366552bee0ef835c75db8fedf12c11f7">F_CTRL</a>);
<a name="l00860"></a>00860         <span class="keywordflow">if</span>(!Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#64bb9f9c135012445c43e8823e98bb3d">is_ctrl</a> &amp;&amp; !Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a>)        <span class="comment">//TODO it broke after two days check if any control instructions can come consecutively like the '88 7' case</span>
<a name="l00861"></a>00861         {
<a name="l00862"></a>00862                 <span class="keywordflow">if</span>(thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>==thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>)
<a name="l00863"></a>00863                         <span class="keywordflow">goto</span> refetch_nextPC;
<a name="l00864"></a>00864         }
<a name="l00865"></a>00865   }
<a name="l00866"></a>00866   Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#2ac0786c8628d0e7042cdc07a8d6fcdd">is_trap</a> = !!(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> &amp; <a class="code" href="machine_8h.html#fca5911ccd3348339952f3772240aa24">F_TRAP</a>);
<a name="l00867"></a>00867   Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#64bb9f9c135012445c43e8823e98bb3d">is_ctrl</a> = !!(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> &amp; <a class="code" href="machine_8h.html#366552bee0ef835c75db8fedf12c11f7">F_CTRL</a>);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> &amp; <a class="code" href="machine_8h.html#f22e51ade054d5be4b47a3c1c87ef688">F_FENCE</a>)
<a name="l00870"></a>00870   {
<a name="l00871"></a>00871         <span class="comment">//fprintf(stdout,"\n[%lld] Fence Instruction",sim_cycle);</span>
<a name="l00872"></a>00872   }
<a name="l00873"></a>00873   
<a name="l00874"></a>00874 
<a name="l00875"></a>00875   <span class="comment">//set up initial default next PC, THis is removed because now I know the next PC from the QEMU trace</span>
<a name="l00876"></a>00876   <span class="comment">//thread-&gt;regs.regs_NPC = thread-&gt;regs.regs_PC + MD_INST_SIZE(Mop-&gt;fetch.inst);</span>
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   <span class="comment">//if((!Mop-&gt;decode.is_ctrl) || (!Mop-&gt;fetch.inst.rep))</span>
<a name="l00879"></a>00879         <span class="comment">//thread-&gt;regs.regs_NPC = thread-&gt;regs.regs_PC + MD_INST_SIZE(Mop-&gt;fetch.inst);</span>
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <span class="comment">/* grab values for Mop */</span>
<a name="l00883"></a>00883   Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#5645e3dfe55b1b6b2206ffb38379c44d">PC</a> = thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>;
<a name="l00884"></a>00884   Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#2337789f03bfd40d471eafa6e31b4b45">pred_NPC</a> = thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> + <a class="code" href="machine_8h.html#14c2828e3f3d84cfb676273b5dfc5bf8">MD_INST_SIZE</a>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#64bb9f9c135012445c43e8823e98bb3d">is_ctrl</a>)
<a name="l00888"></a>00888   {
<a name="l00889"></a>00889         <span class="keywordflow">if</span>(thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>!= (thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> + <a class="code" href="machine_8h.html#14c2828e3f3d84cfb676273b5dfc5bf8">MD_INST_SIZE</a>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>) ) )
<a name="l00890"></a>00890                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#f820451bdee352d521eb3bf905c3d4e0">targetPC</a>=thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>;
<a name="l00891"></a>00891         <span class="keywordflow">else</span><span class="comment">// TODO Check if this is correct Is just adding the IMM offset enough, In case a branch is not taken QEMU does not tell me what the target is! Thus I need to make an intelligent guess as I dont keep values</span>
<a name="l00892"></a>00892                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#f820451bdee352d521eb3bf905c3d4e0">targetPC</a>=thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> + <a class="code" href="machine_8h.html#14c2828e3f3d84cfb676273b5dfc5bf8">MD_INST_SIZE</a>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>)+ Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#b2f0a90d745653fcc0f7b2764407bb59">imm</a>;
<a name="l00893"></a>00893   }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 
<a name="l00896"></a>00896 
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   <span class="comment">/* set unique id */</span>
<a name="l00899"></a>00899   Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#73a37cb3f710fed5c590d5185dd45531">seq</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#d4bb322114e12a61f9c86ab9e30cb78a">global_seq</a>++;
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <span class="comment">/*********************************************************/</span>
<a name="l00902"></a>00902   <span class="comment">/* REP implementation:</span>
<a name="l00903"></a>00903 <span class="comment">     1. Before any instances of the REP'd instruction, we</span>
<a name="l00904"></a>00904 <span class="comment">        insert a "micro-branch" uop that implements the check</span>
<a name="l00905"></a>00905 <span class="comment">        for whether there are zero iterations.  Note that this</span>
<a name="l00906"></a>00906 <span class="comment">        branch doesn't actually do anything architecturally</span>
<a name="l00907"></a>00907 <span class="comment">        (see notes in machine.def), but it can still be tagged</span>
<a name="l00908"></a>00908 <span class="comment">        as a recover_inst in case of a micro-branch misprediction.</span>
<a name="l00909"></a>00909 <span class="comment">     2. Each REP iteration is manifested in a separate macro-op</span>
<a name="l00910"></a>00910 <span class="comment">        instantiation, but as far as the stats go, it all still</span>
<a name="l00911"></a>00911 <span class="comment">        counts as a single x86 instruction.</span>
<a name="l00912"></a>00912 <span class="comment">     3. At the end of each REP iteration, we append two extra</span>
<a name="l00913"></a>00913 <span class="comment">        uops to implement the REP control flow.  One decrements</span>
<a name="l00914"></a>00914 <span class="comment">        ECX/CX, and the other implements a branch back to the</span>
<a name="l00915"></a>00915 <span class="comment">        same instruction if more REP's are needed.</span>
<a name="l00916"></a>00916 <span class="comment">                                                           */</span>
<a name="l00917"></a>00917   <span class="comment">/*********************************************************/</span>
<a name="l00918"></a>00918 
<a name="l00919"></a>00919   <span class="comment">/* check for insts with repeat count of 0, this can never happen because QEMU sends only executed instructions</span>
<a name="l00920"></a>00920 <span class="comment">     Thus we are ignoring the microops inserted for zero repetition instructions */</span>
<a name="l00921"></a>00921   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a>)
<a name="l00922"></a>00922     Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#4b7707567ffe0d3d712027c190dde6b1">zero_rep</a> = <span class="keyword">false</span>;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="comment">/* For the first in a sequence of REPs (including zero REPs), insert</span>
<a name="l00925"></a>00925 <span class="comment">     a microbranch into the flow-table; uop conversion happens later */</span>
<a name="l00926"></a>00926   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> &amp;&amp; (thread-&gt;<a class="code" href="structthread__t.html#d907b780c1717ccfc70ddc4c6f56d17b">rep_sequence</a> == 0))
<a name="l00927"></a>00927   {
<a name="l00928"></a>00928     Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#63b2a1a4d6f27a1bd3b6c3ca831f16b2">first_rep</a> = <span class="keyword">true</span>;
<a name="l00929"></a>00929 
<a name="l00930"></a>00930     <span class="comment">/* inject an initial micro-branch to test if there are any iterations at all */</span>
<a name="l00931"></a>00931     <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#0b5a8c4597c2e37cf890118bd975f552">mode</a> &amp; <a class="code" href="machine_8h.html#2e33cca3b4e448fea5e41b0f382b3fd2">MODE_ADDR32</a>)
<a name="l00932"></a>00932       flowtab[0] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REPFIRST_MICROBR_D) &lt;&lt; 16);
<a name="l00933"></a>00933     <span class="keywordflow">else</span>
<a name="l00934"></a>00934       flowtab[0] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REPFIRST_MICROBR_W) &lt;&lt; 16);
<a name="l00935"></a>00935 
<a name="l00936"></a>00936     Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a> = 1;
<a name="l00937"></a>00937   }
<a name="l00938"></a>00938   <span class="keywordflow">else</span>
<a name="l00939"></a>00939     Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#63b2a1a4d6f27a1bd3b6c3ca831f16b2">first_rep</a> = <span class="keyword">false</span>;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> &amp;&amp; (Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> &amp; <a class="code" href="machine_8h.html#a6be3e11431119e8d3ab666ab4f5ded7">F_MEM</a>) )
<a name="l00942"></a>00942   {
<a name="l00943"></a>00943         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a> )
<a name="l00944"></a>00944                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#f820451bdee352d521eb3bf905c3d4e0">targetPC</a>= thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> ;
<a name="l00945"></a>00945         <span class="keywordflow">else</span>
<a name="l00946"></a>00946                 Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#f820451bdee352d521eb3bf905c3d4e0">targetPC</a>= thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> + <a class="code" href="machine_8h.html#14c2828e3f3d84cfb676273b5dfc5bf8">MD_INST_SIZE</a>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>);
<a name="l00947"></a>00947   }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949   <span class="comment">/* If there are more than zero instances of the instruction, then fill in the uops */</span>
<a name="l00950"></a>00950   <span class="keywordflow">if</span>(!Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#4b7707567ffe0d3d712027c190dde6b1">zero_rep</a>  ||    (thread-&gt;<a class="code" href="structthread__t.html#d907b780c1717ccfc70ddc4c6f56d17b">rep_sequence</a> != 0)     ) <span class="comment">/* a mispredicted zero rep will have rep_sequence != 0 */</span>
<a name="l00951"></a>00951   {
<a name="l00952"></a>00952     assert(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> &amp; <a class="code" href="machine_8h.html#d1a033a0796fd0c70c7f3198588584bb">F_UCODE</a>); <span class="comment">/* all instructions should have a flow mapping (even for 1-uop codes) */</span>
<a name="l00953"></a>00953 
<a name="l00954"></a>00954     <span class="comment">/* get instruction flow */</span>
<a name="l00955"></a>00955     Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a> += <a class="code" href="machine_8h.html#b3f57fdb0b3410ba51dc0eafadbaeae8">md_get_flow</a>(Mop, flowtab + Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#63b2a1a4d6f27a1bd3b6c3ca831f16b2">first_rep</a>, bogus); <span class="comment">/* have to adjust for the micro-branch we may have already injected */</span>
<a name="l00956"></a>00956 
<a name="l00957"></a>00957     <span class="comment">/* allocate a uop-array of appropriate length */</span>
<a name="l00958"></a>00958     Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#c7fc21b5fb694c21209262c29615fdb7">get_uop_array</a>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a> + (Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a>?2:0));
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> &amp;&amp; (thread-&gt;<a class="code" href="structthread__t.html#d907b780c1717ccfc70ddc4c6f56d17b">rep_sequence</a> == 0)) <span class="comment">/* insert ubranch for 1st iteration of REP */</span>
<a name="l00961"></a>00961     {
<a name="l00962"></a>00962       <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[0];
<a name="l00963"></a>00963       uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a> = flowtab[0];
<a name="l00964"></a>00964       <a class="code" href="machine_8h.html#3e3e4e68ba5623a3a048d9719c57be70">MD_SET_UOPCODE</a>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>,&amp;uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a>);
<a name="l00965"></a>00965       uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> = <a class="code" href="machine_8h.html#9b0f21d8388c386bb4159d06bcf1ed72">MD_OP_FLAGS</a>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>);
<a name="l00966"></a>00966       uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#9ccd1826a44171c8c8a70f4ba0206bc9">is_ctrl</a> = <span class="keyword">true</span>;
<a name="l00967"></a>00967       uop-&gt;<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a> = Mop;
<a name="l00968"></a>00968     }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     <span class="comment">//fprintf(stdout,"\nFlow length %d Bogus %d",Mop-&gt;decode.flow_length, *bogus);</span>
<a name="l00971"></a>00971     <span class="keywordflow">if</span>((!*bogus) &amp;&amp; Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a> &gt; Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#63b2a1a4d6f27a1bd3b6c3ca831f16b2">first_rep</a>) <span class="comment">/* if 1st rep, flow_length already was equal to 1 */</span>
<a name="l00972"></a>00972     {
<a name="l00973"></a>00973       <span class="keywordtype">int</span> imm_uops_left = 0;
<a name="l00974"></a>00974       <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * <a class="code" href="structuop__t.html#430e0f4aeb84fac91fc04ae7d31b5329">fusion_head</a> = NULL; <span class="comment">/* if currently fused, points at head. */</span>
<a name="l00975"></a>00975       <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * prev_uop = NULL;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#63b2a1a4d6f27a1bd3b6c3ca831f16b2">first_rep</a>;i&lt;Mop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.flow_length;i++)
<a name="l00978"></a>00978       {
<a name="l00979"></a>00979         <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[i];
<a name="l00980"></a>00980         uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a> = flowtab[i];
<a name="l00981"></a>00981         <span class="keywordflow">if</span>(!imm_uops_left)
<a name="l00982"></a>00982         {
<a name="l00983"></a>00983           uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#5f5acb91cf98e7630d1fff849c0458be">has_imm</a> = <a class="code" href="machine_8h.html#b1978599c102a26af3174336e11c6ec9">UHASIMM</a>;
<a name="l00984"></a>00984           <a class="code" href="machine_8h.html#3e3e4e68ba5623a3a048d9719c57be70">MD_SET_UOPCODE</a>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>,&amp;uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a>);
<a name="l00985"></a>00985           uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> = <a class="code" href="machine_8h.html#9b0f21d8388c386bb4159d06bcf1ed72">MD_OP_FLAGS</a>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>);
<a name="l00986"></a>00986           uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#fd9cc07575e4452cb5192588691e6814">is_load</a> = !!(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#a696f4e8edb147969a12513f7b195e9a">F_LOAD</a>);
<a name="l00987"></a>00987           <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7301ad4e0c0f5ece738ba62448f7c655">opflags</a> &amp; <a class="code" href="machine_8h.html#88eaa4bf4bc810ef90a437971cd5cf9e">F_STORE</a>)
<a name="l00988"></a>00988           {
<a name="l00989"></a>00989             uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#eec85d8cffdbdff59e335df7cf38174a">is_sta</a> = !!( (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STAD) |
<a name="l00990"></a>00990                                      (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STAW) |
<a name="l00991"></a>00991                                      (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STA_BGENW) |
<a name="l00992"></a>00992                                      (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STA_BGENWI) |
<a name="l00993"></a>00993                                      (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STA_BGEND) |
<a name="l00994"></a>00994                                      (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STA_BGENDI)
<a name="l00995"></a>00995                                    );
<a name="l00996"></a>00996             uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#85d4bc293425ae1bcd322b314414ce1b">is_std</a> = !!(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#88eaa4bf4bc810ef90a437971cd5cf9e">F_STORE</a>);
<a name="l00997"></a>00997           }
<a name="l00998"></a>00998           uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#9ccd1826a44171c8c8a70f4ba0206bc9">is_ctrl</a> = !!(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#366552bee0ef835c75db8fedf12c11f7">F_CTRL</a>);
<a name="l00999"></a>00999           uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#56a6fccbcaa70ed56ccb4fa52fe57cb0">is_nop</a> = uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == NOP;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001           <span class="keywordflow">if</span>(knobs-&gt;<a class="code" href="structcore__knobs__t.html#6dc1fa40282035ef593c34664e66c2a1">decode</a>.<a class="code" href="structcore__knobs__t.html#ccba373a43ac43d703c8ed7e6724acf2">fusion_mode</a> &amp; <a class="code" href="machine_8h.html#3e1758a64e4b5e964fbc8d6642fa7023">FUSION_TYPE</a>(uop))
<a name="l01002"></a>01002           {
<a name="l01003"></a>01003             assert(prev_uop);
<a name="l01004"></a>01004             <span class="keywordflow">if</span>(fusion_head == NULL)
<a name="l01005"></a>01005             {
<a name="l01006"></a>01006               assert(!prev_uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#831dde25d8ef14de7a0c73bc3a5fa3c9">in_fusion</a>);
<a name="l01007"></a>01007               fusion_head = prev_uop;
<a name="l01008"></a>01008               fusion_head-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#831dde25d8ef14de7a0c73bc3a5fa3c9">in_fusion</a> = <span class="keyword">true</span>;
<a name="l01009"></a>01009               fusion_head-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#e915e589eff078d3f108ff4d45ed216c">is_fusion_head</a> = <span class="keyword">true</span>;
<a name="l01010"></a>01010               fusion_head-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#0691349116e499d26a2131a145fe8489">fusion_size</a> = 1;
<a name="l01011"></a>01011               fusion_head-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#430e0f4aeb84fac91fc04ae7d31b5329">fusion_head</a> = fusion_head; <span class="comment">/* point at yourself as well */</span>
<a name="l01012"></a>01012             }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014             uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#831dde25d8ef14de7a0c73bc3a5fa3c9">in_fusion</a> = <span class="keyword">true</span>;
<a name="l01015"></a>01015             uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#430e0f4aeb84fac91fc04ae7d31b5329">fusion_head</a> = fusion_head;
<a name="l01016"></a>01016             fusion_head-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#0691349116e499d26a2131a145fe8489">fusion_size</a>++;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018             prev_uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#17e765e3d22399396fbe31aab97cdf06">fusion_next</a> = uop;
<a name="l01019"></a>01019           }
<a name="l01020"></a>01020           <span class="keywordflow">else</span>
<a name="l01021"></a>01021             fusion_head = NULL;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023           prev_uop = uop;
<a name="l01024"></a>01024         }
<a name="l01025"></a>01025         <span class="keywordflow">else</span>
<a name="l01026"></a>01026         {
<a name="l01027"></a>01027           imm_uops_left--; <span class="comment">/* don't try to decode the immediates! */</span>
<a name="l01028"></a>01028           uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#b1051f89245a2a2d5ea721ab6b4c9870">is_imm</a> = <span class="keyword">true</span>;
<a name="l01029"></a>01029         }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         uop-&gt;<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a> = Mop; <span class="comment">/* back-pointer to parent macro-op */</span>
<a name="l01032"></a>01032         <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#5f5acb91cf98e7630d1fff849c0458be">has_imm</a>)
<a name="l01033"></a>01033           imm_uops_left = 2;
<a name="l01034"></a>01034       }
<a name="l01035"></a>01035     }
<a name="l01036"></a>01036     <span class="keywordflow">else</span>
<a name="l01037"></a>01037     {
<a name="l01038"></a>01038       <span class="comment">/* If at any point we decode something strange, if we're on the wrong path, we'll just</span>
<a name="l01039"></a>01039 <span class="comment">         abort the instruction.  This will basically bring fetch to a halt until the machine</span>
<a name="l01040"></a>01040 <span class="comment">         gets back on the correct control-flow path. */</span>
<a name="l01041"></a>01041       <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01042"></a>01042       {
<a name="l01043"></a>01043         *bogus = <span class="keyword">true</span>;
<a name="l01044"></a>01044         <span class="keywordflow">if</span>(wrote_spec_mem)
<a name="l01045"></a>01045           <a class="code" href="misc_8h.html#f80d19f1297a11626fab61a248959c71">warn</a>(<span class="stringliteral">"(%s:%d) leaking spec mem"</span>,__FILE__,__LINE__);
<a name="l01046"></a>01046         <span class="keywordflow">return</span> NULL;
<a name="l01047"></a>01047       }
<a name="l01048"></a>01048       <span class="keywordflow">else</span>
<a name="l01049"></a>01049         <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"could not locate UCODE flow"</span>);
<a name="l01050"></a>01050     }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052     <span class="comment">/* mark repeat iteration for repeating instructions;</span>
<a name="l01053"></a>01053 <span class="comment">       inject corresponding uops (one ECX update, one micro-branch */</span>
<a name="l01054"></a>01054     <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a>)
<a name="l01055"></a>01055     {
<a name="l01056"></a>01056       <span class="comment">/* ECX/CX update */</span>
<a name="l01057"></a>01057       <span class="keywordtype">int</span> idx = Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a>;
<a name="l01058"></a>01058       <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#0b5a8c4597c2e37cf890118bd975f552">mode</a> &amp; <a class="code" href="machine_8h.html#2e33cca3b4e448fea5e41b0f382b3fd2">MODE_ADDR32</a>)
<a name="l01059"></a>01059       {
<a name="l01060"></a>01060         flowtab[idx] = ((!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(SUBDI) &lt;&lt; 16)
<a name="l01061"></a>01061                                        | (<a class="code" href="machine_8h.html#85959b31a96164d804447c37faa100a5">md_uop_reg</a>(<a class="code" href="machine_8h.html#8f348514238e5cc31e527bb232c04ef84efaba1b420b554577fd0652f2f92e01">XR_ECX</a>, Mop, bogus) &lt;&lt; 12)
<a name="l01062"></a>01062                                        | (<a class="code" href="machine_8h.html#85959b31a96164d804447c37faa100a5">md_uop_reg</a>(<a class="code" href="machine_8h.html#8f348514238e5cc31e527bb232c04ef84efaba1b420b554577fd0652f2f92e01">XR_ECX</a>, Mop, bogus) &lt;&lt; 8)
<a name="l01063"></a>01063                                        | (<a class="code" href="machine_8h.html#e10ffaf1df8ee9dc086b4d3e45051bd0">md_uop_immb</a>(<a class="code" href="machine_8h.html#8f348514238e5cc31e527bb232c04ef85b81af0ff0be9fd0e627bb777c58d5af">XE_ONE</a>, Mop, bogus)));
<a name="l01064"></a>01064         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a> = flowtab[idx];
<a name="l01065"></a>01065         <a class="code" href="machine_8h.html#3e3e4e68ba5623a3a048d9719c57be70">MD_SET_UOPCODE</a>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>,&amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a>);
<a name="l01066"></a>01066         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> = <a class="code" href="machine_8h.html#9b0f21d8388c386bb4159d06bcf1ed72">MD_OP_FLAGS</a>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>);
<a name="l01067"></a>01067         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a> = Mop;
<a name="l01068"></a>01068       }
<a name="l01069"></a>01069       <span class="keywordflow">else</span>
<a name="l01070"></a>01070       {
<a name="l01071"></a>01071         flowtab[idx] = ((!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(SUBWI) &lt;&lt; 16)
<a name="l01072"></a>01072                                        | (<a class="code" href="machine_8h.html#85959b31a96164d804447c37faa100a5">md_uop_reg</a>(<a class="code" href="machine_8h.html#8f348514238e5cc31e527bb232c04ef880fd537a7b477fbeb6f02fc34a186941">XR_CX</a>, Mop, bogus) &lt;&lt; 12)
<a name="l01073"></a>01073                                        | (<a class="code" href="machine_8h.html#85959b31a96164d804447c37faa100a5">md_uop_reg</a>(<a class="code" href="machine_8h.html#8f348514238e5cc31e527bb232c04ef880fd537a7b477fbeb6f02fc34a186941">XR_CX</a>, Mop, bogus) &lt;&lt; 8)
<a name="l01074"></a>01074                                        | (<a class="code" href="machine_8h.html#e10ffaf1df8ee9dc086b4d3e45051bd0">md_uop_immb</a>(<a class="code" href="machine_8h.html#8f348514238e5cc31e527bb232c04ef85b81af0ff0be9fd0e627bb777c58d5af">XE_ONE</a>, Mop, bogus)));
<a name="l01075"></a>01075         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a> = flowtab[idx];
<a name="l01076"></a>01076         <a class="code" href="machine_8h.html#3e3e4e68ba5623a3a048d9719c57be70">MD_SET_UOPCODE</a>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>,&amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a>);
<a name="l01077"></a>01077         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> = <a class="code" href="machine_8h.html#9b0f21d8388c386bb4159d06bcf1ed72">MD_OP_FLAGS</a>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>);
<a name="l01078"></a>01078         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a> = Mop;
<a name="l01079"></a>01079       }
<a name="l01080"></a>01080 
<a name="l01081"></a>01081       idx++;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083 
<a name="l01084"></a>01084       <span class="comment">/* micro-jump to test for end of REP */</span>
<a name="l01085"></a>01085       <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#0b5a8c4597c2e37cf890118bd975f552">mode</a> &amp; <a class="code" href="machine_8h.html#2e33cca3b4e448fea5e41b0f382b3fd2">MODE_ADDR32</a>)
<a name="l01086"></a>01086       {
<a name="l01087"></a>01087         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> == <a class="code" href="machine_8h.html#1fd5635eb03573f5a1618af1152d1fda">REP_REPNZ</a>)
<a name="l01088"></a>01088           flowtab[idx] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REPNZ_MICROBR_D) &lt;&lt; 16);
<a name="l01089"></a>01089         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> == <a class="code" href="machine_8h.html#1b0eb3c76214aef658830a2c081bbf90">REP_REPZ</a>)
<a name="l01090"></a>01090           flowtab[idx] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REPZ_MICROBR_D) &lt;&lt; 16);
<a name="l01091"></a>01091         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> == <a class="code" href="machine_8h.html#2da96452a4c6418f9b9bbc1227e49f00">REP_REP</a>)
<a name="l01092"></a>01092           flowtab[idx] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REP_MICROBR_D) &lt;&lt; 16);
<a name="l01093"></a>01093         <span class="keywordflow">else</span>
<a name="l01094"></a>01094         {
<a name="l01095"></a>01095           <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01096"></a>01096           {
<a name="l01097"></a>01097             *bogus = <span class="keyword">true</span>;
<a name="l01098"></a>01098             <span class="comment">//if(wrote_spec_mem)</span>
<a name="l01099"></a>01099             <span class="comment">//  warn("(%s:%d) leaking spec mem",__FILE__,__LINE__);</span>
<a name="l01100"></a>01100             <span class="keywordflow">return</span> NULL;
<a name="l01101"></a>01101           }
<a name="l01102"></a>01102           <span class="keywordflow">else</span>
<a name="l01103"></a>01103             <a class="code" href="misc_8h.html#d1f1a1dc0581a11b597453f148106393">panic</a>(<span class="stringliteral">"bogus repeat code"</span>);
<a name="l01104"></a>01104         }
<a name="l01105"></a>01105       }
<a name="l01106"></a>01106       <span class="keywordflow">else</span><span class="comment">/*16 bit address mode*/</span>
<a name="l01107"></a>01107       {
<a name="l01108"></a>01108         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> == <a class="code" href="machine_8h.html#1fd5635eb03573f5a1618af1152d1fda">REP_REPNZ</a>)
<a name="l01109"></a>01109           flowtab[idx] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REPNZ_MICROBR_W) &lt;&lt; 16);
<a name="l01110"></a>01110         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> == <a class="code" href="machine_8h.html#1b0eb3c76214aef658830a2c081bbf90">REP_REPZ</a>)
<a name="l01111"></a>01111           flowtab[idx] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REPZ_MICROBR_W) &lt;&lt; 16);
<a name="l01112"></a>01112         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> == <a class="code" href="machine_8h.html#2da96452a4c6418f9b9bbc1227e49f00">REP_REP</a>)
<a name="l01113"></a>01113           flowtab[idx] = (!!(<a class="code" href="machine_8h.html#1965eaca47dbf3f87acdafc2208f04eb">UP</a>) &lt;&lt; 30) | (<a class="code" href="machine_8h.html#9682311d5eea29d63f16e67e41be6053">md_uop_opc</a>(REP_MICROBR_W) &lt;&lt; 16);
<a name="l01114"></a>01114         <span class="keywordflow">else</span>
<a name="l01115"></a>01115         {
<a name="l01116"></a>01116           <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01117"></a>01117           {
<a name="l01118"></a>01118             *bogus = <span class="keyword">true</span>;
<a name="l01119"></a>01119             <span class="keywordflow">return</span> NULL;
<a name="l01120"></a>01120           }
<a name="l01121"></a>01121           <span class="keywordflow">else</span>
<a name="l01122"></a>01122             <a class="code" href="misc_8h.html#d1f1a1dc0581a11b597453f148106393">panic</a>(<span class="stringliteral">"bogus repeat code"</span>);
<a name="l01123"></a>01123         }
<a name="l01124"></a>01124       }
<a name="l01125"></a>01125       Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a> = flowtab[idx];
<a name="l01126"></a>01126       Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#9ccd1826a44171c8c8a70f4ba0206bc9">is_ctrl</a> = <span class="keyword">true</span>;
<a name="l01127"></a>01127       <a class="code" href="machine_8h.html#3e3e4e68ba5623a3a048d9719c57be70">MD_SET_UOPCODE</a>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>,&amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a>);
<a name="l01128"></a>01128       Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[idx].<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a> = Mop;
<a name="l01129"></a>01129 
<a name="l01130"></a>01130       Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a> += 2;
<a name="l01131"></a>01131     }
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a>;i++)
<a name="l01134"></a>01134     {
<a name="l01135"></a>01135       Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[i].<a class="code" href="structuop__t.html#1606190a5e56586a16065646985b02e9">flow_index</a> = i;
<a name="l01136"></a>01136       Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[i].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#46ca09f2272d8c3dd6b6b14d5e722185">Mop_seq</a> = Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#73a37cb3f710fed5c590d5185dd45531">seq</a>;
<a name="l01137"></a>01137       Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[i].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#a7b9e443607a13d90b1b51db2a921257">uop_seq</a> = (Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#73a37cb3f710fed5c590d5185dd45531">seq</a> &lt;&lt; <a class="code" href="machine_8h.html#a815a6d01e28ecb0f60fcde13fc11e4a">UOP_SEQ_SHIFT</a>) + i;
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   }
<a name="l01141"></a>01141   <span class="keywordflow">else</span> <span class="comment">/* zero-rep inst This branch will never be taken with QEMU */</span>
<a name="l01142"></a>01142   {
<a name="l01143"></a>01143     Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#c7fc21b5fb694c21209262c29615fdb7">get_uop_array</a>(1);
<a name="l01144"></a>01144     <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[0];
<a name="l01145"></a>01145     uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a> = flowtab[0];
<a name="l01146"></a>01146     <a class="code" href="machine_8h.html#3e3e4e68ba5623a3a048d9719c57be70">MD_SET_UOPCODE</a>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>,&amp;uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#16ed66cfd17998b95d7dc19e42336a55">raw_op</a>);
<a name="l01147"></a>01147     uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> = <a class="code" href="machine_8h.html#9b0f21d8388c386bb4159d06bcf1ed72">MD_OP_FLAGS</a>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>);
<a name="l01148"></a>01148     uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#9ccd1826a44171c8c8a70f4ba0206bc9">is_ctrl</a> = <span class="keyword">true</span>;
<a name="l01149"></a>01149     uop-&gt;<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a> = Mop;
<a name="l01150"></a>01150   }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   <span class="keywordflow">if</span>(!Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a> || Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#63b2a1a4d6f27a1bd3b6c3ca831f16b2">first_rep</a>)
<a name="l01153"></a>01153     Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[0].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#075d4a905368cc1eeb377d2a41bd9c20">BOM</a> = <span class="keyword">true</span>;
<a name="l01154"></a>01154 
<a name="l01155"></a>01155   <span class="keywordflow">while</span>(flow_index &lt; Mop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.flow_length)
<a name="l01156"></a>01156   {
<a name="l01157"></a>01157     <span class="comment">/* If we have a microcode op, get the op and inst, this</span>
<a name="l01158"></a>01158 <span class="comment">     * has already been done for non-microcode instructions */</span>
<a name="l01159"></a>01159     <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[flow_index];
<a name="l01160"></a>01160     uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#156195a0d0889db67681f0900c044423">FU_class</a> = <a class="code" href="machine_8h.html#7f2662286e75066073d89e5490dcfea6">MD_OP_FUCLASS</a>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>);
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="comment">/* get dependency names */</span>
<a name="l01163"></a>01163     <span class="keywordflow">switch</span> (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a>)
<a name="l01164"></a>01164     {
<a name="l01165"></a>01165 <span class="preprocessor">#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,I1,I2,I3,OFLAGS,IFLAGS)\</span>
<a name="l01166"></a>01166 <span class="preprocessor">      case OP: uop-&gt;decode.idep_name[0] = I1; uop-&gt;decode.odep_name = O1;  \</span>
<a name="l01167"></a>01167 <span class="preprocessor">               uop-&gt;decode.idep_name[1] = I2;  \</span>
<a name="l01168"></a>01168 <span class="preprocessor">               uop-&gt;decode.idep_name[2] = I3;  \</span>
<a name="l01169"></a>01169 <span class="preprocessor">               uop-&gt;decode.iflags = (IFLAGS!=DNA)?IFLAGS:0; \</span>
<a name="l01170"></a>01170 <span class="preprocessor">               uop-&gt;decode.oflags = (OFLAGS!=DNA)?OFLAGS:0; \</span>
<a name="l01171"></a>01171 <span class="preprocessor">      break;</span>
<a name="l01172"></a>01172 <span class="preprocessor"></span><span class="preprocessor">#define DEFUOP(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,I1,I2,I3,OFLAGS,IFLAGS)\</span>
<a name="l01173"></a>01173 <span class="preprocessor">      case OP: uop-&gt;decode.idep_name[0] = I1; uop-&gt;decode.odep_name = O1;  \</span>
<a name="l01174"></a>01174 <span class="preprocessor">               uop-&gt;decode.idep_name[1] = I2;  \</span>
<a name="l01175"></a>01175 <span class="preprocessor">               uop-&gt;decode.idep_name[2] = I3;  \</span>
<a name="l01176"></a>01176 <span class="preprocessor">               uop-&gt;decode.iflags = (IFLAGS!=DNA)?IFLAGS:0; \</span>
<a name="l01177"></a>01177 <span class="preprocessor">               uop-&gt;decode.oflags = (OFLAGS!=DNA)?OFLAGS:0; \</span>
<a name="l01178"></a>01178 <span class="preprocessor">      break;</span>
<a name="l01179"></a>01179 <span class="preprocessor"></span><span class="preprocessor">#define DEFLINK(OP,MSK,NAME,MASK,SHIFT)          \</span>
<a name="l01180"></a>01180 <span class="preprocessor">      case OP:                            \</span>
<a name="l01181"></a>01181 <span class="preprocessor">                            panic("attempted to execute a linking opcode");</span>
<a name="l01182"></a>01182 <span class="preprocessor"></span><span class="preprocessor">#define CONNECT(OP)</span>
<a name="l01183"></a>01183 <span class="preprocessor"></span><span class="preprocessor">#include "machine.def"</span>
<a name="l01184"></a>01184       <span class="keywordflow">default</span>:
<a name="l01185"></a>01185         <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01186"></a>01186         {
<a name="l01187"></a>01187           *bogus = <span class="keyword">true</span>;
<a name="l01188"></a>01188           <span class="comment">//if(wrote_spec_mem)</span>
<a name="l01189"></a>01189           <span class="comment">//  cleanup_aborted_mop(Mop);</span>
<a name="l01190"></a>01190           <span class="keywordflow">return</span> NULL;
<a name="l01191"></a>01191         }
<a name="l01192"></a>01192         <span class="keywordflow">else</span>
<a name="l01193"></a>01193           <a class="code" href="misc_8h.html#d1f1a1dc0581a11b597453f148106393">panic</a>(<span class="stringliteral">"attempted to execute a bogus opcode"</span>);
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196     <span class="comment">/* check for completed flow at top of loop */</span>
<a name="l01197"></a>01197     <span class="keywordtype">int</span> offset = <a class="code" href="machine_8h.html#c2cab6744a434647b35f28d966f98d73">MD_INC_FLOW</a>;
<a name="l01198"></a>01198     Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#82638df3748d18d1c8c2e3d58d077a49">last_uop_index</a> = flow_index;
<a name="l01199"></a>01199     flow_index += offset;
<a name="l01200"></a>01200   }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202   flow_index = 0;
<a name="l01203"></a>01203   <span class="keywordflow">while</span>(flow_index &lt; Mop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.flow_length)
<a name="l01204"></a>01204   {
<a name="l01205"></a>01205     <span class="comment">/* If we have a microcode op, get the op and inst, this</span>
<a name="l01206"></a>01206 <span class="comment">     * has already been done for non-microcode instructions */</span>
<a name="l01207"></a>01207     <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[flow_index];
<a name="l01208"></a>01208 
<a name="l01209"></a>01209     assert((!(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#88eaa4bf4bc810ef90a437971cd5cf9e">F_STORE</a>)) || uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#85d4bc293425ae1bcd322b314414ce1b">is_std</a>);
<a name="l01210"></a>01210     assert((!(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#a696f4e8edb147969a12513f7b195e9a">F_LOAD</a>)) || uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#fd9cc07575e4452cb5192588691e6814">is_load</a>);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212     <span class="comment">/* are all operands valid? */</span>
<a name="l01213"></a>01213     <span class="keywordflow">if</span>( (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[0] &gt;= <a class="code" href="machine_8h.html#fe3f361f13b4d59d0f770023d0e26e29">MD_TOTAL_REGS</a>) ||
<a name="l01214"></a>01214         (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[1] &gt;= <a class="code" href="machine_8h.html#fe3f361f13b4d59d0f770023d0e26e29">MD_TOTAL_REGS</a>) ||
<a name="l01215"></a>01215         (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[2] &gt;= <a class="code" href="machine_8h.html#fe3f361f13b4d59d0f770023d0e26e29">MD_TOTAL_REGS</a>) ||
<a name="l01216"></a>01216         (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a> &gt;= <a class="code" href="machine_8h.html#fe3f361f13b4d59d0f770023d0e26e29">MD_TOTAL_REGS</a>) )
<a name="l01217"></a>01217     {
<a name="l01218"></a>01218       <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01219"></a>01219       {
<a name="l01220"></a>01220         *bogus = <span class="keyword">true</span>;
<a name="l01221"></a>01221         <span class="comment">//if(wrote_spec_mem)</span>
<a name="l01222"></a>01222         <span class="comment">//  cleanup_aborted_mop(Mop);</span>
<a name="l01223"></a>01223         <span class="keywordflow">return</span> NULL;
<a name="l01224"></a>01224       }
<a name="l01225"></a>01225       <span class="keywordflow">else</span>
<a name="l01226"></a>01226         <a class="code" href="misc_8h.html#d1f1a1dc0581a11b597453f148106393">panic</a>(<span class="stringliteral">"decoded an instruction with an invalid register specifier (%d=%d,%d,%d max should be %d)"</span>,uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>, uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[0], uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[1], uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[2],<a class="code" href="machine_8h.html#fe3f361f13b4d59d0f770023d0e26e29">MD_TOTAL_REGS</a>);
<a name="l01227"></a>01227     }
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="comment">/* break addr dependency to allow STA/STD to execute independently */</span>
<a name="l01230"></a>01230     <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#85d4bc293425ae1bcd322b314414ce1b">is_std</a>)
<a name="l01231"></a>01231       uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[<a class="code" href="zesto-structs_8h.html#a3f75da7162ca55aee3b048479f44204">MD_STA_OP_INDEX</a>] = <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="comment">//    /* read input dep values WE CANNOT READ THESE VALUES BECAUSE ZESTO DOES NOT KEEP ANY STATE ANYMORE */</span>
<a name="l01236"></a>01236 <span class="comment">//    for(int i=0;i&lt;MAX_IDEPS;i++)</span>
<a name="l01237"></a>01237 <span class="comment">//    {</span>
<a name="l01238"></a>01238 <span class="comment">//      if((uop-&gt;decode.idep_name[i] != DNA) &amp;&amp; (uop-&gt;decode.idep_name[i] != MD_REG_ZERO))</span>
<a name="l01239"></a>01239 <span class="comment">//      {</span>
<a name="l01240"></a>01240 <span class="comment">//        if(REG_IS_GPR(uop-&gt;decode.idep_name[i]))</span>
<a name="l01241"></a>01241 <span class="comment">//          uop-&gt;oracle.ivalue[i].dw = thread-&gt;regs.regs_R.dw[_DGPR(uop-&gt;decode.idep_name[i])];</span>
<a name="l01242"></a>01242 <span class="comment">//        else if(REG_IS_FPR(uop-&gt;decode.idep_name[i]))</span>
<a name="l01243"></a>01243 <span class="comment">//          uop-&gt;oracle.ivalue[i].e = thread-&gt;regs.regs_F.e[_DFPR(uop-&gt;decode.idep_name[i])];</span>
<a name="l01244"></a>01244 <span class="comment">//        else if(REG_IS_SEG(uop-&gt;decode.idep_name[i]))</span>
<a name="l01245"></a>01245 <span class="comment">//          uop-&gt;oracle.ivalue[i].w = thread-&gt;regs.regs_S.w[_DSEG(uop-&gt;decode.idep_name[i])];</span>
<a name="l01246"></a>01246 <span class="comment">//      }</span>
<a name="l01247"></a>01247 <span class="comment">//    }</span>
<a name="l01248"></a>01248 <span class="comment">//    /* copy previous values of odep for possible recovery */</span>
<a name="l01249"></a>01249 <span class="comment">//    if((uop-&gt;decode.odep_name != DNA) &amp;&amp; (uop-&gt;decode.odep_name != MD_REG_ZERO))</span>
<a name="l01250"></a>01250 <span class="comment">//    {</span>
<a name="l01251"></a>01251 <span class="comment">//      if(REG_IS_GPR(uop-&gt;decode.odep_name))</span>
<a name="l01252"></a>01252 <span class="comment">//        uop-&gt;oracle.prev_ovalue.dw = thread-&gt;regs.regs_R.dw[_DGPR(uop-&gt;decode.odep_name)];</span>
<a name="l01253"></a>01253 <span class="comment">//      else if(REG_IS_FPR(uop-&gt;decode.odep_name))</span>
<a name="l01254"></a>01254 <span class="comment">//        uop-&gt;oracle.prev_ovalue.e = thread-&gt;regs.regs_F.e[_DFPR(uop-&gt;decode.odep_name)];</span>
<a name="l01255"></a>01255 <span class="comment">//      else if(REG_IS_SEG(uop-&gt;decode.odep_name))</span>
<a name="l01256"></a>01256 <span class="comment">//        uop-&gt;oracle.prev_ovalue.w = thread-&gt;regs.regs_S.w[_DSEG(uop-&gt;decode.odep_name)];</span>
<a name="l01257"></a>01257 <span class="comment">//    }</span>
<a name="l01258"></a>01258 <span class="comment">//    uop-&gt;oracle.ictrl = thread-&gt;regs.regs_C;</span>
<a name="l01259"></a>01259 
<a name="l01260"></a>01260     <span class="comment">/* execute the instruction This is not needed anymore beacuse QEMU is executing the instructions </span>
<a name="l01261"></a>01261 <span class="comment">       Code here is also responsible for writing the PC and NPC values as well as the virtual addresses of memory ops</span>
<a name="l01262"></a>01262 <span class="comment">       So we need to add functionality to insert these values</span>
<a name="l01263"></a>01263 <span class="comment">       NPC values get written in the beginning with the MD_FETCH_NEXT_PC() call</span>
<a name="l01264"></a>01264 <span class="comment">       We need to write the values of addresses for memory ops</span>
<a name="l01265"></a>01265 <span class="comment"></span>
<a name="l01266"></a>01266 <span class="comment">    switch (uop-&gt;decode.op)</span>
<a name="l01267"></a>01267 <span class="comment">    {</span>
<a name="l01268"></a>01268 <span class="comment">#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,I1,I2,I3,OFLAGS,IFLAGS)\</span>
<a name="l01269"></a>01269 <span class="comment">      case OP: SYMCAT(OP,_IMPL_FUNC)(thread,core,Mop,uop,bogus);               \</span>
<a name="l01270"></a>01270 <span class="comment">      break;</span>
<a name="l01271"></a>01271 <span class="comment">#define DEFUOP(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,I1,I2,I3,OFLAGS,IFLAGS)\</span>
<a name="l01272"></a>01272 <span class="comment">      case OP: SYMCAT(OP,_IMPL_FUNC)(thread,core,Mop,uop,bogus);               \</span>
<a name="l01273"></a>01273 <span class="comment">      break;</span>
<a name="l01274"></a>01274 <span class="comment">#define DEFLINK(OP,MSK,NAME,MASK,SHIFT)          \</span>
<a name="l01275"></a>01275 <span class="comment">      case OP:                            \</span>
<a name="l01276"></a>01276 <span class="comment">                            panic("attempted to execute a linking opcode");</span>
<a name="l01277"></a>01277 <span class="comment">#define CONNECT(OP)</span>
<a name="l01278"></a>01278 <span class="comment">#include "machine.def"</span>
<a name="l01279"></a>01279 <span class="comment">#undef DEFINST</span>
<a name="l01280"></a>01280 <span class="comment">#undef DEFUOP</span>
<a name="l01281"></a>01281 <span class="comment">#undef CONNECT</span>
<a name="l01282"></a>01282 <span class="comment">      default:</span>
<a name="l01283"></a>01283 <span class="comment">        panic("attempted to execute a bogus opcode");</span>
<a name="l01284"></a>01284 <span class="comment">    }*/</span>
<a name="l01285"></a>01285 
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 
<a name="l01288"></a>01288 <span class="comment">//    if(uop-&gt;oracle.spec_mem[0])</span>
<a name="l01289"></a>01289 <span class="comment">//      wrote_spec_mem = true;</span>
<a name="l01290"></a>01290 <span class="comment">//</span>
<a name="l01291"></a>01291 <span class="comment">//    /* maintain $r0 semantics */</span>
<a name="l01292"></a>01292 <span class="comment">//    thread-&gt;regs.regs_R.dw[MD_REG_ZERO] = 0;</span>
<a name="l01293"></a>01293 <span class="comment">//</span>
<a name="l01294"></a>01294 <span class="comment">//    /* copy output value */</span>
<a name="l01295"></a>01295 <span class="comment">//    if((uop-&gt;decode.odep_name != DNA) &amp;&amp; (uop-&gt;decode.odep_name != MD_REG_ZERO))</span>
<a name="l01296"></a>01296 <span class="comment">//    {</span>
<a name="l01297"></a>01297 <span class="comment">//      if(REG_IS_GPR(uop-&gt;decode.odep_name))</span>
<a name="l01298"></a>01298 <span class="comment">//        uop-&gt;oracle.ovalue.dw = thread-&gt;regs.regs_R.dw[_DGPR(uop-&gt;decode.odep_name)];</span>
<a name="l01299"></a>01299 <span class="comment">//      else if(REG_IS_FPR(uop-&gt;decode.odep_name))</span>
<a name="l01300"></a>01300 <span class="comment">//        uop-&gt;oracle.ovalue.e = thread-&gt;regs.regs_F.e[_DFPR(uop-&gt;decode.odep_name)];</span>
<a name="l01301"></a>01301 <span class="comment">//      else if(REG_IS_SEG(uop-&gt;decode.odep_name))</span>
<a name="l01302"></a>01302 <span class="comment">//        uop-&gt;oracle.ovalue.w = thread-&gt;regs.regs_S.w[_DSEG(uop-&gt;decode.odep_name)];</span>
<a name="l01303"></a>01303 <span class="comment">//    }</span>
<a name="l01304"></a>01304 <span class="comment">//    uop-&gt;oracle.octrl = thread-&gt;regs.regs_C;</span>
<a name="l01305"></a>01305 
<a name="l01306"></a>01306 
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 
<a name="l01309"></a>01309     <span class="comment">/*Updating the address of the load micro-op with the one given by QEMU*/</span>
<a name="l01310"></a>01310     <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#fd9cc07575e4452cb5192588691e6814">is_load</a>)
<a name="l01311"></a>01311     {
<a name="l01312"></a>01312         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4e0149c5502186cc978fc5412d60b087">ld_dequeued</a>[0]==<span class="keyword">false</span>)       <span class="comment">//if this is the firts load mem-op of an instruction</span>
<a name="l01313"></a>01313         {
<a name="l01314"></a>01314                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#ebe595b6542eff03da2b3f92bb966c07">mem_paddr_ld</a>[0];
<a name="l01315"></a>01315                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0];
<a name="l01316"></a>01316                 uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>=Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#aa559aaa21d731cda775b553c08c9a2f">ld_size</a>[0];
<a name="l01317"></a>01317                 Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4e0149c5502186cc978fc5412d60b087">ld_dequeued</a>[0]=<span class="keyword">true</span>;
<a name="l01318"></a>01318         }<span class="keywordflow">else</span>   <span class="comment">//if an instruction has two load micro-ops</span>
<a name="l01319"></a>01319         {
<a name="l01320"></a>01320                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#ebe595b6542eff03da2b3f92bb966c07">mem_paddr_ld</a>[1];
<a name="l01321"></a>01321                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[1];
<a name="l01322"></a>01322                 uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>=Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#aa559aaa21d731cda775b553c08c9a2f">ld_size</a>[1];
<a name="l01323"></a>01323                 Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4e0149c5502186cc978fc5412d60b087">ld_dequeued</a>[1]=<span class="keyword">true</span>;
<a name="l01324"></a>01324         }
<a name="l01325"></a>01325         <span class="keywordflow">if</span>( (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == LDPCWW) || (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == LDPCDW) || (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == LDPCWD) || (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == LDPCDD) )
<a name="l01326"></a>01326         {
<a name="l01328"></a>01328                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>=thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>;
<a name="l01329"></a>01329                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>=thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>;
<a name="l01330"></a>01330                 uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>=4;
<a name="l01331"></a>01331         }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 
<a name="l01334"></a>01334         <span class="comment">//if(Mop-&gt;fetch.inst.rep &amp;&amp; (!(uop-&gt;oracle.virt_addr)) )        //Case where the iteration is not executed so QEMU gives you the instruction but not the memory op</span>
<a name="l01335"></a>01335         <span class="keywordflow">if</span>((!(uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>)) ) <span class="comment">//Case where the iteration is not executed so QEMU gives you the instruction but not the memory op</span>
<a name="l01336"></a>01336         {
<a name="l01337"></a>01337                         uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>= 0xfffffff0;
<a name="l01338"></a>01338                         uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>= 0xfffffff0;
<a name="l01339"></a>01339                         uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>= 4;
<a name="l01340"></a>01340         }       
<a name="l01341"></a>01341         assert(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>!=0);
<a name="l01342"></a>01342     }
<a name="l01343"></a>01343     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#85d4bc293425ae1bcd322b314414ce1b">is_std</a>)
<a name="l01344"></a>01344     {
<a name="l01345"></a>01345         <span class="keywordtype">int</span> prev_uop_index = flow_index-1;
<a name="l01346"></a>01346         <span class="comment">/* virt_addr and mem_size set by execution of STD uop, copy back to STA */</span>
<a name="l01347"></a>01347         assert(prev_uop_index &gt;= 0);
<a name="l01348"></a>01348         <span class="keywordflow">while</span>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[prev_uop_index].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#b1051f89245a2a2d5ea721ab6b4c9870">is_imm</a>)
<a name="l01349"></a>01349         {
<a name="l01350"></a>01350                 prev_uop_index --;
<a name="l01351"></a>01351                 assert(prev_uop_index &gt;= 0);
<a name="l01352"></a>01352         }
<a name="l01353"></a>01353         assert(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[prev_uop_index].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#eec85d8cffdbdff59e335df7cf38174a">is_sta</a>);
<a name="l01354"></a>01354 
<a name="l01355"></a>01355         <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4158b3e42772696b3f6569c7fc2b1401">str_dequeued</a>[0]==<span class="keyword">false</span>)      <span class="comment">//if this is the firts load mem-op of an instruction</span>
<a name="l01356"></a>01356         {
<a name="l01357"></a>01357                 <span class="comment">//fprintf(stdout,"\n[%lld]Oracle This is the first store sent by QEMu ", sim_cycle);</span>
<a name="l01358"></a>01358                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#84f77c012a6cdd392f645db63dd3b9cb">mem_paddr_str</a>[0];
<a name="l01359"></a>01359                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0];
<a name="l01360"></a>01360                 uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>=Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#66a55324ea75d2ce5951a6dbfe43b665">str_size</a>[0];
<a name="l01361"></a>01361                 Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4158b3e42772696b3f6569c7fc2b1401">str_dequeued</a>[0]=<span class="keyword">true</span>;
<a name="l01362"></a>01362         }<span class="keywordflow">else</span>   <span class="comment">//if an instruction has two store micro-ops</span>
<a name="l01363"></a>01363         {
<a name="l01364"></a>01364                 <span class="comment">//fprintf(stdout,"\n[%lld]Oracle This is the second store sent by QEMu ", sim_cycle);</span>
<a name="l01365"></a>01365                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#84f77c012a6cdd392f645db63dd3b9cb">mem_paddr_str</a>[1];
<a name="l01366"></a>01366                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>= Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[1];
<a name="l01367"></a>01367                 uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>=Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#66a55324ea75d2ce5951a6dbfe43b665">str_size</a>[1];
<a name="l01368"></a>01368                 Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4158b3e42772696b3f6569c7fc2b1401">str_dequeued</a>[1]=<span class="keyword">true</span>;
<a name="l01369"></a>01369         }
<a name="l01370"></a>01370         
<a name="l01371"></a>01371         <span class="comment">//if(Mop-&gt;fetch.inst.rep &amp;&amp; (!(uop-&gt;oracle.virt_addr)) )        //Case where the iteration is not executed so QEMU gives you the instruction but not the memory op</span>
<a name="l01372"></a>01372         <span class="keywordflow">if</span>((!(uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>)) ) <span class="comment">//Case where the iteration is not executed so QEMU gives you the instruction but not the memory op</span>
<a name="l01373"></a>01373         {       
<a name="l01374"></a>01374                         uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>= 0xbeffeffe;
<a name="l01375"></a>01375                         uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>= 0xbeffeffe;
<a name="l01376"></a>01376                         uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>= 4;
<a name="l01377"></a>01377         }       
<a name="l01378"></a>01378 
<a name="l01379"></a>01379         <span class="keywordflow">if</span>( (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STPCD) || (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#c1fb2c48a0b03eafe8596e3b134042f4">op</a> == STPCW) )
<a name="l01380"></a>01380         {
<a name="l01381"></a>01381                 <span class="comment">//fprintf(stdout,"Detected a store PC instruction");    //I need the address of the stack segment</span>
<a name="l01382"></a>01382                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>=Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#e05730869a364bf93b640941f78113ab">paddr</a>;
<a name="l01383"></a>01383                 uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>=Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#95beb627225d1c1eb84837df86c53e28">vaddr</a>;
<a name="l01384"></a>01384                 uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>=4;
<a name="l01385"></a>01385         }
<a name="l01386"></a>01386         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[prev_uop_index].<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a> = uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a>;
<a name="l01387"></a>01387         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[prev_uop_index].<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a> = uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#fdd71edb53caa0d97b0947644ebfcfc1">phys_addr</a>;
<a name="l01388"></a>01388         Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[prev_uop_index].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a> = uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>;
<a name="l01389"></a>01389         <span class="keywordflow">if</span>(!<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01390"></a>01390         {
<a name="l01391"></a>01391                 assert(uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#d7e89a7b0583599bf140c251ce1731f5">virt_addr</a> &amp;&amp; uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#58a7c8e6a49a879b290148211ac08e5a">mem_size</a>);
<a name="l01394"></a>01394         }
<a name="l01395"></a>01395     }
<a name="l01396"></a>01396 
<a name="l01397"></a>01397     <span class="keywordflow">if</span> (uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#3c07aa650f5f60bee4eb64e9f8230bf0">fault</a> != <a class="code" href="machine_8h.html#a85392bc9273ef092efe1e9f7422b32119b8f8ccd7cf501d68fbe167f0244bbc">md_fault_none</a>)
<a name="l01398"></a>01398     {
<a name="l01399"></a>01399       <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01400"></a>01400       {
<a name="l01401"></a>01401         *bogus = <span class="keyword">true</span>;
<a name="l01402"></a>01402         <span class="comment">//if(wrote_spec_mem)</span>
<a name="l01403"></a>01403         <span class="comment">//  cleanup_aborted_mop(Mop);</span>
<a name="l01404"></a>01404         <span class="keywordflow">return</span> NULL;
<a name="l01405"></a>01405       }
<a name="l01406"></a>01406       <span class="keywordflow">else</span>
<a name="l01407"></a>01407         <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"fault (%d) detected @ 0x%08p"</span>, uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#3c07aa650f5f60bee4eb64e9f8230bf0">fault</a>, thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>);
<a name="l01408"></a>01408     }
<a name="l01409"></a>01409 
<a name="l01410"></a>01410     <span class="comment">/* Update stats */</span>
<a name="l01411"></a>01411     <span class="keywordflow">if</span>((!uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#831dde25d8ef14de7a0c73bc3a5fa3c9">in_fusion</a>) || uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#e915e589eff078d3f108ff4d45ed216c">is_fusion_head</a>)
<a name="l01412"></a>01412     {
<a name="l01413"></a>01413       Mop-&gt;<a class="code" href="structMop__t.html#42838437539e18e14b2049aa3ad512c2">stat</a>.<a class="code" href="structMop__t.html#b63d1f53be60fd17e64b2e6fe22e6f3b">num_uops</a>++;
<a name="l01414"></a>01414       <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#9c6c4ccf8310d7a378ea90b01555d141">oracle_total_uops</a>++;)
<a name="l01415"></a>01415     }
<a name="l01416"></a>01416     Mop-&gt;<a class="code" href="structMop__t.html#42838437539e18e14b2049aa3ad512c2">stat</a>.<a class="code" href="structMop__t.html#e76ae084a61689a2170b98ffd872a6a3">num_eff_uops</a>++;
<a name="l01417"></a>01417     <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#8c9802fcef07a9344070d45736f9af17">oracle_total_eff_uops</a>++;)
<a name="l01418"></a>01418 
<a name="l01419"></a>01419     <span class="keywordflow">if</span> (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#366552bee0ef835c75db8fedf12c11f7">F_CTRL</a>) {
<a name="l01420"></a>01420       Mop-&gt;<a class="code" href="structMop__t.html#42838437539e18e14b2049aa3ad512c2">stat</a>.<a class="code" href="structMop__t.html#3112da7835a7592682fa3c358e9d3cad">num_branches</a>++;
<a name="l01421"></a>01421       <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#437c271d49060c1283eb8a894ca5dda4">oracle_total_branches</a>++;)
<a name="l01422"></a>01422       <span class="keywordflow">if</span>(!<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01423"></a>01423         <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#41f068fd35eac1ec28b4fe69b88d1edd">oracle_num_branches</a>++;)
<a name="l01424"></a>01424     }
<a name="l01425"></a>01425     <span class="keywordflow">if</span> (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#a6be3e11431119e8d3ab666ab4f5ded7">F_MEM</a>) 
<a name="l01426"></a>01426     {
<a name="l01427"></a>01427       Mop-&gt;<a class="code" href="structMop__t.html#42838437539e18e14b2049aa3ad512c2">stat</a>.<a class="code" href="structMop__t.html#f0c857b3ff34e7bac381f3999036c251">num_refs</a>++;
<a name="l01428"></a>01428       <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7fe9765f24e107db96dbb0fb43085d11">oracle_total_refs</a>++;)
<a name="l01429"></a>01429       <span class="keywordflow">if</span>(!<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01430"></a>01430         <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#9d38f70d7711758002a9f0a103dbddf0">oracle_num_refs</a>++;)
<a name="l01431"></a>01431       <span class="keywordflow">if</span> (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#049e7e1cae99e04134e75e9f7f300a7b">opflags</a> &amp; <a class="code" href="machine_8h.html#a696f4e8edb147969a12513f7b195e9a">F_LOAD</a>) {
<a name="l01432"></a>01432         Mop-&gt;<a class="code" href="structMop__t.html#42838437539e18e14b2049aa3ad512c2">stat</a>.<a class="code" href="structMop__t.html#52274c64edc3d83425766a0f8cdd71df">num_loads</a>++;
<a name="l01433"></a>01433         <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#7e3c8f66ac3b8562f5f65a84c99a19c9">oracle_total_loads</a>++;)
<a name="l01434"></a>01434         <span class="keywordflow">if</span>(!<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01435"></a>01435           <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#b0f22a4d1fc67a8007391bf9d139cbab">oracle_num_loads</a>++;)
<a name="l01436"></a>01436       }
<a name="l01437"></a>01437     }
<a name="l01438"></a>01438 
<a name="l01439"></a>01439     flow_index += <a class="code" href="machine_8h.html#c2cab6744a434647b35f28d966f98d73">MD_INC_FLOW</a>;
<a name="l01440"></a>01440   }
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   <span class="comment">/* Do FP-stack adjustments if necessary */</span>
<a name="l01443"></a>01443   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7fb3398e3b0132467e40c95cb551db96">fpstack_op</a> != <a class="code" href="machine_8h.html#bbcc806996635e0671f66e73317b0c9646e33ab1efe19f95f336d480778b1669">fpstk_nop</a>)
<a name="l01444"></a>01444     <a class="code" href="zesto-oracle_8cpp.html#a751a02ae08302c577ec12f2ca780b81">FPSTACK_IMPL</a>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7fb3398e3b0132467e40c95cb551db96">fpstack_op</a>);
<a name="l01445"></a>01445 
<a name="l01446"></a>01446   <span class="comment">/* update register mappings, inter-uop dependencies */</span>
<a name="l01447"></a>01447   <span class="comment">/* NOTE: this occurs in its own loop because the above loop</span>
<a name="l01448"></a>01448 <span class="comment">     may terminate prematurely if a bogus fetch condition is</span>
<a name="l01449"></a>01449 <span class="comment">     encountered. */</span>
<a name="l01450"></a>01450   flow_index = 0;
<a name="l01451"></a>01451   <span class="keywordflow">while</span>(flow_index &lt; Mop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.flow_length)
<a name="l01452"></a>01452   {
<a name="l01453"></a>01453     <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[flow_index];
<a name="l01454"></a>01454 
<a name="l01455"></a>01455     <a class="code" href="classcore__oracle__t.html#deeae95a29f95000a81b20fb895a2e64">install_dependencies</a>(uop); <span class="comment">/* update back/fwd pointers between uop and parent */</span>
<a name="l01456"></a>01456     <a class="code" href="classcore__oracle__t.html#8a47de2d0fbb812311a55d1204cdc1c1">install_mapping</a>(uop); <span class="comment">/* add self to register mapping (oracle's rename table) */</span>
<a name="l01457"></a>01457     flow_index += <a class="code" href="machine_8h.html#c2cab6744a434647b35f28d966f98d73">MD_INC_FLOW</a>;
<a name="l01458"></a>01458   }
<a name="l01459"></a>01459 
<a name="l01460"></a>01460   <span class="comment">/* if PC==NPC, means we're still REP'ing */</span>
<a name="l01461"></a>01461   <span class="keywordflow">if</span>(thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> == thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>)
<a name="l01462"></a>01462   {
<a name="l01464"></a>01464     assert(Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#92d2861b39c23b47dd58854da3288e81">spec_mode</a> || Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#3cb7c4132587d2f78d978d951ab0eef7">rep</a>);    
<a name="l01465"></a>01465     thread-&gt;<a class="code" href="structthread__t.html#d907b780c1717ccfc70ddc4c6f56d17b">rep_sequence</a> ++;
<a name="l01466"></a>01466   }
<a name="l01467"></a>01467   <span class="keywordflow">else</span>
<a name="l01468"></a>01468   {
<a name="l01469"></a>01469     Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#82638df3748d18d1c8c2e3d58d077a49">last_uop_index</a>].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#be01a5d7b4a12d36d753ca8e295cceb6">EOM</a> = <span class="keyword">true</span>; <span class="comment">/* Mark EOM if appropriate */</span>
<a name="l01470"></a>01470     thread-&gt;<a class="code" href="structthread__t.html#d907b780c1717ccfc70ddc4c6f56d17b">rep_sequence</a> = 0;
<a name="l01471"></a>01471   }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#82638df3748d18d1c8c2e3d58d077a49">last_uop_index</a>].<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#be01a5d7b4a12d36d753ca8e295cceb6">EOM</a>) <span class="comment">/* count insts based on EOM markers */</span>
<a name="l01474"></a>01474   {
<a name="l01475"></a>01475     <span class="keywordflow">if</span>(!Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#92d2861b39c23b47dd58854da3288e81">spec_mode</a>)
<a name="l01476"></a>01476       thread-&gt;<a class="code" href="structthread__t.html#9ec7f775f2b8390dc4088ee1c40d9cc3">stat</a>.<a class="code" href="structthread__t.html#f868fe7453e104d71cbe7cd80248a451">num_insn</a>++;
<a name="l01477"></a>01477     <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#94cb8397eca3462590b990f8e428e0be">oracle_total_insn</a>++;)
<a name="l01478"></a>01478   }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480 <span class="comment">//  /* maintain $r0 semantics */</span>
<a name="l01481"></a>01481 <span class="comment">//  thread-&gt;regs.regs_R.dw[MD_REG_ZERO] = 0;</span>
<a name="l01482"></a>01482 
<a name="l01483"></a>01483   Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#56859cbd74e3f756c4b2ef9f573fe642">NextPC</a> = thread-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>;
<a name="l01484"></a>01484 
<a name="l01485"></a>01485   <span class="comment">/* commit this inst to the MopQ */</span>
<a name="l01486"></a>01486   <a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a> = <a class="code" href="misc_8h.html#ec0decc56f83415e5cd152f876e5dde1">modinc</a>(<a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a>,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//(MopQ_tail + 1) % MopQ_size;</span>
<a name="l01487"></a>01487   <a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> ++;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489 
<a name="l01490"></a>01490   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#2ac0786c8628d0e7042cdc07a8d6fcdd">is_trap</a>)
<a name="l01491"></a>01491   {    
<a name="l01492"></a>01492     <a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a> = Mop;
<a name="l01493"></a>01493     <span class="comment">/* make sure pipeline has drained */</span>
<a name="l01494"></a>01494     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> &gt; 0)
<a name="l01495"></a>01495     {
<a name="l01497"></a>01497       <span class="keywordflow">return</span> NULL;
<a name="l01498"></a>01498     }
<a name="l01499"></a>01499     <span class="keywordflow">else</span>
<a name="l01500"></a>01500       assert(!<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>);
<a name="l01501"></a>01501   }
<a name="l01502"></a>01502 
<a name="l01503"></a>01503   <a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a> = Mop;
<a name="l01504"></a>01504 
<a name="l01505"></a>01505   assert(Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a>); <span class="comment">/* there had better be at least one uop */</span>
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 <span class="preprocessor">#ifdef ZTRACE</span>
<a name="l01508"></a>01508 <span class="preprocessor"></span>  ztrace_print(Mop);
<a name="l01509"></a>01509 <span class="preprocessor">#endif</span>
<a name="l01510"></a>01510 <span class="preprocessor"></span>
<a name="l01512"></a>01512   <span class="keywordflow">return</span> Mop;
<a name="l01513"></a>01513 }
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 <span class="comment">/* After calling oracle-exec, you need to first call this function</span>
<a name="l01516"></a>01516 <span class="comment">   to tell the oracle that you are in fact done with the previous</span>
<a name="l01517"></a>01517 <span class="comment">   Mop.  This may occur due to interruptions half-way through fetch</span>
<a name="l01518"></a>01518 <span class="comment">   processing (e.g., instruction spilt across cache lines). */</span>
<a name="l01519"></a><a class="code" href="classcore__oracle__t.html#527c3d85c2b86a3fed4c223b529dd33f">01519</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#527c3d85c2b86a3fed4c223b529dd33f">core_oracle_t::consume</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> <a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a>)
<a name="l01520"></a>01520 {
<a name="l01521"></a>01521   assert(Mop == <a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a>);
<a name="l01522"></a>01522   <span class="comment">//if(Mop-&gt;decode.is_trap)</span>
<a name="l01523"></a>01523           <span class="comment">//fprintf(stdout,"\n[%lld]Oracle : Consuming Macro-op",sim_cycle);</span>
<a name="l01524"></a>01524   <a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a> = NULL;
<a name="l01525"></a>01525 }
<a name="l01526"></a>01526 
<a name="l01527"></a><a class="code" href="classcore__oracle__t.html#ba02df09c524181a44404676f33669a5">01527</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#ba02df09c524181a44404676f33669a5">core_oracle_t::commit_uop</a>(<span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a> * <span class="keyword">const</span> uop)
<a name="l01528"></a>01528 {
<a name="l01529"></a>01529   <span class="comment">/* clean up idep/odep ptrs */</span>
<a name="l01530"></a>01530   <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * odep = uop-&gt;<a class="code" href="structuop__t.html#effc0bd8baf056d9abde991743af3cc3">exec</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a>;
<a name="l01531"></a>01531   <span class="keywordflow">while</span>(odep)
<a name="l01532"></a>01532   {
<a name="l01533"></a>01533     <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * <a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a> = odep-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a>;
<a name="l01534"></a>01534     <a class="code" href="zesto-oracle_8h.html#4f942292a4c30024a9b7fe4f9b1820a4">zesto_assert</a>(odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a>,(<span class="keywordtype">void</span>)0);
<a name="l01535"></a>01535     odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a>-&gt;<a class="code" href="structuop__t.html#effc0bd8baf056d9abde991743af3cc3">exec</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[odep-&gt;<a class="code" href="structodep__t.html#a9047cb0f60d68673900ec2fd18b2263">op_num</a>] = NULL;
<a name="l01536"></a>01536     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#c76899d81828f8557930f9ab87f4938e">return_odep_link</a>(odep);
<a name="l01537"></a>01537     odep = next;
<a name="l01538"></a>01538   }
<a name="l01539"></a>01539   uop-&gt;<a class="code" href="structuop__t.html#effc0bd8baf056d9abde991743af3cc3">exec</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a> = NULL;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="comment">/* remove self from register mapping */</span>
<a name="l01542"></a>01542   <a class="code" href="classcore__oracle__t.html#9c6462ead2fb5d7d4134ff11fc918029">commit_mapping</a>(uop);
<a name="l01543"></a>01543 
<a name="l01544"></a>01544   <span class="comment">/* clear oracle's back/fwd pointers between uop and children */</span>
<a name="l01545"></a>01545   <a class="code" href="classcore__oracle__t.html#999bfe83c41ad19d351d0cfc5cc1b16a">commit_dependencies</a>(uop);
<a name="l01546"></a>01546 
<a name="l01547"></a>01547 
<a name="l01548"></a>01548   <span class="comment">/* commit memory writes to real memory system NOT NEEDED ANYMORE with QEMU</span>
<a name="l01549"></a>01549 <span class="comment">  for(int j=0;j&lt;12;j++)</span>
<a name="l01550"></a>01550 <span class="comment">  {</span>
<a name="l01551"></a>01551 <span class="comment">    if(!uop-&gt;oracle.spec_mem[j])</span>
<a name="l01552"></a>01552 <span class="comment">      break;</span>
<a name="l01553"></a>01553 <span class="comment">    MEM_WRITE_BYTE_NON_SPEC(core-&gt;current_thread-&gt;mem, uop-&gt;oracle.virt_addr+j, uop-&gt;oracle.spec_mem[j]-&gt;val);</span>
<a name="l01554"></a>01554 <span class="comment">    core-&gt;oracle-&gt;commit_write_byte(uop-&gt;oracle.spec_mem[j]);</span>
<a name="l01555"></a>01555 <span class="comment">    uop-&gt;oracle.spec_mem[j] = NULL;</span>
<a name="l01556"></a>01556 <span class="comment">  }*/</span>
<a name="l01557"></a>01557 }
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 <span class="comment">/* This is called by the backend to inform the oracle that the pipeline has</span>
<a name="l01560"></a>01560 <span class="comment">   completed processing (committed) the entire Mop. */</span>
<a name="l01561"></a>01561 <span class="keywordtype">void</span>
<a name="l01562"></a><a class="code" href="classcore__oracle__t.html#5656906c0caee72b39f9d3760341de99">01562</a> <a class="code" href="classcore__oracle__t.html#5656906c0caee72b39f9d3760341de99">core_oracle_t::commit</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> commit_Mop)
<a name="l01563"></a>01563 {
<a name="l01564"></a>01564   <span class="keyword">struct </span><a class="code" href="structMop__t.html">Mop_t</a> * Mop = &amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[<a class="code" href="classcore__oracle__t.html#70cbf1e1615f32f3f61216ef002aba42">MopQ_head</a>];
<a name="l01565"></a>01565 
<a name="l01566"></a>01566   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> &lt;= 0) <span class="comment">/* nothing to commit */</span>
<a name="l01567"></a>01567     <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"attempt to commit when MopQ is empty"</span>);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569   assert(Mop == commit_Mop);
<a name="l01570"></a>01570 
<a name="l01571"></a>01571   <span class="comment">/* TODO: add checker support */</span>
<a name="l01572"></a>01572 
<a name="l01573"></a>01573   assert(Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#92d2861b39c23b47dd58854da3288e81">spec_mode</a> == 0); <span class="comment">/* can't commit wrong path insts! */</span>
<a name="l01574"></a>01574 
<a name="l01575"></a>01575   Mop-&gt;<a class="code" href="structMop__t.html#9de159d013ea3a9cca480a4d459d5eb4">valid</a> = <span class="keyword">false</span>;
<a name="l01576"></a>01576 
<a name="l01577"></a>01577   <a class="code" href="classcore__oracle__t.html#70cbf1e1615f32f3f61216ef002aba42">MopQ_head</a> = <a class="code" href="misc_8h.html#ec0decc56f83415e5cd152f876e5dde1">modinc</a>(<a class="code" href="classcore__oracle__t.html#70cbf1e1615f32f3f61216ef002aba42">MopQ_head</a>,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//(MopQ_head + 1) % MopQ_size;</span>
<a name="l01578"></a>01578   <span class="comment">//fprintf(stdout,"\n[%lld]Oracle.commit() Decrementing MopQ_num",sim_cycle);</span>
<a name="l01579"></a>01579   <a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a>--;
<a name="l01580"></a>01580   assert(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> &gt;= 0);
<a name="l01581"></a>01581 }
<a name="l01582"></a>01582 
<a name="l01583"></a>01583 <span class="comment">/* Undo the effects of the single Mop.  This function only affects the ISA-level</span>
<a name="l01584"></a>01584 <span class="comment">   state.  Bookkeeping for the MopQ and other core-level structures has to be</span>
<a name="l01585"></a>01585 <span class="comment">   dealt with separately. */</span>
<a name="l01586"></a>01586 <span class="keywordtype">void</span>
<a name="l01587"></a><a class="code" href="classcore__oracle__t.html#0d7765bb5655c1dd28f758143caaa8ce">01587</a> <a class="code" href="classcore__oracle__t.html#0d7765bb5655c1dd28f758143caaa8ce">core_oracle_t::undo</a>(<span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> Mop)
<a name="l01588"></a>01588 {
<a name="l01589"></a>01589   <span class="keyword">struct </span><a class="code" href="structthread__t.html">thread_t</a> * thread = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>;
<a name="l01590"></a>01590   <span class="comment">/* walk uop list backwards, undoing each operation's effects */</span>
<a name="l01591"></a>01591   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a>-1;i&gt;=0;i--)
<a name="l01592"></a>01592   {
<a name="l01593"></a>01593     <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[i];
<a name="l01594"></a>01594     uop-&gt;<a class="code" href="structuop__t.html#effc0bd8baf056d9abde991743af3cc3">exec</a>.<a class="code" href="structuop__t.html#47dc4af18b603fd6693da3d213ff3298">action_id</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#110f33d959a11c403fb9166326c7e5f3">new_action_id</a>(); <span class="comment">/* squashes any in-flight loads/stores */</span>
<a name="l01595"></a>01595 
<a name="l01596"></a>01596     <span class="comment">/* collect stats */</span>
<a name="l01597"></a>01597     <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#be01a5d7b4a12d36d753ca8e295cceb6">EOM</a>)
<a name="l01598"></a>01598     {
<a name="l01599"></a>01599       <span class="keywordflow">if</span>(!Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#92d2861b39c23b47dd58854da3288e81">spec_mode</a>)
<a name="l01600"></a>01600       {
<a name="l01601"></a>01601         thread-&gt;<a class="code" href="structthread__t.html#9ec7f775f2b8390dc4088ee1c40d9cc3">stat</a>.<a class="code" href="structthread__t.html#f868fe7453e104d71cbe7cd80248a451">num_insn</a> --; <span class="comment">/* one less oracle instruction executed */</span>
<a name="l01602"></a>01602       }
<a name="l01603"></a>01603       <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#4297d18ae42208a6fe8d25fe88ab13c7">oracle_inst_undo</a> ++;)
<a name="l01604"></a>01604     }
<a name="l01605"></a>01605 
<a name="l01606"></a>01606     <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#b1051f89245a2a2d5ea721ab6b4c9870">is_imm</a>)
<a name="l01607"></a>01607       <span class="keywordflow">continue</span>;
<a name="l01608"></a>01608     <span class="keywordflow">else</span>
<a name="l01609"></a>01609     { 
<a name="l01610"></a>01610       <span class="comment">/* one less oracle uop executed */</span>
<a name="l01611"></a>01611       <span class="keywordflow">if</span>(!uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#831dde25d8ef14de7a0c73bc3a5fa3c9">in_fusion</a> || uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#e915e589eff078d3f108ff4d45ed216c">is_fusion_head</a>)
<a name="l01612"></a>01612       {
<a name="l01613"></a>01613         <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#73d06bc16b62c80eb6e6bb28f4494a98">oracle_uop_undo</a> ++;)
<a name="l01614"></a>01614       }
<a name="l01615"></a>01615       <a class="code" href="zesto-opts_8h.html#225a9a02a0c5a33775f2743a37dfd8d8">ZESTO_STAT</a>(<a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#f45e29e7af5cc3d2d4642fde587eb4c7">oracle_eff_uop_undo</a> ++;)
<a name="l01616"></a>01616     }
<a name="l01617"></a>01617 
<a name="l01618"></a>01618     <span class="comment">/* undo register write NOT NEEDED WITH QEMU */</span>
<a name="l01619"></a>01619     <span class="comment">//if((uop-&gt;decode.odep_name != DNA) &amp;&amp; (uop-&gt;decode.odep_name != MD_REG_ZERO))</span>
<a name="l01620"></a>01620     <span class="comment">//{</span>
<a name="l01621"></a>01621     <span class="comment">//  if(REG_IS_GPR(uop-&gt;decode.odep_name))</span>
<a name="l01622"></a>01622     <span class="comment">//    thread-&gt;regs.regs_R.dw[_DGPR(uop-&gt;decode.odep_name)] = uop-&gt;oracle.prev_ovalue.dw;</span>
<a name="l01623"></a>01623     <span class="comment">//  else if(REG_IS_FPR(uop-&gt;decode.odep_name))</span>
<a name="l01624"></a>01624     <span class="comment">//    thread-&gt;regs.regs_F.e[_DFPR(uop-&gt;decode.odep_name)] = uop-&gt;oracle.prev_ovalue.e;</span>
<a name="l01625"></a>01625     <span class="comment">//  else if(REG_IS_SEG(uop-&gt;decode.odep_name))</span>
<a name="l01626"></a>01626     <span class="comment">//    thread-&gt;regs.regs_S.w[_DSEG(uop-&gt;decode.odep_name)] = uop-&gt;oracle.prev_ovalue.w;</span>
<a name="l01627"></a>01627     <span class="comment">//}</span>
<a name="l01628"></a>01628 
<a name="l01629"></a>01629     <span class="comment">/* undo ctrl register updates */</span>
<a name="l01630"></a>01630     <span class="comment">//thread-&gt;regs.regs_C = uop-&gt;oracle.ictrl;</span>
<a name="l01631"></a>01631 
<a name="l01632"></a>01632     <span class="comment">/* undo memory changes NOT NEEDED ANYMORE with QEMU</span>
<a name="l01633"></a>01633 <span class="comment">    if(uop-&gt;decode.is_std)</span>
<a name="l01634"></a>01634 <span class="comment">    {</span>
<a name="l01635"></a>01635 <span class="comment">      for(int j=0;j&lt;12;j++)</span>
<a name="l01636"></a>01636 <span class="comment">      {</span>
<a name="l01637"></a>01637 <span class="comment">        if(uop-&gt;oracle.spec_mem[j] == NULL)</span>
<a name="l01638"></a>01638 <span class="comment">          break;</span>
<a name="l01639"></a>01639 <span class="comment">        squash_write_byte(uop-&gt;oracle.spec_mem[j]);</span>
<a name="l01640"></a>01640 <span class="comment">        uop-&gt;oracle.spec_mem[j] = NULL;</span>
<a name="l01641"></a>01641 <span class="comment">      }</span>
<a name="l01642"></a>01642 <span class="comment">    }*/</span>
<a name="l01643"></a>01643 
<a name="l01644"></a>01644     <span class="comment">/* remove self from register mapping */</span>
<a name="l01645"></a>01645     <a class="code" href="classcore__oracle__t.html#dc47fe294aeba52e39f9a11276522823">undo_mapping</a>(uop);
<a name="l01646"></a>01646 
<a name="l01647"></a>01647     <span class="comment">/* clear back/fwd pointers between uop and parent */</span>
<a name="l01648"></a>01648     <a class="code" href="classcore__oracle__t.html#56379122fc2f63fc767cdf82e346b98b">undo_dependencies</a>(uop);
<a name="l01649"></a>01649   }
<a name="l01650"></a>01650 
<a name="l01651"></a>01651   thread-&gt;<a class="code" href="structthread__t.html#d907b780c1717ccfc70ddc4c6f56d17b">rep_sequence</a> = Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#4d78627f97c622df4b1a9ea232bdc5ce">rep_seq</a>;
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#5a1a1b0c85b6d77e4817a5fb68774b09">jeclear_action_id</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#110f33d959a11c403fb9166326c7e5f3">new_action_id</a>();
<a name="l01654"></a>01654 }
<a name="l01655"></a>01655 
<a name="l01656"></a>01656 <span class="comment">/* recover the oracle's state right up to Mop (but don't undo Mop) */</span>
<a name="l01657"></a>01657 <span class="keywordtype">void</span>
<a name="l01658"></a><a class="code" href="classcore__oracle__t.html#3262388e107011060f8fe40023f235c5">01658</a> <a class="code" href="classcore__oracle__t.html#3262388e107011060f8fe40023f235c5">core_oracle_t::recover</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> <a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a>)
<a name="l01659"></a>01659 {
<a name="l01660"></a>01660   <span class="keywordtype">int</span> idx = <a class="code" href="misc_8h.html#e72918bfe3eb9d02e83975f2739a7ab2">moddec</a>(<a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a>,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//(MopQ_tail-1+MopQ_size) % MopQ_size;</span>
<a name="l01661"></a>01661   <span class="comment">//fprintf(stdout,"\n\n[%lld]Oracle.recover_start()  Thread-&gt;PC= 0x%llx Thread-&gt;NPC= 0x%llx ", sim_cycle, core-&gt;current_thread-&gt;regs.regs_PC, core-&gt;current_thread-&gt;regs.regs_NPC);</span>
<a name="l01662"></a>01662   <span class="keywordflow">while</span>(Mop != &amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx])
<a name="l01663"></a>01663   {
<a name="l01664"></a>01664     <span class="keywordflow">if</span>(idx == <a class="code" href="classcore__oracle__t.html#70cbf1e1615f32f3f61216ef002aba42">MopQ_head</a>)
<a name="l01665"></a>01665       <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"ran out of Mop's before finding requested MopQ recovery point"</span>);
<a name="l01666"></a>01666     <a class="code" href="classcore__oracle__t.html#0d7765bb5655c1dd28f758143caaa8ce">undo</a>(&amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx]);
<a name="l01667"></a>01667     <a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#9de159d013ea3a9cca480a4d459d5eb4">valid</a> = <span class="keyword">false</span>;
<a name="l01668"></a>01668     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].fetch.<a class="code" href="structMop__t.html#f33535affa9efa0509db7e31a70bea08">bpred_update</a>)
<a name="l01669"></a>01669     {
<a name="l01670"></a>01670       <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#0dd5fd2d75f870de5fb95a496e3e6844">bpred</a>-&gt;<a class="code" href="classbpred__t.html#5e29cd0982fcca98f66db5f4cc11321a">flush</a>(<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].fetch.<a class="code" href="structMop__t.html#f33535affa9efa0509db7e31a70bea08">bpred_update</a>);
<a name="l01671"></a>01671       <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#0dd5fd2d75f870de5fb95a496e3e6844">bpred</a>-&gt;<a class="code" href="classbpred__t.html#f9c3b3c249ede7672c20b900ff8768e9">return_state_cache</a>(<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].fetch.<a class="code" href="structMop__t.html#f33535affa9efa0509db7e31a70bea08">bpred_update</a>);
<a name="l01672"></a>01672       <a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#f33535affa9efa0509db7e31a70bea08">bpred_update</a> = NULL;
<a name="l01673"></a>01673     }
<a name="l01674"></a>01674 
<a name="l01675"></a>01675     <a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> --;
<a name="l01676"></a>01676     <a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a> = idx;
<a name="l01677"></a>01677     idx = <a class="code" href="misc_8h.html#e72918bfe3eb9d02e83975f2739a7ab2">moddec</a>(idx,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//(idx-1+MopQ_size) % MopQ_size;</span>
<a name="l01678"></a>01678   }
<a name="l01679"></a>01679   <span class="comment">/* reset PC */</span>
<a name="l01680"></a>01680   <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#b816a0b34ea5ca8a061c02c6946fef3e">branch_mispred</a>) <span class="comment">//If this is a recover due to branch misprediction</span>
<a name="l01681"></a>01681   {
<a name="l01682"></a>01682         <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> = Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#5645e3dfe55b1b6b2206ffb38379c44d">PC</a>;
<a name="l01683"></a>01683         <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a> = Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#56859cbd74e3f756c4b2ef9f573fe642">NextPC</a>;
<a name="l01684"></a>01684   }
<a name="l01685"></a>01685   <span class="keywordflow">else</span>  <span class="comment">//jeclear due to store misordering TODO: reexecute from previous Mop</span>
<a name="l01686"></a>01686   {
<a name="l01687"></a>01687         <span class="comment">//core-&gt;current_thread-&gt;regs.regs_PC = Mop-&gt;fetch.PC;</span>
<a name="l01688"></a>01688         <span class="comment">//core-&gt;current_thread-&gt;regs.regs_NPC = Mop-&gt;oracle.NextPC;</span>
<a name="l01689"></a>01689   }
<a name="l01690"></a>01690   <a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a> = Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#92d2861b39c23b47dd58854da3288e81">spec_mode</a>;
<a name="l01691"></a>01691   <a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a> = NULL;
<a name="l01692"></a>01692   <span class="comment">//fprintf(stdout,"\n[%lld]Oracle.recover_end()  Thread-&gt;PC= 0x%llx Thread-&gt;NPC= 0x%llx ", sim_cycle, core-&gt;current_thread-&gt;regs.regs_PC, core-&gt;current_thread-&gt;regs.regs_NPC);</span>
<a name="l01693"></a>01693 }
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 <span class="comment">/* flush everything after Mop */</span>
<a name="l01696"></a><a class="code" href="classcore__oracle__t.html#c687f6e9c8564e5fd108ca8c9f771dce">01696</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#c687f6e9c8564e5fd108ca8c9f771dce">core_oracle_t::pipe_recover</a>(<span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> <a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a>, <span class="keyword">const</span> <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> New_PC)
<a name="l01697"></a>01697 {
<a name="l01698"></a>01698   <span class="keyword">struct </span><a class="code" href="structcore__knobs__t.html">core_knobs_t</a> * <a class="code" href="sim-zesto_8cpp.html#89a180011adecec49b08c8ef843388fa">knobs</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#a397a3f36f045e3c2a19dafc16dab1c1">knobs</a>;
<a name="l01699"></a>01699   <span class="keywordflow">if</span>(knobs-&gt;<a class="code" href="structcore__knobs__t.html#7255d0ea236298f95bb8fb003a06c613">fetch</a>.<a class="code" href="structcore__knobs__t.html#c899955252aaaa5b0bd449e2e0ed05f7">jeclear_delay</a>)
<a name="l01700"></a>01700     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#9221709533fb19b4a70b54a426ca8c25">jeclear_enqueue</a>(Mop,New_PC);
<a name="l01701"></a>01701   <span class="keywordflow">else</span>
<a name="l01702"></a>01702   {
<a name="l01703"></a>01703     <span class="keywordflow">if</span>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#f33535affa9efa0509db7e31a70bea08">bpred_update</a>)
<a name="l01704"></a>01704       <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#0dd5fd2d75f870de5fb95a496e3e6844">bpred</a>-&gt;<a class="code" href="classbpred__t.html#d355ab253a6029ba45cc4fa10229081d">recover</a>(Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#f33535affa9efa0509db7e31a70bea08">bpred_update</a>,(New_PC != (Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#5645e3dfe55b1b6b2206ffb38379c44d">PC</a> + Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#268a8bdf9dc08de70db61fbbdd52480d">inst</a>.<a class="code" href="structmd__inst__t.html#5dad80b28e8ae15c2bd387663d32fb7e">len</a>)));
<a name="l01705"></a>01705     <span class="comment">/*core-&gt;oracle-&gt;*/</span><a class="code" href="classcore__oracle__t.html#3262388e107011060f8fe40023f235c5">recover</a>(Mop);
<a name="l01706"></a>01706     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#1058815318dc1da3c60b90d9a5479092">commit</a>-&gt;<a class="code" href="classcore__commit__t.html#93b5aa051280bff8ca2a57bf00fd3f87">recover</a>(Mop);
<a name="l01707"></a>01707     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd8831061ddb119a3abe035f7a482b55">exec</a>-&gt;<a class="code" href="classcore__exec__t.html#b9edcea5d76d1bbdbe89696ddf876c73">recover</a>(Mop);
<a name="l01708"></a>01708     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#20394b8c7a44d5ad56a16e9cd635299e">alloc</a>-&gt;<a class="code" href="classcore__alloc__t.html#e8350cafe32ac5219eaea41e6fb11f57">recover</a>(Mop);
<a name="l01709"></a>01709     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#5a8f490b74ace2edeb7f90c493c98691">decode</a>-&gt;<a class="code" href="classcore__decode__t.html#4cc12f3baa24ee5764ae57d87b759743">recover</a>(Mop);
<a name="l01710"></a>01710     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#5f9f05d72804be74a2a622eeb5456e51">recover</a>(New_PC);
<a name="l01711"></a>01711   }
<a name="l01712"></a>01712 }
<a name="l01713"></a>01713 
<a name="l01714"></a>01714 <span class="comment">/* flush everything including the Mop; restart fetching with this</span>
<a name="l01715"></a>01715 <span class="comment">   Mop again. */</span>
<a name="l01716"></a><a class="code" href="classcore__oracle__t.html#d79ed0d31e9421037f71a3aae2aa0cbb">01716</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#d79ed0d31e9421037f71a3aae2aa0cbb">core_oracle_t::pipe_flush</a>(<span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> Mop)
<a name="l01717"></a>01717 {
<a name="l01718"></a>01718   <span class="keyword">const</span> <span class="keywordtype">int</span> prev_Mop_index = <a class="code" href="misc_8h.html#e72918bfe3eb9d02e83975f2739a7ab2">moddec</a>(Mop-<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//((Mop - MopQ) - 1 + MopQ_size) % MopQ_size;</span>
<a name="l01719"></a>01719   <a class="code" href="zesto-oracle_8h.html#4f942292a4c30024a9b7fe4f9b1820a4">zesto_assert</a>(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> &gt; 1 &amp;&amp; (Mop != &amp; <a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[<a class="code" href="classcore__oracle__t.html#70cbf1e1615f32f3f61216ef002aba42">MopQ_head</a>]),(<span class="keywordtype">void</span>)0); <span class="comment">/* I don't think there are any uop flows that can cause intra-Mop violations */</span>
<a name="l01720"></a>01720   <span class="keyword">struct </span><a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> prev_Mop = &amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[prev_Mop_index];
<a name="l01721"></a>01721   <span class="comment">/* CALLs/RETNs where the PC is loaded from memory, and that load is involved</span>
<a name="l01722"></a>01722 <span class="comment">     in a store-load ordering violation, can cause a branch (target) mispredict</span>
<a name="l01723"></a>01723 <span class="comment">     recovery from being properly taken care of (partly due to the fact that</span>
<a name="l01724"></a>01724 <span class="comment">     our uop flow does not act on the recovery until the lasp uop of the flow,</span>
<a name="l01725"></a>01725 <span class="comment">     which is typically *not* the load).  So to get around that, we just patch</span>
<a name="l01726"></a>01726 <span class="comment">     up the predicted NPC. */</span>
<a name="l01727"></a>01727   prev_Mop-&gt;<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#2337789f03bfd40d471eafa6e31b4b45">pred_NPC</a> = prev_Mop-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#56859cbd74e3f756c4b2ef9f573fe642">NextPC</a>;
<a name="l01728"></a>01728 
<a name="l01729"></a>01729   <span class="comment">//pipe_recover(prev_Mop, prev_Mop-&gt;fetch.pred_NPC);</span>
<a name="l01730"></a>01730   <span class="comment">//fprintf(stdout,"\n[%lld]Oracle.pipe_flush()  Now start from = 0x%llx ", sim_cycle, Mop-&gt;core-&gt;current_thread-&gt;regs.regs_NPC);</span>
<a name="l01731"></a>01731   <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> current_nextPC;
<a name="l01732"></a>01732 <span class="preprocessor">#ifdef USE_PIN_TRACES</span>
<a name="l01733"></a>01733 <span class="preprocessor"></span>  current_nextPC=<a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[Mop-&gt;<a class="code" href="structMop__t.html#2ab1350e46f43d1327adc1457ac77372">core</a>-&gt;<a class="code" href="classcore__t.html#3a8653bac0ed9aefff8d1679ca81546f">id</a>];
<a name="l01734"></a>01734 <span class="preprocessor">#else</span>
<a name="l01735"></a>01735 <span class="preprocessor"></span>  <a class="code" href="zesto-oracle_8cpp.html#4603dc5f3e60fbfcd30343123777d18c">md_fetch_next_pc</a>(&amp;current_nextPC,Mop-&gt;<a class="code" href="structMop__t.html#2ab1350e46f43d1327adc1457ac77372">core</a>-&gt;<a class="code" href="classcore__t.html#3a8653bac0ed9aefff8d1679ca81546f">id</a>);
<a name="l01736"></a>01736 <span class="preprocessor">#endif</span>
<a name="l01737"></a>01737 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(!<a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a>)
<a name="l01738"></a>01738           <a class="code" href="classcore__oracle__t.html#c687f6e9c8564e5fd108ca8c9f771dce">pipe_recover</a>(Mop, Mop-&gt;<a class="code" href="structMop__t.html#2ab1350e46f43d1327adc1457ac77372">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>);
<a name="l01739"></a>01739   <span class="keywordflow">else</span> <span class="comment">//If the mode is speculative the thread PC and nextPC are the same so that no-ops do not run off into the address stream</span>
<a name="l01740"></a>01740           <a class="code" href="classcore__oracle__t.html#c687f6e9c8564e5fd108ca8c9f771dce">pipe_recover</a>(Mop, current_nextPC);
<a name="l01741"></a>01741   <span class="comment">//TODO: All Mops must be refetched and executed following a memory order violation, For now we just go ahead with the next instruction stream assuming this does not happen too often </span>
<a name="l01742"></a>01742 
<a name="l01743"></a>01743 }
<a name="l01744"></a>01744 
<a name="l01745"></a>01745 <span class="comment">/* like oracle recover, but empties out the entire pipeline, wrong-path or not */</span>
<a name="l01746"></a>01746 <span class="keywordtype">void</span>
<a name="l01747"></a><a class="code" href="classcore__oracle__t.html#9f125e90b225555a2632277161f3b27c">01747</a> <a class="code" href="classcore__oracle__t.html#9f125e90b225555a2632277161f3b27c">core_oracle_t::complete_flush</a>(<span class="keywordtype">void</span>)
<a name="l01748"></a>01748 {
<a name="l01749"></a>01749   <span class="keywordtype">int</span> idx = <a class="code" href="misc_8h.html#e72918bfe3eb9d02e83975f2739a7ab2">moddec</a>(<a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a>,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//(MopQ_tail-1+MopQ_size) % MopQ_size;</span>
<a name="l01750"></a>01750   <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> arch_PC = 0x00000000LL;
<a name="l01751"></a>01751   <span class="keywordflow">while</span>(<a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a>)
<a name="l01752"></a>01752   {
<a name="l01753"></a>01753     arch_PC = <a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#5645e3dfe55b1b6b2206ffb38379c44d">PC</a>;
<a name="l01754"></a>01754     assert(<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#9de159d013ea3a9cca480a4d459d5eb4">valid</a>);
<a name="l01755"></a>01755     <a class="code" href="classcore__oracle__t.html#0d7765bb5655c1dd28f758143caaa8ce">undo</a>(&amp;<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx]);
<a name="l01756"></a>01756     <a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#9de159d013ea3a9cca480a4d459d5eb4">valid</a> = <span class="keyword">false</span>;
<a name="l01757"></a>01757     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.bpred_update)
<a name="l01758"></a>01758     {
<a name="l01759"></a>01759       <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#0dd5fd2d75f870de5fb95a496e3e6844">bpred</a>-&gt;<a class="code" href="classbpred__t.html#5e29cd0982fcca98f66db5f4cc11321a">flush</a>(<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.bpred_update);
<a name="l01760"></a>01760       <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#0dd5fd2d75f870de5fb95a496e3e6844">bpred</a>-&gt;<a class="code" href="classbpred__t.html#f9c3b3c249ede7672c20b900ff8768e9">return_state_cache</a>(<a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.bpred_update);
<a name="l01761"></a>01761       <a class="code" href="classcore__oracle__t.html#ce39de7d819c6a08c18fce9294162dad">MopQ</a>[idx].<a class="code" href="structMop__t.html#068ff277465b6ed03aad00e96daccc62">fetch</a>.<a class="code" href="structMop__t.html#f33535affa9efa0509db7e31a70bea08">bpred_update</a> = NULL;
<a name="l01762"></a>01762     }
<a name="l01763"></a>01763 
<a name="l01764"></a>01764     <a class="code" href="classcore__oracle__t.html#c5e34c6486de6628dec11dae6b6139ef">MopQ_num</a> --;
<a name="l01765"></a>01765     <a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a> = idx;
<a name="l01766"></a>01766     idx = <a class="code" href="misc_8h.html#e72918bfe3eb9d02e83975f2739a7ab2">moddec</a>(idx,<a class="code" href="classcore__oracle__t.html#004d660ced8ad0c50b52372465d27012">MopQ_size</a>); <span class="comment">//(idx-1+MopQ_size) % MopQ_size;</span>
<a name="l01767"></a>01767   }
<a name="l01768"></a>01768   <span class="comment">/* reset PC */</span>
<a name="l01769"></a>01769   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a> = arch_PC;
<a name="l01770"></a>01770   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a> = arch_PC;
<a name="l01771"></a>01771   assert(<a class="code" href="classcore__oracle__t.html#70cbf1e1615f32f3f61216ef002aba42">MopQ_head</a> == <a class="code" href="classcore__oracle__t.html#f309d834c383b98e92101c00d3ac3133">MopQ_tail</a>);
<a name="l01772"></a>01772 
<a name="l01773"></a>01773   <a class="code" href="classcore__oracle__t.html#c3d9d77c3cc61cac13be93461b663fbb">spec_mode</a> = <span class="keyword">false</span>;
<a name="l01774"></a>01774   <a class="code" href="classcore__oracle__t.html#d1209b754eaf54cb0119beb43eea0929">current_Mop</a> = NULL;
<a name="l01775"></a>01775 }
<a name="l01776"></a>01776 
<a name="l01777"></a>01777 <span class="comment">/* This *completely* resets the oracle to restart execution all over</span>
<a name="l01778"></a>01778 <span class="comment">   again.  This reloads the initial simulated program state from the</span>
<a name="l01779"></a>01779 <span class="comment">   first checkpoint in the EIO file. */</span>
<a name="l01780"></a>01780 <span class="keywordtype">void</span>
<a name="l01781"></a><a class="code" href="classcore__oracle__t.html#cd307b32aa377a56b3f4dc79b2122038">01781</a> <a class="code" href="classcore__oracle__t.html#cd307b32aa377a56b3f4dc79b2122038">core_oracle_t::reset_execution</a>(<span class="keywordtype">void</span>)
<a name="l01782"></a>01782 {
<a name="l01783"></a>01783   <a class="code" href="classcore__oracle__t.html#9f125e90b225555a2632277161f3b27c">complete_flush</a>();
<a name="l01784"></a>01784   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#1058815318dc1da3c60b90d9a5479092">commit</a>-&gt;<a class="code" href="classcore__commit__t.html#93b5aa051280bff8ca2a57bf00fd3f87">recover</a>();
<a name="l01785"></a>01785   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd8831061ddb119a3abe035f7a482b55">exec</a>-&gt;<a class="code" href="classcore__exec__t.html#b9edcea5d76d1bbdbe89696ddf876c73">recover</a>();
<a name="l01786"></a>01786   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#20394b8c7a44d5ad56a16e9cd635299e">alloc</a>-&gt;<a class="code" href="classcore__alloc__t.html#e8350cafe32ac5219eaea41e6fb11f57">recover</a>();
<a name="l01787"></a>01787   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#5a8f490b74ace2edeb7f90c493c98691">decode</a>-&gt;<a class="code" href="classcore__decode__t.html#4cc12f3baa24ee5764ae57d87b759743">recover</a>();
<a name="l01788"></a>01788   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#5f9f05d72804be74a2a622eeb5456e51">recover</a>(0);
<a name="l01789"></a>01789   <span class="comment">// NOT NEEDED WITH QEMU wipe_memory(core-&gt;current_thread-&gt;mem);</span>
<a name="l01790"></a>01790 
<a name="l01791"></a>01791   <span class="comment">// NOT NEEDED WITH QEMU ld_reload_prog(core-&gt;current_thread);</span>
<a name="l01792"></a>01792   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#dadc3ae0443ab1d4eb3493d8847b10c8">PC</a> = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>;
<a name="l01793"></a>01793   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#ced0dd38e3004abe40e9eeb7ab865c1f">bogus</a> = <span class="keyword">false</span>;
<a name="l01794"></a>01794   <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#fd66018e0e0529be576f673452a032df">stat</a>.<a class="code" href="structcore__t_1_1core__stat__t.html#6f1c10a0ec011ec2b106084c7be4f640">oracle_resets</a>++;
<a name="l01795"></a>01795 }
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="comment">/* Called when a uop commits; removes uop from list of producers. */</span>
<a name="l01798"></a><a class="code" href="classcore__oracle__t.html#9c6462ead2fb5d7d4134ff11fc918029">01798</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#9c6462ead2fb5d7d4134ff11fc918029">core_oracle_t::commit_mapping</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a> * <span class="keyword">const</span> <a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>)
<a name="l01799"></a>01799 {
<a name="l01800"></a>01800   <span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1map__node__t.html">map_node_t</a> * p;
<a name="l01801"></a>01801 
<a name="l01802"></a>01802   <span class="comment">/* regular register output */</span>
<a name="l01803"></a>01803   <span class="keywordflow">if</span>((uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a> != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>) &amp;&amp; (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a> != <a class="code" href="machine_8h.html#7958b4dc7e6644b7c434becf7e2447f2">DGPR</a>(<a class="code" href="machine_8h.html#f09067c20691d3ae255145b7eee302c26c67316076cf9d98777ba6147f6b75f1">MD_REG_ZERO</a>)))
<a name="l01804"></a>01804   {
<a name="l01805"></a>01805     p = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>];
<a name="l01806"></a>01806 
<a name="l01807"></a>01807     <span class="comment">/* if you're committing this, it better be in the mapping */</span>
<a name="l01808"></a>01808     assert(p);
<a name="l01809"></a>01809     <span class="comment">/* if you're committing this, it better be the oldest one */</span>
<a name="l01810"></a>01810     assert(uop == p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#2186c80a8356e79436815b51fb01b978">uop</a>);
<a name="l01811"></a>01811 
<a name="l01812"></a>01812     <span class="comment">/* remove from head */</span>
<a name="l01813"></a>01813     <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] = p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a>;
<a name="l01814"></a>01814     <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a>)
<a name="l01815"></a>01815       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a>-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a> = NULL;
<a name="l01816"></a>01816 
<a name="l01817"></a>01817     <span class="comment">/* if only mapping, remove from tail as well */</span>
<a name="l01818"></a>01818     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] == p)
<a name="l01819"></a>01819       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] = NULL;
<a name="l01820"></a>01820 
<a name="l01821"></a>01821     <a class="code" href="classcore__oracle__t.html#6ed0bc2ff222597a87894e8fe6d53fc1">return_map_node</a>(p);
<a name="l01822"></a>01822   }
<a name="l01823"></a>01823 
<a name="l01824"></a>01824   <span class="comment">/* flags output */</span>
<a name="l01825"></a>01825   <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#a0d602d55a295c1e2b230d66190f5fc7">oflags</a> &amp;&amp; uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#a0d602d55a295c1e2b230d66190f5fc7">oflags</a> != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>)
<a name="l01826"></a>01826   {
<a name="l01827"></a>01827     p = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)];
<a name="l01828"></a>01828 
<a name="l01829"></a>01829     <span class="comment">/* if you're committing this, it better be in the mapping */</span>
<a name="l01830"></a>01830     assert(p);
<a name="l01831"></a>01831     <span class="comment">/* if you're committing this, it better be the oldest one */</span>
<a name="l01832"></a>01832     assert(uop == p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#2186c80a8356e79436815b51fb01b978">uop</a>);
<a name="l01833"></a>01833 
<a name="l01834"></a>01834     <span class="comment">/* remove from head */</span>
<a name="l01835"></a>01835     <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] = p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a>;
<a name="l01836"></a>01836     <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a>)
<a name="l01837"></a>01837       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a>-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a> = NULL;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839     <span class="comment">/* if only mapping, remove from tail as well */</span>
<a name="l01840"></a>01840     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] == p)
<a name="l01841"></a>01841       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] = NULL;
<a name="l01842"></a>01842 
<a name="l01843"></a>01843     <a class="code" href="classcore__oracle__t.html#6ed0bc2ff222597a87894e8fe6d53fc1">return_map_node</a>(p);
<a name="l01844"></a>01844   }
<a name="l01845"></a>01845 }
<a name="l01846"></a>01846 
<a name="l01847"></a>01847 <span class="comment">/* Cleans up dependency pointers between uop and CHILDREN. */</span>
<a name="l01848"></a><a class="code" href="classcore__oracle__t.html#999bfe83c41ad19d351d0cfc5cc1b16a">01848</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#999bfe83c41ad19d351d0cfc5cc1b16a">core_oracle_t::commit_dependencies</a>(<span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a> * <span class="keyword">const</span> uop)
<a name="l01849"></a>01849 {
<a name="l01850"></a>01850   <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * odep = uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a>;
<a name="l01851"></a>01851 
<a name="l01852"></a>01852   <span class="keywordflow">while</span>(odep)
<a name="l01853"></a>01853   {
<a name="l01854"></a>01854     <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * <a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a> = odep-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a>;
<a name="l01855"></a>01855 
<a name="l01856"></a>01856     <span class="comment">/* remove from child's idep vector */</span>
<a name="l01857"></a>01857     assert(odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a>-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[odep-&gt;<a class="code" href="structodep__t.html#a9047cb0f60d68673900ec2fd18b2263">op_num</a>] == uop);
<a name="l01858"></a>01858     odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a>-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[odep-&gt;<a class="code" href="structodep__t.html#a9047cb0f60d68673900ec2fd18b2263">op_num</a>] = NULL;
<a name="l01859"></a>01859 
<a name="l01860"></a>01860     odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a> = NULL;
<a name="l01861"></a>01861     odep-&gt;<a class="code" href="structodep__t.html#a9047cb0f60d68673900ec2fd18b2263">op_num</a> = -1;
<a name="l01862"></a>01862     <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#c76899d81828f8557930f9ab87f4938e">return_odep_link</a>(odep);
<a name="l01863"></a>01863 
<a name="l01864"></a>01864     odep = next;
<a name="l01865"></a>01865   }
<a name="l01866"></a>01866   uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a> = NULL;
<a name="l01867"></a>01867 }
<a name="l01868"></a>01868 
<a name="l01869"></a>01869 <span class="comment">/* remove the entry from the table */</span>
<a name="l01870"></a><a class="code" href="classcore__oracle__t.html#084f475b2682976f22fbad98943ac04f">01870</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#084f475b2682976f22fbad98943ac04f">core_oracle_t::commit_write_byte</a>(<span class="keyword">struct</span> <a class="code" href="structspec__byte__t.html">spec_byte_t</a> * <span class="keyword">const</span> p)
<a name="l01871"></a>01871 {
<a name="l01872"></a>01872   <span class="keyword">const</span> <span class="keywordtype">int</span> index = p-&gt;<a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a> &amp; <a class="code" href="zesto-oracle_8h.html#d2111e2165e4a519d36c3f3af50d557e">MEM_HASH_MASK</a>;
<a name="l01873"></a>01873   assert(<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#6e2657bc63a3f2e608a24a83ae33b9da">head</a> == p);
<a name="l01874"></a>01874 
<a name="l01875"></a>01875   <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a>)
<a name="l01876"></a>01876     p-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a>-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a> = NULL;
<a name="l01877"></a>01877   <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#6e2657bc63a3f2e608a24a83ae33b9da">head</a> = p-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a>;
<a name="l01878"></a>01878   <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a> == NULL)
<a name="l01879"></a>01879   {
<a name="l01880"></a>01880     <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a> = NULL;
<a name="l01881"></a>01881     assert(<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#6e2657bc63a3f2e608a24a83ae33b9da">head</a> == NULL);
<a name="l01882"></a>01882   }
<a name="l01883"></a>01883 
<a name="l01884"></a>01884   <a class="code" href="classcore__oracle__t.html#ecb0129c38db27a8d8424d8171025145">return_spec_mem_node</a>(p);
<a name="l01885"></a>01885 }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 
<a name="l01888"></a>01888 <span class="comment">/**************************************/</span>
<a name="l01889"></a>01889 <span class="comment">/* PROTECTED METHODS/MEMBER-FUNCTIONS */</span>
<a name="l01890"></a>01890 <span class="comment">/**************************************/</span>
<a name="l01891"></a>01891 
<a name="l01892"></a>01892 
<a name="l01893"></a>01893 <span class="comment">/* ORACLE DEPENDENCY MAP:</span>
<a name="l01894"></a>01894 <span class="comment">   The oracle keeps track of the equivalent of a register renaming</span>
<a name="l01895"></a>01895 <span class="comment">   table.  For each uop, the following functions add the uop to the</span>
<a name="l01896"></a>01896 <span class="comment">   output dependency list (odep list) of each of its input</span>
<a name="l01897"></a>01897 <span class="comment">   dependencies that the oracle still knows about (i.e., each parent</span>
<a name="l01898"></a>01898 <span class="comment">   uop that has not yet committed from the oracle), and the adds</span>
<a name="l01899"></a>01899 <span class="comment">   this uop into the mapping table as the most recent producer of</span>
<a name="l01900"></a>01900 <span class="comment">   the output register.  These pointers are used to implement the</span>
<a name="l01901"></a>01901 <span class="comment">   edges of the dataflow dependency graph which is used instead of</span>
<a name="l01902"></a>01902 <span class="comment">   explicit register renaming et al. to make the simulator a little</span>
<a name="l01903"></a>01903 <span class="comment">   bit faster. */</span>
<a name="l01904"></a>01904 
<a name="l01905"></a>01905 <span class="comment">/* adds uop as most recent producer of its output(s) */</span>
<a name="l01906"></a><a class="code" href="classcore__oracle__t.html#8a47de2d0fbb812311a55d1204cdc1c1">01906</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#8a47de2d0fbb812311a55d1204cdc1c1">core_oracle_t::install_mapping</a>(<span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a> * <span class="keyword">const</span> <a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a>)
<a name="l01907"></a>01907 {
<a name="l01908"></a>01908   <span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1map__node__t.html">map_node_t</a> * p = NULL;
<a name="l01909"></a>01909 
<a name="l01910"></a>01910   <span class="comment">/* regular register output */</span>
<a name="l01911"></a>01911   <span class="keywordflow">if</span>((uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a> != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>) &amp;&amp; (uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a> != <a class="code" href="machine_8h.html#7958b4dc7e6644b7c434becf7e2447f2">DGPR</a>(<a class="code" href="machine_8h.html#f09067c20691d3ae255145b7eee302c26c67316076cf9d98777ba6147f6b75f1">MD_REG_ZERO</a>)))
<a name="l01912"></a>01912   {
<a name="l01913"></a>01913     p = <a class="code" href="classcore__oracle__t.html#1d625a959241c89446eb56ea68c374cc">get_map_node</a>();
<a name="l01914"></a>01914     p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#2186c80a8356e79436815b51fb01b978">uop</a> = uop;
<a name="l01915"></a>01915 
<a name="l01916"></a>01916     <span class="comment">/* install in tail (newest) position */</span>
<a name="l01917"></a>01917     
<a name="l01918"></a>01918     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] == NULL) <span class="comment">/* if no in-flight producers */</span>
<a name="l01919"></a>01919     {
<a name="l01920"></a>01920       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] = p;
<a name="l01921"></a>01921       assert(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] == NULL);
<a name="l01922"></a>01922       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] = p;
<a name="l01923"></a>01923       <span class="comment">/* p's next/prev pointers are already cleared */</span>
<a name="l01924"></a>01924     }
<a name="l01925"></a>01925     <span class="keywordflow">else</span> <span class="comment">/* at least one other producer still in-flight */</span>
<a name="l01926"></a>01926     {
<a name="l01927"></a>01927       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a> = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>];
<a name="l01928"></a>01928       assert(p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>);
<a name="l01929"></a>01929       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a> = p;
<a name="l01930"></a>01930       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] = p;
<a name="l01931"></a>01931     }
<a name="l01932"></a>01932   }
<a name="l01933"></a>01933 
<a name="l01934"></a>01934   <span class="comment">/* flags output - same thing as above */</span>
<a name="l01935"></a>01935   <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#a0d602d55a295c1e2b230d66190f5fc7">oflags</a> &amp;&amp; uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#a0d602d55a295c1e2b230d66190f5fc7">oflags</a> != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>)
<a name="l01936"></a>01936   {
<a name="l01937"></a>01937     p = <a class="code" href="classcore__oracle__t.html#1d625a959241c89446eb56ea68c374cc">get_map_node</a>();
<a name="l01938"></a>01938     p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#2186c80a8356e79436815b51fb01b978">uop</a> = uop;
<a name="l01939"></a>01939     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] == NULL)
<a name="l01940"></a>01940     {
<a name="l01941"></a>01941       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] = p;
<a name="l01942"></a>01942       assert(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] == NULL);
<a name="l01943"></a>01943       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] = p;
<a name="l01944"></a>01944       <span class="comment">/* p's next/prev pointers are already cleared */</span>
<a name="l01945"></a>01945     }
<a name="l01946"></a>01946     <span class="keywordflow">else</span>
<a name="l01947"></a>01947     {
<a name="l01948"></a>01948       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a> = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)];
<a name="l01949"></a>01949       assert(p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>);
<a name="l01950"></a>01950       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a> = p;
<a name="l01951"></a>01951       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] = p;
<a name="l01952"></a>01952     }
<a name="l01953"></a>01953   }
<a name="l01954"></a>01954 }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956 <span class="comment">/* Called when a uop is undone (during pipe flush); removes uop from</span>
<a name="l01957"></a>01957 <span class="comment">   list of producers.  Difference is commit removes from the head,</span>
<a name="l01958"></a>01958 <span class="comment">   undo removes from the tail. */</span>
<a name="l01959"></a><a class="code" href="classcore__oracle__t.html#dc47fe294aeba52e39f9a11276522823">01959</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#dc47fe294aeba52e39f9a11276522823">core_oracle_t::undo_mapping</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a> * <span class="keyword">const</span> uop)
<a name="l01960"></a>01960 {
<a name="l01961"></a>01961   <span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1map__node__t.html">map_node_t</a> * p;
<a name="l01962"></a>01962   
<a name="l01963"></a>01963   <span class="comment">/* regular register output */</span>
<a name="l01964"></a>01964   <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a> != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a> &amp;&amp; uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a> != <a class="code" href="machine_8h.html#f09067c20691d3ae255145b7eee302c26c67316076cf9d98777ba6147f6b75f1">MD_REG_ZERO</a>)
<a name="l01965"></a>01965   {
<a name="l01966"></a>01966     p = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>];
<a name="l01967"></a>01967 
<a name="l01968"></a>01968     <span class="comment">/* XXX might not be in mapping if oldest inst? */</span>
<a name="l01969"></a>01969     <span class="keywordflow">if</span>(!p)
<a name="l01970"></a>01970       <span class="keywordflow">goto</span> flags;
<a name="l01971"></a>01971 
<a name="l01972"></a>01972     <span class="comment">/* if you're undoing this, it better be the youngest one */</span>
<a name="l01973"></a>01973     assert(uop == p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#2186c80a8356e79436815b51fb01b978">uop</a>);
<a name="l01974"></a>01974 
<a name="l01975"></a>01975     <span class="comment">/* remove from tail */</span>
<a name="l01976"></a>01976     <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] = p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>;
<a name="l01977"></a>01977     <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>)
<a name="l01978"></a>01978       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a> = NULL;
<a name="l01979"></a>01979 
<a name="l01980"></a>01980     <span class="comment">/* if only mapping, remove from head as well */</span>
<a name="l01981"></a>01981     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] == p)
<a name="l01982"></a>01982       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#6b25418271a661494d1ddd662cd1ecf8">odep_name</a>] = NULL;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984     <a class="code" href="classcore__oracle__t.html#6ed0bc2ff222597a87894e8fe6d53fc1">return_map_node</a>(p);
<a name="l01985"></a>01985   }
<a name="l01986"></a>01986 
<a name="l01987"></a>01987 flags:
<a name="l01988"></a>01988 
<a name="l01989"></a>01989   <span class="comment">/* flags output */</span>
<a name="l01990"></a>01990   <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#a0d602d55a295c1e2b230d66190f5fc7">oflags</a> &amp;&amp; uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#a0d602d55a295c1e2b230d66190f5fc7">oflags</a> != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>)
<a name="l01991"></a>01991   {
<a name="l01992"></a>01992     p = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)];
<a name="l01993"></a>01993 
<a name="l01994"></a>01994     <span class="comment">/* XXX might not be in mapping if oldest inst? */</span>
<a name="l01995"></a>01995     <span class="keywordflow">if</span>(!p)
<a name="l01996"></a>01996       <span class="keywordflow">return</span>;
<a name="l01997"></a>01997     <span class="comment">/* if you're undoing this, it better be the oldest one */</span>
<a name="l01998"></a>01998     assert(uop == p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#2186c80a8356e79436815b51fb01b978">uop</a>);
<a name="l01999"></a>01999 
<a name="l02000"></a>02000     <span class="comment">/* remove from tail */</span>
<a name="l02001"></a>02001     <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] = p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>;
<a name="l02002"></a>02002     <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>)
<a name="l02003"></a>02003       p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a>-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a> = NULL;
<a name="l02004"></a>02004 
<a name="l02005"></a>02005     <span class="comment">/* if only mapping, remove from head as well */</span>
<a name="l02006"></a>02006     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] == p)
<a name="l02007"></a>02007       <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.head[<a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>)] = NULL;
<a name="l02008"></a>02008 
<a name="l02009"></a>02009     <a class="code" href="classcore__oracle__t.html#6ed0bc2ff222597a87894e8fe6d53fc1">return_map_node</a>(p);
<a name="l02010"></a>02010   }
<a name="l02011"></a>02011 }
<a name="l02012"></a>02012 
<a name="l02013"></a>02013 <span class="comment">/* Mapping table node alloc/dealloc */</span>
<a name="l02014"></a><a class="code" href="classcore__oracle__t.html#1d625a959241c89446eb56ea68c374cc">02014</a> <span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1map__node__t.html">core_oracle_t::map_node_t</a> * <a class="code" href="classcore__oracle__t.html#1d625a959241c89446eb56ea68c374cc">core_oracle_t::get_map_node</a>(<span class="keywordtype">void</span>)
<a name="l02015"></a>02015 {
<a name="l02016"></a>02016   <span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1map__node__t.html">map_node_t</a> * p = NULL;
<a name="l02017"></a>02017   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#ed152af32c6f582d03ee8a88f2f399a3">map_free_pool</a>)
<a name="l02018"></a>02018   {
<a name="l02019"></a>02019     p = <a class="code" href="classcore__oracle__t.html#ed152af32c6f582d03ee8a88f2f399a3">map_free_pool</a>;
<a name="l02020"></a>02020     <a class="code" href="classcore__oracle__t.html#ed152af32c6f582d03ee8a88f2f399a3">map_free_pool</a> = p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a>;
<a name="l02021"></a>02021   }
<a name="l02022"></a>02022   <span class="keywordflow">else</span>
<a name="l02023"></a>02023   {
<a name="l02024"></a>02024     p = (<span class="keyword">struct </span><a class="code" href="structcore__oracle__t_1_1map__node__t.html">map_node_t</a>*) calloc(1,<span class="keyword">sizeof</span>(*p));
<a name="l02025"></a>02025     <span class="keywordflow">if</span>(!p)
<a name="l02026"></a>02026       <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"couldn't calloc a dependency node"</span>);
<a name="l02027"></a>02027   }
<a name="l02028"></a>02028   assert(p);
<a name="l02029"></a>02029   p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a> = NULL;
<a name="l02030"></a>02030   <span class="comment">/* other fields were cleared when p was "return"ed (see below) */</span>
<a name="l02031"></a>02031   <a class="code" href="classcore__oracle__t.html#2387b57848be51fa71ac1bd00797b4f9">map_free_pool_debt</a>++;
<a name="l02032"></a>02032   <span class="keywordflow">return</span> p;
<a name="l02033"></a>02033 }
<a name="l02034"></a>02034 
<a name="l02035"></a><a class="code" href="classcore__oracle__t.html#6ed0bc2ff222597a87894e8fe6d53fc1">02035</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#6ed0bc2ff222597a87894e8fe6d53fc1">core_oracle_t::return_map_node</a>(<span class="keyword">struct</span> <a class="code" href="structcore__oracle__t_1_1map__node__t.html">map_node_t</a> * <span class="keyword">const</span> p)
<a name="l02036"></a>02036 {
<a name="l02037"></a>02037   p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#a8314e51205c7e6f7e74601eb21625f2">next</a> = <a class="code" href="classcore__oracle__t.html#ed152af32c6f582d03ee8a88f2f399a3">map_free_pool</a>;
<a name="l02038"></a>02038   <a class="code" href="classcore__oracle__t.html#ed152af32c6f582d03ee8a88f2f399a3">map_free_pool</a> = p;
<a name="l02039"></a>02039   p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#2186c80a8356e79436815b51fb01b978">uop</a> = NULL;
<a name="l02040"></a>02040   p-&gt;<a class="code" href="structcore__oracle__t_1_1map__node__t.html#4f925fd747af3b8eaf5e252557e57a40">prev</a> = NULL;
<a name="l02041"></a>02041   <a class="code" href="classcore__oracle__t.html#2387b57848be51fa71ac1bd00797b4f9">map_free_pool_debt</a>--;
<a name="l02042"></a>02042   <span class="comment">/* p-&gt;next used for free list, will be cleared on "get" */</span>
<a name="l02043"></a>02043 }
<a name="l02044"></a>02044 
<a name="l02045"></a>02045 
<a name="l02046"></a>02046 <span class="comment">/* Installs pointers back to the uop's parents, and installs odep</span>
<a name="l02047"></a>02047 <span class="comment">   pointers from the parents forward to this uop.  (Build uop's list</span>
<a name="l02048"></a>02048 <span class="comment">   of parents, add uop to each parent's list of children.) */</span>
<a name="l02049"></a><a class="code" href="classcore__oracle__t.html#deeae95a29f95000a81b20fb895a2e64">02049</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#deeae95a29f95000a81b20fb895a2e64">core_oracle_t::install_dependencies</a>(<span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a> * <span class="keyword">const</span> uop)
<a name="l02050"></a>02050 {
<a name="l02051"></a>02051   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="zesto-structs_8h.html#dfffbd8f2596b46b6777c263be9e5a23">MAX_IDEPS</a>;i++)
<a name="l02052"></a>02052   {
<a name="l02053"></a>02053     <span class="comment">/* get pointers to parent uops */</span>
<a name="l02054"></a>02054     <span class="keywordtype">int</span> reg_name = uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[i];
<a name="l02055"></a>02055     <span class="keywordflow">if</span>(reg_name != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a> &amp;&amp; reg_name != <a class="code" href="machine_8h.html#f09067c20691d3ae255145b7eee302c26c67316076cf9d98777ba6147f6b75f1">MD_REG_ZERO</a>)
<a name="l02056"></a>02056     {
<a name="l02057"></a>02057       <span class="comment">/* my parent is the most recent producer (dep_map.tail) of my operand */</span>
<a name="l02058"></a>02058       <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[reg_name])
<a name="l02059"></a>02059       {
<a name="l02060"></a>02060         uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[i] = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[reg_name]-&gt;uop;
<a name="l02061"></a>02061         assert(uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[i]-&gt;<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a>-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#73a37cb3f710fed5c590d5185dd45531">seq</a> &lt;= uop-&gt;<a class="code" href="structuop__t.html#5752c48ff1454c5c470509db2fa46b7a">Mop</a>-&gt;<a class="code" href="structMop__t.html#f445a1796fbcfb01bb7094b956b4361a">oracle</a>.<a class="code" href="structMop__t.html#73a37cb3f710fed5c590d5185dd45531">seq</a>);
<a name="l02062"></a>02062       }
<a name="l02063"></a>02063 
<a name="l02064"></a>02064       <span class="comment">/* install pointers from parent to this uop (add to parent's odep list) */</span>
<a name="l02065"></a>02065       <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[i])
<a name="l02066"></a>02066       {
<a name="l02067"></a>02067         <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * odep = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#c584461c992898648b8e0f8cf5931dfd">get_odep_link</a>();
<a name="l02068"></a>02068         odep-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a> = uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[i]-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a>;
<a name="l02069"></a>02069         uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[i]-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a> = odep;
<a name="l02070"></a>02070         odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a> = uop;
<a name="l02071"></a>02071         odep-&gt;<a class="code" href="structodep__t.html#1b87d9a262d821eb09ac04a1007a7505">aflags</a> = <span class="keyword">false</span>;
<a name="l02072"></a>02072         odep-&gt;<a class="code" href="structodep__t.html#a9047cb0f60d68673900ec2fd18b2263">op_num</a> = i;
<a name="l02073"></a>02073       }
<a name="l02074"></a>02074       <span class="comment">/* else parent already committed */</span>
<a name="l02075"></a>02075     }
<a name="l02076"></a>02076   }
<a name="l02077"></a>02077 
<a name="l02078"></a>02078   <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#dd3e91d0ee510873faf7b091da66ff14">iflags</a> &amp;&amp; uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#dd3e91d0ee510873faf7b091da66ff14">iflags</a> != <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>)
<a name="l02079"></a>02079   {
<a name="l02080"></a>02080     <span class="comment">/* get pointers to parent uop */</span>
<a name="l02081"></a>02081     <span class="keywordtype">int</span> reg_name = <a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>);
<a name="l02082"></a>02082     <span class="keywordtype">int</span> idx = MAX_IDEPS-1; <span class="comment">/* always install AFLAGS idep in last entry */</span>
<a name="l02083"></a>02083     assert(uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[idx] == <a class="code" href="machine_8h.html#7e1f80c2888e5e4d779d8571e66ae50d">DNA</a>);
<a name="l02084"></a>02084     uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#802d55251c30f553d17da8dc7502ad62">idep_name</a>[idx] = <a class="code" href="machine_8h.html#d80e74580200731f87e13556d877b32f">DCREG</a>(<a class="code" href="machine_8h.html#f078ffebd93269a86355d7e41c6fd6f1c2fafc305b75d71956ef7420b58be20e">MD_REG_AFLAGS</a>);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086     <span class="comment">/* my parent is the most recent producer (dep_map.tail) of my operand */</span>
<a name="l02087"></a>02087     <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[reg_name])
<a name="l02088"></a>02088       uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[idx] = <a class="code" href="classcore__oracle__t.html#dff628c0529f5ffc29965d2699adf61a">dep_map</a>.tail[reg_name]-&gt;uop;
<a name="l02089"></a>02089 
<a name="l02090"></a>02090     <span class="comment">/* install pointers from parent to this uop (add to parent's odep list) */</span>
<a name="l02091"></a>02091     <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[idx])
<a name="l02092"></a>02092     {
<a name="l02093"></a>02093       <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * odep = <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#c584461c992898648b8e0f8cf5931dfd">get_odep_link</a>();
<a name="l02094"></a>02094       odep-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a> = uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[idx]-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a>;
<a name="l02095"></a>02095       uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[idx]-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a> = odep;
<a name="l02096"></a>02096       odep-&gt;<a class="code" href="structodep__t.html#1b87d9a262d821eb09ac04a1007a7505">aflags</a> = <span class="keyword">true</span>;
<a name="l02097"></a>02097       odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a> = uop;
<a name="l02098"></a>02098       odep-&gt;<a class="code" href="structodep__t.html#a9047cb0f60d68673900ec2fd18b2263">op_num</a> = idx;
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100     <span class="comment">/* else parent already committed */</span>
<a name="l02101"></a>02101   }
<a name="l02102"></a>02102 }
<a name="l02103"></a>02103 
<a name="l02104"></a>02104 <span class="comment">/* Cleans up dependency pointers between uop and PARENTS. */</span>
<a name="l02105"></a><a class="code" href="classcore__oracle__t.html#56379122fc2f63fc767cdf82e346b98b">02105</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#56379122fc2f63fc767cdf82e346b98b">core_oracle_t::undo_dependencies</a>(<span class="keyword">struct</span> <a class="code" href="structuop__t.html">uop_t</a> * <span class="keyword">const</span> <a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a>)
<a name="l02106"></a>02106 {
<a name="l02107"></a>02107   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="zesto-structs_8h.html#dfffbd8f2596b46b6777c263be9e5a23">MAX_IDEPS</a>;i++)
<a name="l02108"></a>02108   {
<a name="l02109"></a>02109     <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * parent = uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[i];
<a name="l02110"></a>02110     <span class="keywordflow">if</span>(parent)
<a name="l02111"></a>02111     {
<a name="l02112"></a>02112       <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * odep = NULL;
<a name="l02113"></a>02113       <span class="keyword">struct </span><a class="code" href="structodep__t.html">odep_t</a> * odep_prev = NULL;
<a name="l02114"></a>02114 
<a name="l02115"></a>02115       odep = parent-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a>;
<a name="l02116"></a>02116       <span class="keywordflow">while</span>(odep)
<a name="l02117"></a>02117       {
<a name="l02118"></a>02118         <span class="keywordflow">if</span>((odep-&gt;<a class="code" href="structodep__t.html#4870c3718dfdc8a6ac81f2455e8e7b60">uop</a> == uop) &amp;&amp; (odep-&gt;<a class="code" href="structodep__t.html#a9047cb0f60d68673900ec2fd18b2263">op_num</a> == i))
<a name="l02119"></a>02119         {
<a name="l02120"></a>02120           <span class="keywordflow">if</span>(odep_prev)
<a name="l02121"></a>02121             odep_prev-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a> = odep-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a>;
<a name="l02122"></a>02122           <span class="keywordflow">else</span>
<a name="l02123"></a>02123             parent-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#26d4b1db6fdef492b6f61b9624455f7c">odep_uop</a> = odep-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a>;
<a name="l02124"></a>02124           <a class="code" href="classcore__oracle__t.html#32fd14747d2d54dc5e0bc2ba7d118364">core</a>-&gt;<a class="code" href="classcore__t.html#c76899d81828f8557930f9ab87f4938e">return_odep_link</a>(odep);
<a name="l02125"></a>02125           <span class="keywordflow">break</span>;
<a name="l02126"></a>02126         }
<a name="l02127"></a>02127         odep_prev = odep;
<a name="l02128"></a>02128         odep = odep-&gt;<a class="code" href="structodep__t.html#a696a50e030a95db3b98795875dcd908">next</a>;
<a name="l02129"></a>02129       }
<a name="l02130"></a>02130       assert(odep); <span class="comment">/* if I point back at a parent, the parent should point fwd to me. */</span>
<a name="l02131"></a>02131     }
<a name="l02132"></a>02132     uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#e941cb97551b1b6f4205334d2c23fbc4">idep_uop</a>[i] = NULL; <span class="comment">/* remove my back pointer */</span>
<a name="l02133"></a>02133   }
<a name="l02134"></a>02134 
<a name="l02135"></a>02135   <span class="comment">/* don't need to special-case AFLAGS since those were added to the idep list */</span>
<a name="l02136"></a>02136 }
<a name="l02137"></a>02137 
<a name="l02138"></a>02138 
<a name="l02139"></a>02139 <span class="comment">/* Code for pre-commit memory handling */</span>
<a name="l02140"></a>02140 <span class="comment">/* Stores get inserted into the hash table, and loads check the</span>
<a name="l02141"></a>02141 <span class="comment">   hash table before retrieving a value from memory.  This is very</span>
<a name="l02142"></a>02142 <span class="comment">   similar to the speculative memory handling approach used in MASE.</span>
<a name="l02143"></a>02143 <span class="comment">   Stores do not update the simulated memory (mem_t) until they</span>
<a name="l02144"></a>02144 <span class="comment">   actually commit.  All speculative updates get stored in a</span>
<a name="l02145"></a>02145 <span class="comment">   separate table, and loads have to check this first before</span>
<a name="l02146"></a>02146 <span class="comment">   retrieving values from main memory.  Note that almost everything</span>
<a name="l02147"></a>02147 <span class="comment">   here is performed on a byte-by-byte basis due to the lack of</span>
<a name="l02148"></a>02148 <span class="comment">   alignment restrictions in x86. */</span>
<a name="l02149"></a>02149 
<a name="l02150"></a><a class="code" href="classcore__oracle__t.html#b4d62e47b0d6399f7fc7738eb0864f17">02150</a> <span class="keyword">struct </span><a class="code" href="structspec__byte__t.html">spec_byte_t</a> * <a class="code" href="classcore__oracle__t.html#b4d62e47b0d6399f7fc7738eb0864f17">core_oracle_t::get_spec_mem_node</a>(<span class="keywordtype">void</span>)
<a name="l02151"></a>02151 {
<a name="l02152"></a>02152   <span class="keyword">struct </span><a class="code" href="structspec__byte__t.html">spec_byte_t</a> * p;
<a name="l02153"></a>02153   <span class="keywordflow">if</span>(<a class="code" href="classcore__oracle__t.html#40543fe5b0ca253b04d69a6f6e69ca10">spec_mem_free_pool</a>)
<a name="l02154"></a>02154   {
<a name="l02155"></a>02155     p = <a class="code" href="classcore__oracle__t.html#40543fe5b0ca253b04d69a6f6e69ca10">spec_mem_free_pool</a>;
<a name="l02156"></a>02156     <a class="code" href="classcore__oracle__t.html#40543fe5b0ca253b04d69a6f6e69ca10">spec_mem_free_pool</a> = p-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a>;
<a name="l02157"></a>02157     p-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a> = NULL;
<a name="l02158"></a>02158     <span class="comment">/* other fields were cleared when returned to free pool */</span>
<a name="l02159"></a>02159     <span class="keywordflow">return</span> p;
<a name="l02160"></a>02160   }
<a name="l02161"></a>02161   <span class="keywordflow">else</span>
<a name="l02162"></a>02162   {
<a name="l02163"></a>02163     p = (<span class="keyword">struct </span><a class="code" href="structspec__byte__t.html">spec_byte_t</a>*) calloc(1,<span class="keyword">sizeof</span>(*p));
<a name="l02164"></a>02164     <span class="keywordflow">if</span>(!p)
<a name="l02165"></a>02165       <a class="code" href="misc_8h.html#677da14e8c4326bde43622f233f1ead3">fatal</a>(<span class="stringliteral">"couldn't malloc spec_mem node"</span>);
<a name="l02166"></a>02166     <span class="keywordflow">return</span> p;
<a name="l02167"></a>02167   }
<a name="l02168"></a>02168 }
<a name="l02169"></a>02169 
<a name="l02170"></a><a class="code" href="classcore__oracle__t.html#ecb0129c38db27a8d8424d8171025145">02170</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#ecb0129c38db27a8d8424d8171025145">core_oracle_t::return_spec_mem_node</a>(<span class="keyword">struct</span> <a class="code" href="structspec__byte__t.html">spec_byte_t</a> * <span class="keyword">const</span> p)
<a name="l02171"></a>02171 {
<a name="l02172"></a>02172   assert(p);
<a name="l02173"></a>02173   p-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a> = <a class="code" href="classcore__oracle__t.html#40543fe5b0ca253b04d69a6f6e69ca10">spec_mem_free_pool</a>;
<a name="l02174"></a>02174   <a class="code" href="classcore__oracle__t.html#40543fe5b0ca253b04d69a6f6e69ca10">spec_mem_free_pool</a> = p;
<a name="l02175"></a>02175   p-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a> = NULL;
<a name="l02176"></a>02176   p-&gt;<a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a> = 0;
<a name="l02177"></a>02177   p-&gt;<a class="code" href="structspec__byte__t.html#529d3138d7fe5292c57c89dea4c355f7">val</a> = 0;
<a name="l02178"></a>02178 }
<a name="l02179"></a>02179 
<a name="l02180"></a>02180 <span class="comment">/* similar to commit_write_byte, but remove the tail entry</span>
<a name="l02181"></a>02181 <span class="comment">   instead (used on a uop-flush/squash). */</span>
<a name="l02182"></a><a class="code" href="classcore__oracle__t.html#e14bba8a8cf6ecfc9a52845e3c1760aa">02182</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#e14bba8a8cf6ecfc9a52845e3c1760aa">core_oracle_t::squash_write_byte</a>(<span class="keyword">struct</span> <a class="code" href="structspec__byte__t.html">spec_byte_t</a> * <span class="keyword">const</span> p)
<a name="l02183"></a>02183 {
<a name="l02184"></a>02184   <span class="keyword">const</span> <span class="keywordtype">int</span> index = p-&gt;<a class="code" href="structspec__byte__t.html#1e4c15a23513fc4f753a0154527c84c8">addr</a> &amp; <a class="code" href="zesto-oracle_8h.html#d2111e2165e4a519d36c3f3af50d557e">MEM_HASH_MASK</a>;
<a name="l02185"></a>02185   assert(<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a> == p);
<a name="l02186"></a>02186 
<a name="l02187"></a>02187   <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a>)
<a name="l02188"></a>02188     p-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a>-&gt;<a class="code" href="structspec__byte__t.html#4ace439424a3531bff054f699d865679">next</a> = NULL;
<a name="l02189"></a>02189   <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a> = p-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a>;
<a name="l02190"></a>02190   <span class="keywordflow">if</span>(p-&gt;<a class="code" href="structspec__byte__t.html#65843e255c19ee4684c0273cc1d65443">prev</a> == NULL)
<a name="l02191"></a>02191   {
<a name="l02192"></a>02192     <a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#6e2657bc63a3f2e608a24a83ae33b9da">head</a> = NULL;
<a name="l02193"></a>02193     assert(<a class="code" href="classcore__oracle__t.html#46aeda5c32e396e6f8adfc6cb3c7537c">spec_mem_map</a>.<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#f2b18bc5ab0ad487ac700714f2ef6f32">hash</a>[index].<a class="code" href="structcore__oracle__t_1_1spec__mem__t.html#202bd357c75052e5533179bfe0f69565">tail</a> == NULL);
<a name="l02194"></a>02194   }
<a name="l02195"></a>02195 
<a name="l02196"></a>02196   <a class="code" href="classcore__oracle__t.html#ecb0129c38db27a8d8424d8171025145">return_spec_mem_node</a>(p);
<a name="l02197"></a>02197 }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 <span class="comment">/* if a Mop is partially executed in oracle-exec and then</span>
<a name="l02200"></a>02200 <span class="comment">   aborts (likely due to it being on the wrong path and</span>
<a name="l02201"></a>02201 <span class="comment">   containing bogus ops), speculative writes from the</span>
<a name="l02202"></a>02202 <span class="comment">   partially executed uops need to be cleaned up. */</span>
<a name="l02203"></a><a class="code" href="classcore__oracle__t.html#ba04cbb4ec9ba6ffb03455a2f5c5da32">02203</a> <span class="keywordtype">void</span> <a class="code" href="classcore__oracle__t.html#ba04cbb4ec9ba6ffb03455a2f5c5da32">core_oracle_t::cleanup_aborted_mop</a>(<span class="keyword">struct</span> <a class="code" href="structMop__t.html">Mop_t</a> * <span class="keyword">const</span> Mop)
<a name="l02204"></a>02204 {
<a name="l02205"></a>02205   <span class="keywordtype">int</span> i = Mop-&gt;<a class="code" href="structMop__t.html#28058bfb31dd9263c008929f3c4f7f08">decode</a>.<a class="code" href="structMop__t.html#7718f3555efe88921d86e395fc3fbc74">flow_length</a> - 1;
<a name="l02206"></a>02206   <span class="keywordflow">while</span>(i&gt;=0)
<a name="l02207"></a>02207   {
<a name="l02208"></a>02208     <span class="keyword">struct </span><a class="code" href="structuop__t.html">uop_t</a> * uop = &amp;Mop-&gt;<a class="code" href="structMop__t.html#b435acfedb392843bc50658c7650cbdd">uop</a>[i];
<a name="l02209"></a>02209 
<a name="l02210"></a>02210     <span class="keywordflow">if</span>(!uop-&gt;<a class="code" href="structuop__t.html#c42cc8544fd53bb8513c3aabef62c13b">decode</a>.<a class="code" href="structuop__t.html#b1051f89245a2a2d5ea721ab6b4c9870">is_imm</a>)
<a name="l02211"></a>02211     {
<a name="l02212"></a>02212       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;12;j++)
<a name="l02213"></a>02213       {
<a name="l02214"></a>02214         <span class="keywordflow">if</span>(uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#faa3ffb8ea233ffb14b5a9ee855805ec">spec_mem</a>[j] == NULL)
<a name="l02215"></a>02215           <span class="keywordflow">break</span>;
<a name="l02216"></a>02216         <span class="comment">//squash_write_byte(uop-&gt;oracle.spec_mem[j]);</span>
<a name="l02217"></a>02217         uop-&gt;<a class="code" href="structuop__t.html#8e4a2982dc7dcc8eb4f22d8d16a9ab1b">oracle</a>.<a class="code" href="structuop__t.html#faa3ffb8ea233ffb14b5a9ee855805ec">spec_mem</a>[j] = NULL;
<a name="l02218"></a>02218       }
<a name="l02219"></a>02219     }
<a name="l02220"></a>02220     i--;
<a name="l02221"></a>02221   }
<a name="l02222"></a>02222 }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224 
<a name="l02225"></a>02225 
<a name="l02226"></a>02226 
<a name="l02227"></a>02227 
<a name="l02228"></a>02228 <span class="comment">/* fetch an instruction */</span>
<a name="l02229"></a>02229 <span class="keywordtype">void</span>
<a name="l02230"></a><a class="code" href="zesto-oracle_8h.html#c9b36de1d166dbea41697884bd42aa7e">02230</a> <a class="code" href="zesto-oracle_8cpp.html#c9b36de1d166dbea41697884bd42aa7e">md_fetch_inst</a>(<a class="code" href="structmd__inst__t.html">md_inst_t</a> *inst, <span class="keyword">struct</span> <a class="code" href="structmem__t.html">mem_t</a> *mem, <span class="keyword">const</span> <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> pc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> core_id)
<a name="l02231"></a>02231 {
<a name="l02232"></a>02232   <span class="keywordtype">unsigned</span>  <span class="keywordtype">int</span> i,len,memops;
<a name="l02233"></a>02233 <span class="preprocessor">#ifdef USE_PIN_TRACES</span>
<a name="l02234"></a>02234 <span class="preprocessor"></span>
<a name="l02235"></a>02235   fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%d "</span>,&amp;len);
<a name="l02236"></a>02236   fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%d "</span>,&amp;memops);
<a name="l02237"></a>02237   <span class="comment">//fprintf(stdout,"Store Next PC %llx ", store_nextPC);</span>
<a name="l02238"></a>02238 
<a name="l02239"></a>02239   inst-&gt;<a class="code" href="structmd__inst__t.html#95beb627225d1c1eb84837df86c53e28">vaddr</a>=pc;<span class="comment">//store_nextPC[core_id];       </span>
<a name="l02240"></a>02240   inst-&gt;<a class="code" href="structmd__inst__t.html#e05730869a364bf93b640941f78113ab">paddr</a>=pc;<span class="comment">//store_nextPC[core_id];</span>
<a name="l02241"></a>02241   inst-&gt;<a class="code" href="structmd__inst__t.html#d7a24ed96b5a93217bf1cbd39c2bb859">qemu_len</a>=len;
<a name="l02242"></a>02242   <span class="comment">//fprintf(stdout,"\n[%lld][Core%d]Trace DequeuedPC: 0x%llx   ",sim_cycle,core_id,inst-&gt;vaddr);</span>
<a name="l02243"></a>02243   <span class="keywordflow">for</span> (i = 0; i &lt; len; i++) 
<a name="l02244"></a>02244   {
<a name="l02245"></a>02245         <span class="keywordflow">if</span>(feof(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace))
<a name="l02246"></a>02246                 longjmp(<a class="code" href="manifold__fullsim_8cc.html#84727c65b24d2e32fd3d4a7af53aa15a">sim_exit_buf</a>, <span class="comment">/* exitcode + fudge */</span>0 + 1);
<a name="l02247"></a>02247         fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%x "</span>,&amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#cd464d5bc7356337ebd2ce89f968991c">code</a>[i]));
<a name="l02248"></a>02248         <span class="comment">//fprintf(stdout," %x", inst-&gt;code[i]);</span>
<a name="l02249"></a>02249   }
<a name="l02250"></a>02250 
<a name="l02251"></a>02251   inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0]=0;
<a name="l02252"></a>02252   inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[1]=0;
<a name="l02253"></a>02253   inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0]=0;
<a name="l02254"></a>02254   inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[1]=0;
<a name="l02255"></a>02255   <span class="keywordflow">if</span>(memops)
<a name="l02256"></a>02256   {
<a name="l02257"></a>02257         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ch;
<a name="l02258"></a>02258         inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>=memops;
<a name="l02259"></a>02259         fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">" %llx "</span>,&amp;ch);
<a name="l02260"></a>02260         <span class="comment">//fprintf(stdout,"\nTrace Another memory op out of %d %llx ", memops,ch);</span>
<a name="l02261"></a>02261 
<a name="l02262"></a>02262         <span class="keywordflow">if</span>(ch!=0x00 || ch!=0x01)
<a name="l02263"></a>02263                 <a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id]=ch;
<a name="l02264"></a>02264         <span class="keywordflow">while</span>(<span class="keyword">true</span>)
<a name="l02265"></a>02265         {
<a name="l02266"></a>02266                 <span class="keywordflow">if</span>(feof(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace))
<a name="l02267"></a>02267                         longjmp(<a class="code" href="manifold__fullsim_8cc.html#84727c65b24d2e32fd3d4a7af53aa15a">sim_exit_buf</a>, <span class="comment">/* exitcode + fudge */</span>0 + 1);
<a name="l02268"></a>02268                 <span class="keywordflow">if</span>(ch==0)
<a name="l02269"></a>02269                 {
<a name="l02270"></a>02270                         <span class="keywordflow">if</span>(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0]==0)
<a name="l02271"></a>02271                         {
<a name="l02272"></a>02272                                 fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%llx %d"</span>,&amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0]), &amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#aa559aaa21d731cda775b553c08c9a2f">ld_size</a>[0]) );
<a name="l02273"></a>02273                                 <span class="comment">//fprintf(stdout,"\nTrace Read First %llx Size %d ",inst-&gt;mem_ops.mem_vaddr_ld[0], inst-&gt;mem_ops.ld_size[0]);</span>
<a name="l02274"></a>02274                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#ebe595b6542eff03da2b3f92bb966c07">mem_paddr_ld</a>[0]= inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0];
<a name="l02275"></a>02275                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4e0149c5502186cc978fc5412d60b087">ld_dequeued</a>[0]=<span class="keyword">false</span>;
<a name="l02276"></a>02276                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++;
<a name="l02277"></a>02277                         }
<a name="l02278"></a>02278                         <span class="keywordflow">else</span>
<a name="l02279"></a>02279                         {
<a name="l02280"></a>02280                                 fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%llx %d"</span>,&amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[1]), &amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#aa559aaa21d731cda775b553c08c9a2f">ld_size</a>[1]) );
<a name="l02281"></a>02281                                 <span class="comment">//fprintf(stdout,"\nTrace Read Second %llx Size %d ",inst-&gt;mem_ops.mem_vaddr_ld[1], inst-&gt;mem_ops.ld_size[1] );</span>
<a name="l02282"></a>02282                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#ebe595b6542eff03da2b3f92bb966c07">mem_paddr_ld</a>[1]= inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[1];
<a name="l02283"></a>02283                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4e0149c5502186cc978fc5412d60b087">ld_dequeued</a>[1]=<span class="keyword">false</span>;
<a name="l02284"></a>02284                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++;
<a name="l02285"></a>02285                         }
<a name="l02286"></a>02286                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch==1)
<a name="l02287"></a>02287                       {
<a name="l02288"></a>02288                         <span class="keywordflow">if</span>(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0]==0)
<a name="l02289"></a>02289                         {
<a name="l02290"></a>02290                                 fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%llx %d"</span>,&amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0]), &amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#66a55324ea75d2ce5951a6dbfe43b665">str_size</a>[0]) );
<a name="l02291"></a>02291                                 <span class="comment">//fprintf(stdout,"\nTrace Write First %llx Size %d ",inst-&gt;mem_ops.mem_vaddr_str[0], inst-&gt;mem_ops.str_size[0]);</span>
<a name="l02292"></a>02292                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#84f77c012a6cdd392f645db63dd3b9cb">mem_paddr_str</a>[0]= inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0];
<a name="l02293"></a>02293                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4158b3e42772696b3f6569c7fc2b1401">str_dequeued</a>[0]=<span class="keyword">false</span>;
<a name="l02294"></a>02294                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++; 
<a name="l02295"></a>02295                         }
<a name="l02296"></a>02296                         <span class="keywordflow">else</span>
<a name="l02297"></a>02297                         {
<a name="l02298"></a>02298                                 fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%llx %d"</span>,&amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[1]), &amp;(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#66a55324ea75d2ce5951a6dbfe43b665">str_size</a>[1]) );
<a name="l02299"></a>02299                                 <span class="comment">//fprintf(stdout,"\nTrace Write Second %llx Size %d ",inst-&gt;mem_ops.mem_vaddr_str[1], inst-&gt;mem_ops.str_size[1]);</span>
<a name="l02300"></a>02300                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#84f77c012a6cdd392f645db63dd3b9cb">mem_paddr_str</a>[1]= inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[1];
<a name="l02301"></a>02301                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4158b3e42772696b3f6569c7fc2b1401">str_dequeued</a>[1]=<span class="keyword">false</span>;
<a name="l02302"></a>02302                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++;
<a name="l02303"></a>02303                         }
<a name="l02304"></a>02304                       }
<a name="l02305"></a>02305                       <span class="keywordflow">else</span>
<a name="l02306"></a>02306                         {
<a name="l02307"></a>02307                                 <span class="comment">//fprintf(stdout, "\nTrace Encountered New instruction");</span>
<a name="l02308"></a>02308                                 <a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id]=ch;
<a name="l02309"></a>02309                                 <a class="code" href="sim-zesto_8cpp.html#38a36f4cd3940833135cd0c497f726f4">use_stored_nextPC</a>[core_id]=<span class="keyword">true</span>;
<a name="l02310"></a>02310                                 <span class="keywordflow">break</span>;
<a name="l02311"></a>02311                         }
<a name="l02312"></a>02312                 fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">" %llx "</span>,&amp;ch);
<a name="l02313"></a>02313                 <span class="comment">//fprintf(stdout,"\nTrace Another memory op out of %d %llx ", memops,ch);</span>
<a name="l02314"></a>02314         }
<a name="l02315"></a>02315   }
<a name="l02316"></a>02316   <span class="keywordflow">else</span>
<a name="l02317"></a>02317         <a class="code" href="sim-zesto_8cpp.html#38a36f4cd3940833135cd0c497f726f4">use_stored_nextPC</a>[core_id]=<span class="keyword">false</span>;
<a name="l02318"></a>02318 
<a name="l02319"></a>02319 <span class="preprocessor">#else</span>
<a name="l02320"></a>02320 <span class="preprocessor"></span>  <span class="comment">//Queue *q_ptr = cores[core_id]-&gt;current_thread-&gt;q;</span>
<a name="l02321"></a>02321   
<a name="l02322"></a>02322   Queue *q_ptr = q[core_id]; 
<a name="l02323"></a>02323 refetch_instr:
<a name="l02324"></a>02324 
<a name="l02325"></a>02325   <span class="keywordflow">if</span>(!q_ptr-&gt;empty())
<a name="l02326"></a>02326   {
<a name="l02327"></a>02327         <span class="keywordflow">if</span> (q_ptr-&gt;front().type == QueueItem::INST)
<a name="l02328"></a>02328         {
<a name="l02329"></a>02329                 <span class="comment">//fprintf(stdout,"\n[%lld]Oracle.start DequeuedPC: 0x%llx   ",sim_cycle,q_ptr-&gt;front().data.inst.vaddr);</span>
<a name="l02330"></a>02330                 <span class="keywordflow">for</span> (i = 0; i &lt; q_ptr-&gt;front().data.inst.len; i++) 
<a name="l02331"></a>02331                 {
<a name="l02332"></a>02332                         inst-&gt;<a class="code" href="structmd__inst__t.html#cd464d5bc7356337ebd2ce89f968991c">code</a>[i] = q_ptr-&gt;front().data.inst.bytes[i]; 
<a name="l02333"></a>02333                         <span class="comment">//fprintf(stdout,"%x ", inst-&gt;code[i]);</span>
<a name="l02334"></a>02334                 }
<a name="l02335"></a>02335                 <span class="comment">//fprintf(stdout," Length %d",q_ptr-&gt;front().data.inst.len );</span>
<a name="l02336"></a>02336                 inst-&gt;<a class="code" href="structmd__inst__t.html#95beb627225d1c1eb84837df86c53e28">vaddr</a>=q_ptr-&gt;front().data.inst.vaddr;
<a name="l02337"></a>02337                 inst-&gt;<a class="code" href="structmd__inst__t.html#e05730869a364bf93b640941f78113ab">paddr</a>=q_ptr-&gt;front().data.inst.paddr;
<a name="l02338"></a>02338                 inst-&gt;<a class="code" href="structmd__inst__t.html#d7a24ed96b5a93217bf1cbd39c2bb859">qemu_len</a>=q_ptr-&gt;front().data.inst.len;
<a name="l02339"></a>02339                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0]=0;
<a name="l02340"></a>02340                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[1]=0;
<a name="l02341"></a>02341                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0]=0;
<a name="l02342"></a>02342                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[1]=0;
<a name="l02343"></a>02343                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>=0;
<a name="l02344"></a>02344         }<span class="keywordflow">else</span> <span class="keywordflow">if</span> (q_ptr-&gt;front().type == QueueItem::INTR)
<a name="l02345"></a>02345         {
<a name="l02346"></a>02346           q_ptr-&gt;pop();
<a name="l02347"></a>02347           <span class="keywordflow">goto</span> refetch_instr;
<a name="l02348"></a>02348         }<span class="keywordflow">else</span>
<a name="l02349"></a>02349                 fprintf(stdout,<span class="stringliteral">"\nMemory Op found where looking for an instruction"</span>);
<a name="l02350"></a>02350         q_ptr-&gt;pop();
<a name="l02351"></a>02351         <span class="keywordflow">if</span>(q_ptr-&gt;empty())
<a name="l02352"></a>02352         {
<a name="l02353"></a>02353                 <span class="comment">//fprintf(stdout,"\nRunning QSIM in md_fetch_pc Queue empty after instruction dequeued ");</span>
<a name="l02354"></a>02354                 cd-&gt;run(core_id, 500);
<a name="l02355"></a>02355         }
<a name="l02356"></a>02356         <span class="keywordtype">int</span> index=0;
<a name="l02357"></a>02357         <span class="keywordflow">while</span> (q_ptr-&gt;front().type == QueueItem::MEM)
<a name="l02358"></a>02358         {
<a name="l02359"></a>02359                 <span class="comment">//fprintf(stdout,"\nSize of the Queue %d",q_ptr-&gt;size());</span>
<a name="l02360"></a>02360                 <span class="comment">//fprintf(stdout,"\nMemory-op found\n");</span>
<a name="l02361"></a>02361                 index++;
<a name="l02362"></a>02362                 <span class="keywordflow">if</span>(q_ptr-&gt;front().data.mem.type==<a class="code" href="machine_8h.html#d2266d8ea9432d7a4253dcc60ec17a18a7dbd12c9d01b690ec6bd1229a617aec">MEM_RD</a>)
<a name="l02363"></a>02363                 {
<a name="l02364"></a>02364                         <span class="keywordflow">if</span>(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0]==0)
<a name="l02365"></a>02365                         {
<a name="l02366"></a>02366                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[0]=q_ptr-&gt;front().data.mem.vaddr;
<a name="l02367"></a>02367                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#ebe595b6542eff03da2b3f92bb966c07">mem_paddr_ld</a>[0]=q_ptr-&gt;front().data.mem.paddr;
<a name="l02368"></a>02368                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4e0149c5502186cc978fc5412d60b087">ld_dequeued</a>[0]=<span class="keyword">false</span>;
<a name="l02369"></a>02369                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#aa559aaa21d731cda775b553c08c9a2f">ld_size</a>[0]=q_ptr-&gt;front().data.mem.size;
<a name="l02370"></a>02370                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++;
<a name="l02371"></a>02371                                 <span class="comment">//fprintf(stdout,"\nLoad MemOp address is 0x%llx Size=%d ",q_ptr-&gt;front().data.mem.paddr,q_ptr-&gt;front().data.mem.size );</span>
<a name="l02372"></a>02372                         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[1]==0)
<a name="l02373"></a>02373                               {
<a name="l02374"></a>02374                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#a43937a0969b5ef7228d9a2047457c87">mem_vaddr_ld</a>[1]=q_ptr-&gt;front().data.mem.vaddr;
<a name="l02375"></a>02375                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#ebe595b6542eff03da2b3f92bb966c07">mem_paddr_ld</a>[1]=q_ptr-&gt;front().data.mem.paddr;
<a name="l02376"></a>02376                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4e0149c5502186cc978fc5412d60b087">ld_dequeued</a>[1]=<span class="keyword">false</span>;
<a name="l02377"></a>02377                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#aa559aaa21d731cda775b553c08c9a2f">ld_size</a>[1]=q_ptr-&gt;front().data.mem.size;
<a name="l02378"></a>02378                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++;
<a name="l02379"></a>02379                                 <span class="comment">//fprintf(stdout,"\nLoad MemOp address is 0x%llx ",q_ptr-&gt;front().data.mem.vaddr);</span>
<a name="l02380"></a>02380                               }<span class="comment">//else</span>
<a name="l02381"></a>02381                                         <span class="comment">//fprintf(stdout,"\n[%lld]Oracle More than two Load micro-ops for one instruction",sim_cycle);</span>
<a name="l02382"></a>02382                 }
<a name="l02383"></a>02383                 <span class="keywordflow">if</span>(q_ptr-&gt;front().data.mem.type==<a class="code" href="machine_8h.html#d2266d8ea9432d7a4253dcc60ec17a18f6d36162f59eda62f0c4de11fc00a104">MEM_WR</a>)
<a name="l02384"></a>02384                 {
<a name="l02385"></a>02385                         
<a name="l02386"></a>02386                         <span class="keywordflow">if</span>(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0]==0)
<a name="l02387"></a>02387                         {
<a name="l02388"></a>02388                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[0]=q_ptr-&gt;front().data.mem.vaddr;
<a name="l02389"></a>02389                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#84f77c012a6cdd392f645db63dd3b9cb">mem_paddr_str</a>[0]=q_ptr-&gt;front().data.mem.paddr;
<a name="l02390"></a>02390                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4158b3e42772696b3f6569c7fc2b1401">str_dequeued</a>[0]=<span class="keyword">false</span>;
<a name="l02391"></a>02391                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#66a55324ea75d2ce5951a6dbfe43b665">str_size</a>[0]=q_ptr-&gt;front().data.mem.size;
<a name="l02392"></a>02392                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++;
<a name="l02393"></a>02393                                 <span class="comment">//fprintf(stdout,"\nStore MemOp address is 0x%llx ",q_ptr-&gt;front().data.mem.vaddr);</span>
<a name="l02394"></a>02394                         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[1]==0)
<a name="l02395"></a>02395                               {
<a name="l02396"></a>02396                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#2f0d7904460f2963b06f6a2918594692">mem_vaddr_str</a>[1]=q_ptr-&gt;front().data.mem.vaddr;
<a name="l02397"></a>02397                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#84f77c012a6cdd392f645db63dd3b9cb">mem_paddr_str</a>[1]=q_ptr-&gt;front().data.mem.paddr;
<a name="l02398"></a>02398                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#4158b3e42772696b3f6569c7fc2b1401">str_dequeued</a>[1]=<span class="keyword">false</span>;
<a name="l02399"></a>02399                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#66a55324ea75d2ce5951a6dbfe43b665">str_size</a>[1]=q_ptr-&gt;front().data.mem.size;
<a name="l02400"></a>02400                                 inst-&gt;<a class="code" href="structmd__inst__t.html#7d4fdf56674234c3dd7ad29c61bd6636">mem_ops</a>.<a class="code" href="structmem__ops.html#866a5a8c45748506a42f030a301ea85e">memops</a>++;
<a name="l02401"></a>02401                                 <span class="comment">//fprintf(stdout,"\nStore MemOp address is 0x%llx ",q_ptr-&gt;front().data.mem.vaddr);</span>
<a name="l02402"></a>02402                               }<span class="comment">//else</span>
<a name="l02403"></a>02403                                         <span class="comment">//fprintf(stdout,"[%lld]Oracle More than two Store micro-ops for one instruction",sim_cycle);</span>
<a name="l02404"></a>02404                 }
<a name="l02405"></a>02405                 q_ptr-&gt;pop();
<a name="l02406"></a>02406                 <span class="keywordflow">if</span>(q_ptr-&gt;empty())
<a name="l02407"></a>02407                 {
<a name="l02408"></a>02408 <span class="comment">//                      fprintf(stdout,"\n[%lld][%d]Running QSIM in md_fetch_pc in end",sim_cycle,core_id);</span>
<a name="l02409"></a>02409                         cd-&gt;run(core_id, 500);
<a name="l02410"></a>02410                 }
<a name="l02411"></a>02411         }       <span class="comment">//end of while</span>
<a name="l02412"></a>02412         <span class="comment">//fprintf(stdout, " --Number of memory-ops %d",index);</span>
<a name="l02413"></a>02413    }<span class="keywordflow">else</span>
<a name="l02414"></a>02414    {
<a name="l02415"></a>02415         <span class="comment">//fprintf(stdout,"\nRunning QSIM in md_fetch_pc Queue empty in begining");</span>
<a name="l02416"></a>02416 <span class="comment">//      fprintf(stdout,"\n[%lld][%d]Running QSIM in md_fetch_pc",sim_cycle,core_id);</span>
<a name="l02417"></a>02417         cd-&gt;run(core_id, 500);
<a name="l02418"></a>02418         <span class="keywordflow">goto</span> refetch_instr;
<a name="l02419"></a>02419    }
<a name="l02420"></a>02420 <span class="preprocessor">#endif</span>
<a name="l02421"></a>02421 <span class="preprocessor"></span>}
<a name="l02422"></a>02422 
<a name="l02423"></a>02423 
<a name="l02424"></a>02424 
<a name="l02425"></a>02425 
<a name="l02426"></a>02426 <span class="preprocessor">#ifdef USE_PIN_TRACES</span>
<a name="l02427"></a>02427 <span class="preprocessor"></span>
<a name="l02428"></a>02428 <span class="comment">/*fetch PC of next instruction but not the instruction*/</span>
<a name="l02429"></a><a class="code" href="zesto-oracle_8h.html#4603dc5f3e60fbfcd30343123777d18c">02429</a> <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> <a class="code" href="zesto-oracle_8cpp.html#4603dc5f3e60fbfcd30343123777d18c">md_fetch_next_pc</a>(<a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> *nextPC,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> core_id)
<a name="l02430"></a>02430 {       
<a name="l02431"></a>02431         <span class="keywordflow">if</span>(<a class="code" href="sim-zesto_8cpp.html#38a36f4cd3940833135cd0c497f726f4">use_stored_nextPC</a>[core_id]==<span class="keyword">true</span>)
<a name="l02432"></a>02432                 *nextPC=<a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id];
<a name="l02433"></a>02433         <span class="keywordflow">else</span>
<a name="l02434"></a>02434         {
<a name="l02435"></a>02435                 <span class="keywordflow">if</span>(!feof(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace))
<a name="l02436"></a>02436                         fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%llx"</span>, &amp;<a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id]);
<a name="l02437"></a>02437                 <span class="keywordflow">else</span>
<a name="l02438"></a>02438                 {
<a name="l02439"></a>02439                         fclose(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace);
<a name="l02440"></a>02440                         <span class="keywordtype">char</span> ch[50];
<a name="l02441"></a>02441                         sprintf (ch, <span class="stringliteral">"source/zesto/itrace%d.out"</span>,core_id);
<a name="l02442"></a>02442                         <span class="comment">//printf ("[%s] is a pin trace file\n",ch);</span>
<a name="l02443"></a>02443                         <a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#2b2709c2f5cc8eb7d9c87c8cc4e62b5d">pin_trace</a> =fopen(ch,<span class="stringliteral">"r"</span>);
<a name="l02444"></a>02444                         <span class="comment">//longjmp(sim_exit_buf, /* exitcode + fudge */0 + 1);</span>
<a name="l02445"></a>02445                         fscanf(<a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;current_thread-&gt;pin_trace,<span class="stringliteral">"%llx"</span>, &amp;<a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id]);
<a name="l02446"></a>02446                         <a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>=<a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id];
<a name="l02447"></a>02447                         <a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#70500e5215c4ebb383c43c05a670346c">regs_NPC</a>=<a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id];
<a name="l02448"></a>02448                         <a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;<a class="code" href="classcore__t.html#bb3b5f18fa768382f617bcdec3ee7d7e">fetch</a>-&gt;<a class="code" href="classcore__fetch__t.html#dadc3ae0443ab1d4eb3493d8847b10c8">PC</a> = <a class="code" href="sim-zesto_8cpp.html#fd1fbe748ceabf38ef289bb5b346f69a">cores</a>[core_id]-&gt;<a class="code" href="classcore__t.html#514a179d7ff004ee9a5c5167d90c2119">current_thread</a>-&gt;<a class="code" href="structthread__t.html#91103da0506a0127e32ad580eef763f2">regs</a>.<a class="code" href="structregs__t.html#c6889ccce9099e2fbf701f7fb78cedf1">regs_PC</a>;
<a name="l02449"></a>02449                 }
<a name="l02450"></a>02450                 *nextPC=<a class="code" href="sim-zesto_8cpp.html#87de3dd0dc95ac44e817dc0f7c7ba3d7">store_nextPC</a>[core_id];
<a name="l02451"></a>02451         }
<a name="l02452"></a>02452 }       
<a name="l02453"></a>02453 
<a name="l02454"></a>02454 
<a name="l02455"></a>02455 <span class="preprocessor">#else</span>
<a name="l02456"></a>02456 <span class="preprocessor"></span>
<a name="l02457"></a>02457 
<a name="l02458"></a>02458 <span class="comment">/*fetch PC of next instruction but not the instruction*/</span>
<a name="l02459"></a>02459 <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> <a class="code" href="zesto-oracle_8cpp.html#4603dc5f3e60fbfcd30343123777d18c">md_fetch_next_pc</a>(<a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> *nextPC, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> core_id)
<a name="l02460"></a>02460 {
<a name="l02461"></a>02461   <span class="keywordtype">int</span> i;
<a name="l02462"></a>02462   Queue *q_ptr = q[core_id]; 
<a name="l02463"></a>02463 refetch_instr:
<a name="l02464"></a>02464 
<a name="l02465"></a>02465   <span class="comment">//fprintf(stdout,"\nNumber of instructions %ld", cores[core_id]-&gt;stat.oracle_total_insn);</span>
<a name="l02466"></a>02466   <a class="code" href="machine_8h.html#fba784f22c1d8233f95c4f4db103018a">md_addr_t</a> PC;
<a name="l02467"></a>02467   <span class="keywordflow">if</span>(!q_ptr-&gt;empty())
<a name="l02468"></a>02468   {
<a name="l02469"></a>02469         <span class="keywordflow">if</span> (q_ptr-&gt;front().type == QueueItem::INST)
<a name="l02470"></a>02470         {
<a name="l02471"></a>02471                 *nextPC=q_ptr-&gt;front().data.inst.vaddr;
<a name="l02472"></a>02472                 <span class="comment">//fprintf(stdout,"\n[%d]--Queued NextPC is 0x%llx",core_id,q_ptr-&gt;front().data.inst.vaddr);</span>
<a name="l02473"></a>02473                 <span class="keywordflow">for</span> (i = 0; i &lt; q_ptr-&gt;front().data.inst.len; i++)
<a name="l02474"></a>02474                 {
<a name="l02475"></a>02475                        <span class="comment">//fprintf(stdout," %x", q_ptr-&gt;front().data.inst.bytes[i]);</span>
<a name="l02476"></a>02476                 }
<a name="l02477"></a>02477                 <span class="comment">//fprintf(stdout," Length %d", q_ptr-&gt;front().data.inst.len);</span>
<a name="l02478"></a>02478         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(q_ptr-&gt;front().type == QueueItem::INTR)
<a name="l02479"></a>02479         {
<a name="l02480"></a>02480           <span class="comment">//fprintf(stdout,"\n[%d]Interrrupt seen in md_fetch_next_PC",core_id);</span>
<a name="l02481"></a>02481           q_ptr-&gt;pop();
<a name="l02482"></a>02482           <span class="keywordflow">goto</span> refetch_instr;
<a name="l02483"></a>02483         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(q_ptr-&gt;front().type == QueueItem::MEM)
<a name="l02484"></a>02484         {       
<a name="l02485"></a>02485           <span class="comment">//fprintf(stdout,"\n[%d]Memory ops found in the nextPC entry WIERD",core_id);</span>
<a name="l02486"></a>02486           <span class="comment">//fprintf(stdout,"\n[%d]WIERD MemOp address is 0x%llx ",core_id,q_ptr-&gt;front().data.mem.vaddr);</span>
<a name="l02487"></a>02487           
<a name="l02488"></a>02488           q_ptr-&gt;pop();
<a name="l02489"></a>02489           <span class="keywordflow">goto</span> refetch_instr;
<a name="l02490"></a>02490         }
<a name="l02491"></a>02491   }
<a name="l02492"></a>02492   <span class="keywordflow">else</span>
<a name="l02493"></a>02493   {
<a name="l02494"></a>02494 <span class="comment">//      fprintf(stdout,"\n[%lld][%d]Running QSIM in md_fetch_next_pc",sim_cycle,core_id);</span>
<a name="l02495"></a>02495         cd-&gt;run(core_id, 500);
<a name="l02496"></a>02496         <span class="keywordflow">goto</span> refetch_instr;
<a name="l02497"></a>02497   }
<a name="l02498"></a>02498   <span class="keywordflow">return</span>(PC);
<a name="l02499"></a>02499 
<a name="l02500"></a>02500 }
<a name="l02501"></a>02501 <span class="preprocessor">#endif  </span>
<a name="l02502"></a>02502 <span class="preprocessor"></span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Aug 23 00:20:57 2010 for IRIS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
