/* This doesn't look like -*- C -*-, but it is!
 *
 * x86.def - X86 ISA machine definition
 * This file has been substantially rewritten from the pre-release maintained by
 * Brad Calder et al.  In particular, uop definitions have been implemented such
 * that all supported x86 macro-instructions can be decomposed into uop flows.
 * The uop definitions have also been modified to limit each uop to only three
 * inputs and one output.  Additional uop definitions have been provided to help
 * decompose complex x86 macro-instructions to satisfy the 3-in/1-out constraint.
 *
 * Copyright © 2009 by Gabriel H. Loh and the Georgia Tech Research Corporation
 * Atlanta, GA  30332-0415
 * All Rights Reserved.
 * 
 * THIS IS A LEGAL DOCUMENT BY DOWNLOADING ZESTO, YOU ARE AGREEING TO THESE
 * TERMS AND CONDITIONS.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * NOTE: Portions of this release are directly derived from the SimpleScalar
 * Toolset (property of SimpleScalar LLC), and as such, those portions are
 * bound by the corresponding legal terms and conditions.  All source files
 * derived directly or in part from the SimpleScalar Toolset bear the original
 * user agreement.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Georgia Tech Research Corporation nor the names of
 * its contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * 4. Zesto is distributed freely for commercial and non-commercial use.  Note,
 * however, that the portions derived from the SimpleScalar Toolset are bound
 * by the terms and agreements set forth by SimpleScalar, LLC.  In particular:
 * 
 *   "Nonprofit and noncommercial use is encouraged. SimpleScalar may be
 *   downloaded, compiled, executed, copied, and modified solely for nonprofit,
 *   educational, noncommercial research, and noncommercial scholarship
 *   purposes provided that this notice in its entirety accompanies all copies.
 *   Copies of the modified software can be delivered to persons who use it
 *   solely for nonprofit, educational, noncommercial research, and
 *   noncommercial scholarship purposes provided that this notice in its
 *   entirety accompanies all copies."
 * 
 * User is responsible for reading and adhering to the terms set forth by
 * SimpleScalar, LLC where appropriate.
 * 
 * 5. No nonprofit user may place any restrictions on the use of this software,
 * including as modified by the user, by any other authorized user.
 * 
 * 6. Noncommercial and nonprofit users may distribute copies of Zesto in
 * compiled or executable form as set forth in Section 2, provided that either:
 * (A) it is accompanied by the corresponding machine-readable source code, or
 * (B) it is accompanied by a written offer, with no time limit, to give anyone
 * a machine-readable copy of the corresponding source code in return for
 * reimbursement of the cost of distribution. This written offer must permit
 * verbatim duplication by anyone, or (C) it is distributed by someone who
 * received only the executable form, and is accompanied by a copy of the
 * written offer of source code.
 * 
 * 7. Zesto was developed by Gabriel H. Loh, Ph.D.  US Mail: 266 Ferst Drive,
 * Georgia Institute of Technology, Atlanta, GA 30332-0765
 *
 * NOTE: This file (x86.def) contains code directly derived from previous
 * SimpleScalar source files.  As such, this code is bound by the combination
 * of terms and agreements from both Zesto and SimpleScalar.  In case of any
 * conflicting terms (for example, but not limited to, use by commercial
 * entities), the more restrictive terms shall take precedence (e.g.,
 * non-commercial and for-profit entities may not make use of the code without
 * a license from SimpleScalar, LLC).  The SimpleScalar terms and agreements
 * are replicated below as per their original requirements.
 *
 * SimpleScalar Ô Tool Suite
 * © 1994-2003 Todd M. Austin, Ph.D. and SimpleScalar, LLC
 * All Rights Reserved.
 * 
 * THIS IS A LEGAL DOCUMENT BY DOWNLOADING SIMPLESCALAR, YOU ARE AGREEING TO
 * THESE TERMS AND CONDITIONS.
 * 
 * No portion of this work may be used by any commercial entity, or for any
 * commercial purpose, without the prior, written permission of SimpleScalar,
 * LLC (info@simplescalar.com). Nonprofit and noncommercial use is permitted as
 * described below.
 * 
 * 1. SimpleScalar is provided AS IS, with no warranty of any kind, express or
 * implied. The user of the program accepts full responsibility for the
 * application of the program and the use of any results.
 * 
 * 2. Nonprofit and noncommercial use is encouraged.  SimpleScalar may be
 * downloaded, compiled, executed, copied, and modified solely for nonprofit,
 * educational, noncommercial research, and noncommercial scholarship purposes
 * provided that this notice in its entirety accompanies all copies. Copies of
 * the modified software can be delivered to persons who use it solely for
 * nonprofit, educational, noncommercial research, and noncommercial
 * scholarship purposes provided that this notice in its entirety accompanies
 * all copies.
 * 
 * 3. ALL COMMERCIAL USE, AND ALL USE BY FOR PROFIT ENTITIES, IS EXPRESSLY
 * PROHIBITED WITHOUT A LICENSE FROM SIMPLESCALAR, LLC (info@simplescalar.com).
 * 
 * 4. No nonprofit user may place any restrictions on the use of this software,
 * including as modified by the user, by any other authorized user.
 * 
 * 5. Noncommercial and nonprofit users may distribute copies of SimpleScalar
 * in compiled or executable form as set forth in Section 2, provided that
 * either: (A) it is accompanied by the corresponding machine-readable source
 * code, or (B) it is accompanied by a written offer, with no time limit, to
 * give anyone a machine-readable copy of the corresponding source code in
 * return for reimbursement of the cost of distribution. This written offer
 * must permit verbatim duplication by anyone, or (C) it is distributed by
 * someone who received only the executable form, and is accompanied by a copy
 * of the written offer of source code.
 * 
 * 6. SimpleScalar was developed by Todd M. Austin, Ph.D. The tool suite is
 * currently maintained by SimpleScalar LLC (info@simplescalar.com). US Mail:
 * 2395 Timbercrest Court, Ann Arbor, MI 48105.
 * 
 * Copyright © 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
 *
 */

/* FIXME: these comments are out-of-date */

/* This file defines all aspects of the SimpleScalar instruction set
 * architecture.  Each instruction set in the architecture has a DEFINST()
 * macro call included below.  The contents of a instruction definition are
 * as follows:
 *
 *   DEFINST(<enum>,      <opcode>,
 *       <opname>,      <operands>,
 *       <fu_req>,      <iflags>,
 *       <output deps...>,    <input deps...>,
 *       <expr>)
 *
 * Where:
 *
 *   <enum>  - is an enumerator that is returned when an instruction is
 *      decoded by SS_OP_ENUM()
 *   <opcode>  - is the opcode of this instruction
 *   <opname>   - name of this instruction as a string, used by disassembler
 *   <operands>  - specified the instruction operand fields and their printed
 *       order for disassembly, used by disassembler, the recognized
 *      operand field are (the instruction format is detailed in
 *      the header file ss.h):
 *        J - target field
 *        j - PC relative target (offset + PC)
 *        s - S register field
 *        b - S register field (base register)
 *        t - T register field
 *        d - D register field
 *        S - S register field (FP register)
 *        T - T register field (FP register)
 *        D - D register field (FP register)
 *        o - load address offset (offset)
 *        i - signed immediate field value
 *        u - unsigned immediate field value
 *        U - upper immediate field value
 *        H - shift amount immediate field value
 *        B - break code
 *
 *   <fu_req>  - functional unit requirements for this instruction
 *   <iflags>  - instruction flags, accessible via the SS_OP_FLAGS()
 *      macro, flags are defined with F* prefix in ss.h
 *   <output deps...>
 *    - a list of up to two output dependency designators, the
 *      following designators are recognized (place an DNA in any
 *      unused fields:
 *        DGPR(N)   - general purpose register N
 *        DGPR_D(N) - double word general purpose register N
 *        DCGPR(N)  - general purpose register conditional on
 *              pre/post- increment/decrement mode
 *        DFPR_L(N) - floating-point register N, as word
 *        DFPR_F(N) - floating-point reg N, as single-prec float
 *        DFPR_D(N) - floating-point reg N, as double-prec double
 *        DHI        - HI result register
 *        DLO        - LO result register
 *        DFCC      - floating point condition codes
 *        DCPC      - current PC
 *        DNPC      - next PC
 *        DNA        - no dependence
 *
 *   <input deps...>
 *    - a list of up to three input dependency designators, the
 *      designators are defined above (place an DNA in any unused
 *      fields.
 *
 *   <expr>  - a C expression that implements the instruction being
 *       defined, the expression must modify all architected state
 *      affected by the instruction's execution, by default, the
 *      next PC (NPC) value defaults to the current PC (CPC) plus
 *      SS_INST_SIZE, as a result, only taken branches need to set
 *      NPC
 *
 *      The following predefined macros are available for use in
 *      DEFINST() instruction expressions to access the value of
 *      instruction operand/opcode field values:
 *
 *        RS      - RS register field value
 *        RT      - RT register field value
 *        RD      - RD register field value
 *        FS      - RS register field value
 *        FT      - RT register field value
 *        FD      - RD register field value
 *        BS      - RS register field value
 *        TARG    - jump target field value
 *        OFS      - signed offset field value
 *        IMM      - signed offset field value
 *        UIMM    - unsigned offset field value
 *        SHAMT   - shift amount field value
 *        BCODE   - break code field value
 *
 *      To facilitate the construction of performance simulators
 *      (which may want to specialize their architected state
 *      storage format), all architected register and memory state
 *      is accessed through the following macros:
 *
 *        GPR(N)         - read general purpose register N
 *        SET_GPR(N,E)   - write general purpose register N with E
 *        GPR_D(N)       - read double word general purpose reg N
 *        SET_GPR_D(N,E) - write double word gen purpose reg N w/ E
 *        FPR_L(N)       - read floating-point register N, as word
 *        SET_FPR_L(N,E) - floating-point reg N, as word, with E
 *        FPR_F(N)       - read FP reg N, as single-prec float
 *        SET_FPR_F(N,E) - write FP reg N, as single-prec float w/ E
 *        FPR_D(N)       - read FP reg N, as double-prec double
 *        SET_FPR_D(N,E) - write FP reg N, as double-prec double w/E
 *        HI             - read HI result register
 *        SET_HI(E)      - write HI result register with E
 *        LO             - read LO result register
 *        SET_LO(E)      - write LO result register with E
 *        FCC             - read floating point condition codes
 *        SET_FCC(E)     - write floating point condition codes w/ E
 *        CPC             - read current PC register
 *        NPC             - read next PC register
 *        SET_NPC(E)     - write next PC register with E
 *        TPC             - read target PC register
 *        SET_TPC(E)     - write target PC register with E
 *
 *        READ_SIGNED_BYTE(A)   - read signed byte from address A
 *        READ_UNSIGNED_BYTE(A) - read unsigned byte from address A
 *        READ_SIGNED_WORD(A)   - read signed word from address A
 *        READ_UNSIGNED_WORD(A) - read unsigned word from address A
 *        READ_DWORD(A)          - read double word from address A
 *        WRITE_BYTE(E,A)       - write byte value E to address A
 *        WRITE_WORD(E,A)       - write word value E to address A
 *        WRITE_DWORD(E,A)       - write double word value E to address A
 *
 *      Finally, the following helper functions are available to
 *      assist in the construction of instruction expressions:
 *
 *        INC_DEC(E,N,S) - execute E and update N as per pre/post-
 *             incr/decr addressing sementics for an
 *             access of S bytes
 *        OVER(X,Y)      - check for overflow for X+Y, both signed
 *        UNDER(X,Y)     - check for umderflow for X-Y, both signed
 *        DIV0(N)     - check for divide by zero, N is denom
 *        INTALIGN(N)    - check double word int reg N alignment
 *        FPALIGN(N)     - check double word FP reg N alignment
 *        TALIGN(T)     - check jump target T alignment
 */



/*
 * TODO:
 *
 *  - check "imul", is the multiplication actually signed?
 *  - check "push Ib", what is the operand size?
 *  - implement short-mode JCC jumps
 */

#ifndef UPDATE_CALLGRAPH_CALL
#define UPDATE_CALLGRAPH_CALL()
#endif
#ifndef UPDATE_CALLGRAPH_RETURN
#define UPDATE_CALLGRAPH_RETURN()
#endif

  /* most simulators ignore the UOP definitions */
#ifndef DEFUOP
#define DEFUOP(OP,MSK,NAME,OPFORM,RES,CLASS,O1,I1,I2,I3,OFLAGS,IFLAGS)
#endif /* !DEFUOP */

  /* some macros only look for UOP definitions */
#ifndef DEFINST
#define DEFINST(OP,MSK,NAME,OPFORM,RES,CLASS,O1,I1,I2,I3,OFLAGS,IFLAGS)
#endif /* !DEFINST */
#ifndef DEFLINK
#define DEFLINK(OP,MSK,NAME,MASK,SHIFT)
#endif
#ifndef CONNECT
#define CONNECT(OP)
#endif


/* FIXME: ADDA, ADDS should not update flags! */

#if 0
  /* TOP LEVEL decode table */
  DEFLINK(TOPLEV, 0x00, "toplev", 0, 0xff)
CONNECT(TOPLEV)
#endif

  DEFLINK(ADD_EbRb_LINK, 0x00, "add_ebrb_link", 6, 0x03)

  DEFLINK(ADD_EvRv_LINK, 0x01, "add_evrv_link", 6, 0x03)

  DEFLINK(ADD_RbEb_LINK, 0x02, "add_rbeb_link", 6, 0x03)

  DEFLINK(ADD_RvEv_LINK, 0x03, "add_rvev_link", 6, 0x03)

#define ADD_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _res = _src1 + _src2;            \
  SET_GPR_B(MD_REG_AL, _res);            \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_ALIb,    0x04,
      "add",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _res = _src1 + _src2;            \
  SET_GPR_V(MD_REG_eAX, _res);          \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_eAXIv,    0x05,
      "add",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* This macro is used to implement pushes of data that we do not track */  
#define PUSH_NONSENSE_IMPL            \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = 0xdeadbeef;              \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}

#define PUSHES_IMPL PUSH_NONSENSE_IMPL
  DEFINST(PUSHES,  0x06,
      "push es", "",
      FU_INVALID, F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define POP_NONSENSE_IMPL            \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  /* We dont keep track of segment registers, so throw this away */  \
}

#define POPES_IMPL POP_NONSENSE_IMPL
  DEFINST(POPES,    0x07,
      "pop es",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(OR_EbRb_LINK, 0x08, "or_ebrb_link", 6, 0x03)

  DEFLINK(OR_EvRv_LINK, 0x09, "or_evrv_link", 6, 0x03)

  DEFLINK(OR_RbEb_LINK, 0x0a, "or_ebrb_link", 6, 0x03)

  DEFLINK(OR_RvEv_LINK, 0x0b, "or_rvev_link", 6, 0x03)

#define OR_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _res = _src1 | _src2;            \
  SET_GPR_B(MD_REG_AL, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_ALIb,    0x0c,
      "or",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _res = _src1 | _src2;            \
  SET_GPR_V(MD_REG_eAX, _res);          \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_eAXIv,    0x0d,
      "or",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define PUSHCS_IMPL PUSH_NONSENSE_IMPL
  DEFINST(PUSHCS,    0x0e,
      "push cs",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(TWOESC_LINK, 0x0f, "twoesc_link", 0, 0xff)

  DEFLINK(ADC_EbRb_LINK, 0x10, "adc_ebrb_link", 6, 0x03)

  DEFLINK(ADC_EvRv_LINK, 0x11, "adc_evrv_link", 6, 0x03)

  DEFLINK(ADC_RbEb_LINK, 0x12, "adc_rbeb_link", 6, 0x03)

  DEFLINK(ADC_RvEv_LINK, 0x13, "adc_rvev_link", 6, 0x03)

#define ADC_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res, _cf;          \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_B(MD_REG_AL, _res);            \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_ALIb,    0x14,
      "adc",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res, _cf;          \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_V(MD_REG_eAX, _res);          \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_eAXIv,    0x15,
      "adc",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define PUSHSS_IMPL PUSH_NONSENSE_IMPL
  DEFINST(PUSHSS,    0x16,
      "push ss",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define POPSS_IMPL POP_NONSENSE_IMPL
  DEFINST(POPSS,    0x17,
      "pop ss",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(SBB_EbRb_LINK, 0x18, "sub_ebrb_link", 6, 0x03)

  DEFLINK(SBB_EvRv_LINK, 0x19, "sub_evrv_link", 6, 0x03)

  DEFLINK(SBB_RbEb_LINK, 0x1a, "sub_rbeb_link", 6, 0x03)

  DEFLINK(SBB_RvEv_LINK, 0x1b, "sub_rvev_link", 6, 0x03)

#define SBB_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res, _cf;          \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_B(MD_REG_AL, _res);            \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_ALIb,    0x1c,
      "sbb",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SBB_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res, _cf;          \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_V(MD_REG_eAX, _res);          \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_eAXIv,    0x1d,
      "sbb",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define PUSHDS_IMPL PUSH_NONSENSE_IMPL
  DEFINST(PUSHDS,    0x1e,
      "push ds",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define POPDS_IMPL POP_NONSENSE_IMPL
  DEFINST(POPDS,    0x1f,
      "pop ds",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(AND_EbRb_LINK, 0x20, "and_ebrb_link", 6, 0x03)

  DEFLINK(AND_EvRv_LINK, 0x21, "and_evrv_link", 6, 0x03)

  DEFLINK(AND_RbEb_LINK, 0x22, "and_rbeb_link", 6, 0x03)

  DEFLINK(AND_RvEv_LINK, 0x23, "and_rvev_link", 6, 0x03)

#define AND_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _res = _src1 & _src2;            \
  SET_GPR_B(MD_REG_AL, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_ALIb,    0x24,
      "and",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _res = _src1 & _src2;            \
  SET_GPR_V(MD_REG_eAX, _res);          \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_eAXIv,    0x25,
      "and",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x26: seg=es */

  /* FIXME: TODO 0x27: daa: F_NOMOD */

  DEFLINK(SUB_EbRb_LINK, 0x28, "sub_ebrb_link", 6, 0x03)

  DEFLINK(SUB_EvRv_LINK, 0x29, "sub_evrv_link", 6, 0x03)

  DEFLINK(SUB_RbEb_LINK, 0x2a, "sub_rbeb_link", 6, 0x03)

  DEFLINK(SUB_RvEv_LINK, 0x2b, "sub_rvev_link", 6, 0x03)

#define SUB_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _res = _src1 - _src2;            \
  SET_GPR_B(MD_REG_AL, _res);            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_ALIb,    0x2c,
      "sub",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _res = _src1 - _src2;            \
  SET_GPR_V(MD_REG_eAX, _res);          \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_eAXIv,    0x2d,
      "sub",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x2e: seg=cs */

/* GL: */
#define DAS_IMPL              \
{                  \
  byte_t tempAL = GPR_B(MD_REG_AL);          \
  dword_t tempCF = AFLAGS(CF);          \
  SET_AFLAGS(0,CF); \
  if( ((tempAL & 0x0f) > 9) || AFLAGS(AF)) { \
    SET_GPR_B(MD_REG_AL,tempAL - 6); \
    int borrow = (((signed char)GPR_B(MD_REG_AL)) >= 0) ^ (((signed char)tempAL) >= 0); \
    borrow = !!tempCF || !!borrow; \
    SET_AFLAGS(borrow?CF:0,CF); \
    SET_AFLAGS(AF,AF); \
  } else SET_AFLAGS(0,AF); \
  if((tempAL > 0x99) || tempCF) { \
    SET_GPR_B(MD_REG_AL,GPR_B(MD_REG_AL) - 0x60); \
    SET_AFLAGS(CF,CF); \
  } \
}
  DEFINST(DAS,      0x2f,
      "das",      "%AL",
      FU_INVALID,                 F_NOMOD|F_UIMM|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(XOR_EbRb_LINK, 0x30, "xor_ebrb_link", 6, 0x03)

  DEFLINK(XOR_EvRv_LINK, 0x31, "xor_evrv_link", 6, 0x03)

  DEFLINK(XOR_RbEb_LINK, 0x32, "xor_rbeb_link", 6, 0x03)

  DEFLINK(XOR_RvEv_LINK, 0x33, "xor_rvev_link", 6, 0x03)

#define XOR_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_B(MD_REG_AL, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_ALIb,    0x34,
      "xor",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_V(MD_REG_eAX, _res);          \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_eAXIv,    0x35,
      "xor",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x36: seg=ss */

  /* FIXME: TODO 0x37: aaa: F_NOMOD */

  DEFLINK(CMP_EbRb_LINK, 0x38, "cmp_ebrb_link", 6, 0x03)

  DEFLINK(CMP_EvRv_LINK, 0x39, "cmp_evrv_link", 6, 0x03)

  DEFLINK(CMP_RbEb_LINK, 0x3a, "cmp_rbeb_link", 6, 0x03)

  DEFLINK(CMP_RvEv_LINK, 0x3b, "cmp_rvev_link", 6, 0x03)

#define CMP_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_ALIb,    0x3c,
      "cmp",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMP_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_eAXIv,    0x3d,
      "cmp",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x3e: seg=ds */

  /* FIXME: TODO 0x3f: aas: F_NOMOD */

#define INC_ROv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RO);              \
  _res = _src + 1;              \
  SET_GPR_V(RO, _res);            \
  SET_AFLAGS(AFLAGS_INCV(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(INC_ROv,    0x4740,
      "inc",      "%Qv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define DEC_ROv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RO);              \
  _res = _src - 1;              \
  SET_GPR_V(RO, _res);            \
  SET_AFLAGS(AFLAGS_DECV(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(DEC_ROv,    0x4f48,
      "dec",      "%Qv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define PUSH_ROv_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_V(RO);              \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(PUSH_ROv,    0x5750,
      "push",      "%Qv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define POP_ROv_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  SET_GPR_V(RO, _src);            \
}
  DEFINST(POP_ROv,    0x5f58,
      "pop",      "%Qv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x5f: pusha/pushad: F_NOMOD */

#define DO_ONE_PUSHA( target )  \
    _src = target;              \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \

#define PUSHA_IMPL              \
{                  \
  dword_t _src, _sp, _temp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  _temp = _sp = GPR_S(MD_REG_eSP);            \
  DO_ONE_PUSHA( GPR_V(MD_REG_eAX) );            \
  DO_ONE_PUSHA( GPR_V(MD_REG_eCX) );            \
  DO_ONE_PUSHA( GPR_V(MD_REG_eDX) );            \
  DO_ONE_PUSHA( GPR_V(MD_REG_eBX) );            \
  DO_ONE_PUSHA( _temp );            \
  DO_ONE_PUSHA( GPR_V(MD_REG_eBP) );            \
  DO_ONE_PUSHA( GPR_V(MD_REG_eSI) );            \
  DO_ONE_PUSHA( GPR_V(MD_REG_eDI) );            \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(PUSHA,    0x60,
      "pusha",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define DO_ONE_POPA( reg_target )  \
    _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_GPR_V(reg_target, _src);          \
  _sp = _sp + SIZE_V              


#define POPA_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  _sp = GPR_S(MD_REG_eSP);            \
  DO_ONE_POPA( MD_REG_eDI );            \
  DO_ONE_POPA( MD_REG_eSI );            \
  DO_ONE_POPA( MD_REG_eBP );            \
  _sp = _sp + SIZE_V; /* Skip old stack ptr */      \
  DO_ONE_POPA( MD_REG_eBX );            \
  DO_ONE_POPA( MD_REG_eDX );            \
  DO_ONE_POPA( MD_REG_eCX );            \
  DO_ONE_POPA( MD_REG_eAX );            \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(POPA,    0x61,
      "popa",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x62: bound */

  /* FIXME: TODO 0x63: arpl */

  /* FIXME: TODO 0x64: seg=fs */

  /* FIXME: TODO 0x65: seg=gs */

  /* FIXME: TODO 0x66: opsz prefix */

  /* FIXME: TODO 0x67: addrsz prefix */

  // skumar
  DEFLINK(BOUND_RvMv_LINK, 0x62, "bound_rvmw_link", 6, 0x03) 


#define PUSH_Iv_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = IMM_V;              \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(PUSH_Iv,    0x68,
      "push",      "%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(IMUL_RvEvIv_LINK, 0x69, "imul_rveviv_link", 6, 0x03)

#define PUSH_Ib_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = (dword_t)IMM_B;            \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(PUSH_Ib,    0x6a,
      "push",      "%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(IMUL_RvEvIb_LINK, 0x6b, "imul_rvevib_link", 6, 0x03)

  /* FIXME: TODO 0x6c: insb: F_NOMOD|F_REP */

  /* FIXME: TODO 0x6d: insv: F_NOMOD|F_REP */

  /* FIXME: TODO 0x6e: outsb: F_NOMOD|F_REP */

  /* FIXME: TODO 0x6f: outsv: F_NOMOD|F_REP */

#define JCC_Jb_IMPL              \
{                  \
  dword_t _aflags;              \
  \
  SET_TPC(NPC + IMM_B);            \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  if (CC_EVAL(CC, _aflags))            \
  SET_NPC(NPC + IMM_B);            \
}
  DEFINST(JCC_Jb,      0x7f70,
      "j%cc",      "%Jb",
      FU_INVALID,                 F_CTRL|F_COND|F_DIRJMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(GRP1_EbIb_LINK, 0x80, "grp1_ebib_link", 3, 0x07)

  DEFLINK(GRP1_EvIv_LINK, 0x81, "grp1_eviv_link", 3, 0x07)

  /* aliases with 0x83 */
  DEFLINK(GRP1_EvIb_LINK, 0x83/*82*/, "grp1_evib_link", 3, 0x07)

  DEFLINK(TEST_EbRb_LINK, 0x84, "test_ebrb_link", 6, 0x03)

  DEFLINK(TEST_EvRv_LINK, 0x85, "test_evrv_link", 6, 0x03)

  /* FIXME: TODO 0x86: xchgb */

  /* DEFLINK(XCHG_EvRv_LINK, 0x87, "xchg_evrv_link", 6, 0x03) */

  // skumar

  DEFLINK(XCHG_EbRb_LINK, 0x86, "xchg_ebrb_link", 6, 0x03)

  DEFLINK(XCHG_EvGv_LINK, 0x87, "xchg_evgv_link", 6, 0x03) 


  DEFLINK(MOV_EbRb_LINK, 0x88, "mov_ebrb_link", 6, 0x03)

  DEFLINK(MOV_EvRv_LINK, 0x89, "mov_evrv_link", 6, 0x03)

  DEFLINK(MOV_RbEb_LINK, 0x8a, "mov_rbeb_link", 6, 0x03)

  DEFLINK(MOV_RvEv_LINK, 0x8b, "mov_rvev_link", 6, 0x03)

  /* FIXME: TODO 0x8c: mov_EwSw UCSD - implemented in the next line */

  DEFLINK(MOV_EwSw_LINK, 0x8c, "mov_ewsw_link", 6, 0x03)

  DEFLINK(LEA_RvMx_LINK, 0x8d, "lea_rvmx_link", 6, 0x03)

  /* FIXME: TODO 0x8e: mov_SwEw UCSD - implemented in the next line */

  DEFLINK(MOV_SwEw_LINK, 0x8e, "mov_swew_link", 6, 0x03)

  DEFLINK(POP_Ev_LINK, 0x8f, "pop_ev_link", 3, 0x07)

#define NOP_IMPL              \
{                  \
  /* nada... */              \
}
  DEFINST(NOP,      0x90,
      "nop",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XCHG_eAXRv_IMPL              \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(R));          \
  SET_GPR_V(R, _tmp);              \
}
  DEFINST(XCHG_eAXRv,    0x9791,
      "xchg",      "%eA,%Rv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  // cristiano

#define XCHG_eAXeCX_IMPL            \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(MD_REG_eCX));        \
  SET_GPR_V(MD_REG_eCX, _tmp);          \
}

  DEFINST(XCHG_eAXeCX,    0x91,
      "xchg",      "%eA,%eCX",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


#define XCHG_eAXeDX_IMPL            \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(MD_REG_eDX));        \
  SET_GPR_V(MD_REG_eDX, _tmp);          \
}

  DEFINST(XCHG_eAXeDX,    0x92,
      "xchg",      "%eA,%eDX",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XCHG_eAXeBX_IMPL            \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(MD_REG_eBX));        \
  SET_GPR_V(MD_REG_eBX, _tmp);          \
}

  DEFINST(XCHG_eAXeBX,    0x93,
      "xchg",      "%eA,%eBX",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XCHG_eAXeSP_IMPL            \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(MD_REG_eSP));        \
  SET_GPR_V(MD_REG_eSP, _tmp);          \
}

  DEFINST(XCHG_eAXeSP,    0x94,
      "xchg",      "%eA,%eSP",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


#define XCHG_eAXeBP_IMPL            \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(MD_REG_eBP));        \
  SET_GPR_V(MD_REG_eBP, _tmp);          \
}

  DEFINST(XCHG_eAXeBP,    0x95,
      "xchg",      "%eA,%eBP",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XCHG_eAXeSI_IMPL            \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(MD_REG_eSI));        \
  SET_GPR_V(MD_REG_eSI, _tmp);          \
}

  DEFINST(XCHG_eAXeSI,    0x96,
      "xchg",      "%eA,%eSI",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  // skumar

#define XCHG_eAXeDI_IMPL            \
{                  \
  dword_t _tmp;              \
  \
  _tmp = GPR_V(MD_REG_eAX);            \
  SET_GPR_V(MD_REG_eAX, GPR_V(MD_REG_eDI));        \
  SET_GPR_V(MD_REG_eDI, _tmp);          \
}

  DEFINST(XCHG_eAXeDI,    0x97,
      "xchg",      "%eA,%eDI",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


#define CBW_CWDE_IMPL              \
{                  \
  if (Mop->fetch.inst.mode & MODE_OPER32)          \
  {                  \
    word_t _src;              \
    dword_t _res;              \
    \
    _src = GPR_W(MD_REG_AX);          \
    _res = (sdword_t)(sword_t)_src;          \
    \
    SET_GPR_D(MD_REG_EAX, _res);          \
  }                  \
  else                \
  {                  \
    byte_t _src;              \
    word_t _res;              \
    \
    _src = GPR_B(MD_REG_AL);          \
    _res = (sword_t)(sbyte_t)_src;          \
    \
    SET_GPR_W(MD_REG_AX, _res);          \
  }                  \
}
  DEFINST(CBW_CWDE,    0x98,
      "cbw/cwde",    "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CWD_CDQ_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(MD_REG_eAX);            \
  _res = SIGN_V(_src);            \
  SET_GPR_V(MD_REG_eDX, _res);          \
}
  DEFINST(CWD_CDQ,    0x99,
      "cwd/cdq",    "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x9a: callf_Ap: F_NOMOD */

  /* FIXME: TODO 0x9b: fwait: F_NOMOD */

#define PUSHF_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = AFLAGS(~0);              \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(PUSHF,    0x9c,
      "pushf",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_UCODE|F_NOMOD,
      DGPR(MD_REG_eSP),
      DGPR(MD_REG_eSP), DSEG(SEG_SS), DNA,
      DNA, DNA)


#define POPF_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  SET_AFLAGS(_src, ~0UL);            \
}
  DEFINST(POPF,      0x9d,
      "popf",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DGPR(MD_REG_eSP),
      DGPR(MD_REG_eSP), DSEG(SEG_SS), DNA,
      DNA, DNA)

#define SAHF_IMPL              \
{                  \
  byte_t _src;              \
  \
  _src = GPR_B(MD_REG_AH);            \
  SET_AFLAGS((((dword_t)_src) & (SF|ZF|AF|PF|CF)), SF|ZF|AF|PF|CF);  \
}
  DEFINST(SAHF,      0x9e,
      "sahf",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define LAHF_IMPL              \
{                  \
  byte_t _src;              \
  \
  _src = (byte_t)AFLAGS(SF|ZF|AF|PF|CF);        \
  SET_GPR_B(MD_REG_AH, _src|2);          \
}
  DEFINST(LAHF,      0x9f,
      "lahf",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_ALOb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, 0, 0, 0, UIMM_A);        \
  _res = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_B(MD_REG_AL, _res);            \
}
  DEFINST(MOV_ALOb,    0xa0,
      "mov",      "AL,%Ob",
      FU_INVALID,                 F_MEM|F_LOAD|F_NOMOD|F_UIMM|F_IMMA|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_eAXOv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, 0, 0, 0, UIMM_A);        \
  _res = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_V(MD_REG_eAX, _res);          \
}
  DEFINST(MOV_eAXOv,    0xa1,
      "mov",      "%eA,%Ov",
      FU_INVALID,                 F_MEM|F_LOAD|F_NOMOD|F_UIMM|F_IMMA|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_ObAL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_B(MD_REG_AL);            \
  \
  _addr = AGEN_A(SEG, 0, 0, 0, UIMM_A);        \
  WRITE_BYTE(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(MOV_ObAL,    0xa2,
      "mov",      "%Ob,AL",
      FU_INVALID,                 F_MEM|F_STORE|F_NOMOD|F_UIMM|F_IMMA|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_OveAX_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_V(MD_REG_eAX);            \
  \
  _addr = AGEN_A(SEG, 0, 0, 0, UIMM_A);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(MOV_OveAX,    0xa3,
      "mov",      "%Ov,%eA",
      FU_INVALID,                 F_MEM|F_STORE|F_NOMOD|F_UIMM|F_IMMA|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOVSB_XbYb_IMPL              \
{                  \
  md_addr_t _srcaddr, _dstaddr;          \
  byte_t _src;              \
  enum md_fault_type _fault;            \
  \
  _srcaddr = AGEN_A(SEG, GPR_A(MD_REG_eSI), 0, 0, 0);      \
  _src = READ_BYTE(_srcaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _dstaddr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);    \
  WRITE_BYTE(_src, _dstaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) + 1);      \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + 1);      \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) - 1);      \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - 1);      \
  }                  \
}
  DEFINST(MOVSB_XbYb,    0xa4,
      "movsb",    "%Xb,%Yb",
      FU_INVALID,                 F_MEM|F_LOAD|F_STORE|F_NOMOD|F_REP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOVSB_XvYv_IMPL              \
{                  \
  md_addr_t _srcaddr, _dstaddr;          \
  dword_t _src;              \
  enum md_fault_type _fault;            \
  \
  _srcaddr = AGEN_A(SEG, GPR_A(MD_REG_eSI), 0, 0, 0);      \
  _dstaddr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);    \
  \
  _src = READ_V(_srcaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  \
  WRITE_V(_src, _dstaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) + SIZE_V);    \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + SIZE_V);    \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) - SIZE_V);    \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - SIZE_V);    \
  }                  \
}
  DEFINST(MOVSB_XvYv,    0xa5,
      "movsv",    "%Xv,%Yv",
      FU_INVALID,                 F_MEM|F_LOAD|F_STORE|F_NOMOD|F_REP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMPSB_XbYb_IMPL              \
{                  \
  md_addr_t _src1addr, _src2addr;          \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1addr = AGEN_A(SEG, GPR_A(MD_REG_eSI), 0, 0, 0);    \
  _src1 = READ_BYTE(_src1addr, _fault);        \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2addr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);    \
  _src2 = READ_BYTE(_src2addr, _fault);        \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) + 1);      \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + 1);      \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) - 1);      \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - 1);      \
  }                  \
}
  DEFINST(CMPSB_XbYb,    0xa6,
      "cmpsb",    "%Xb,%Yb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMPSB_XvYv_IMPL              \
{                  \
  md_addr_t _src1addr, _src2addr;          \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1addr = AGEN_A(SEG, GPR_A(MD_REG_eSI), 0, 0, 0);    \
  _src1 = READ_V(_src1addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2addr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);    \
  _src2 = READ_V(_src2addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) + SIZE_V);    \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + SIZE_V);    \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) - SIZE_V);    \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - SIZE_V);    \
  }                  \
}
  DEFINST(CMPSB_XvYv,    0xa7,
      "cmpsv",    "%Xv,%Yv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define TEST_ALIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = IMM_B;              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_ALIb,    0xa8,
      "test",      "AL,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define TEST_eAXIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = IMM_V;              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_eAXIv,    0xa9,
      "test",      "%eA,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define STOSB_ALYb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_B(MD_REG_AL);            \
  _addr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);      \
  WRITE_BYTE(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + 1);      \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - 1);      \
  }                  \
}
  DEFINST(STOSB_ALYb,    0xaa,
      "stosb",    "AL,%Yb",
      FU_INVALID,                 F_MEM|F_STORE|F_NOMOD|F_REP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define STOSV_eAXYv_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_V(MD_REG_eAX);            \
  _addr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);      \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + SIZE_V);    \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - SIZE_V);    \
  }                  \
}
  DEFINST(STOSV_eAXYv,    0xab,
      "stosv",    "%eA,%Yv",
      FU_INVALID,                 F_MEM|F_STORE|F_NOMOD|F_REP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define LODSB_ALXb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, GPR_A(MD_REG_eSI), 0, 0, 0);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_B(MD_REG_AL, _src);            \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) + 1);      \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) - 1);      \
  }                  \
}
  DEFINST(LODSB_ALXb,    0xac,
      "lodsb",    "AL,%Xb",
      FU_INVALID,                 F_MEM|F_LOAD|F_NOMOD|F_REP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define LODSV_eAXXv_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, GPR_A(MD_REG_eSI), 0, 0, 0);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_V(MD_REG_eAX, _src);          \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) + SIZE_V);    \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eSI, GPR_A(MD_REG_eSI) - SIZE_V);    \
  }                  \
}
  DEFINST(LODSV_eAXXv,    0xad,
      "lodsv",    "%eA,%Xv",
      FU_INVALID,                 F_MEM|F_LOAD|F_NOMOD|F_REP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SCASB_Yb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t  _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _addr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + 1);      \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - 1);      \
  }                  \
}
  DEFINST(SCASB_Yb,    0xae,
      "scasb",    "%Yb",
      FU_INVALID,                 F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SCASV_Yv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _addr = AGEN_A(SEG_ES, GPR_A(MD_REG_eDI), 0, 0, 0);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
  \
  if (!AFLAGS(DF))              \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) + SIZE_V);    \
  }                  \
  else                \
  {                  \
    SET_GPR_A(MD_REG_eDI, GPR_A(MD_REG_eDI) - SIZE_V);    \
  }                  \
}
  DEFINST(SCASV_Yv,    0xaf,
      "scasv",    "%Yv",
      FU_INVALID,                 F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RObIb_IMPL              \
{                  \
  SET_GPR_B(RO, IMM_B);            \
}
  DEFINST(MOV_RObIb,    0xb7b0,
      "mov",      "%Qb,%Ib",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_ROvIv_IMPL              \
{                  \
  SET_GPR_V(RO, IMM_V);            \
}
  DEFINST(MOV_ROvIv,    0xbfb8,
      "mov",      "%Qv,%Iv",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(GRP2_EbIb_LINK, 0xc0, "grp2_ebib_link", 3, 0x07)

  DEFLINK(GRP2_EvIb_LINK, 0xc1, "grp2_evib_link", 3, 0x07)

#define RETN_Iw_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V + IMM_W;            \
  \
  SET_TPC_V(_src);              \
  SET_NPC_V(_src);              \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  UPDATE_CALLGRAPH_RETURN();            \
}
  DEFINST(RETN_Iw,    0xc2,
      "retn",      "%Iw",
      FU_INVALID,                 F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_ICOMP|F_NOMOD|F_IMMW|F_UCODE|F_RETN,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RETN_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  SET_TPC_V(_src);              \
  SET_NPC_V(_src);              \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  UPDATE_CALLGRAPH_RETURN();            \
}
  DEFINST(RETN,      0xc3,
      "retn",      "",
      FU_INVALID,                 F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_ICOMP|F_NOMOD|F_UCODE|F_RETN,
      DGPR(MD_REG_eSP),
      DGPR(MD_REG_eSP), DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xc4: les_RvMp */

  /* FIXME: TODO 0xc5: lds_RvMp */

  DEFLINK(MOV_EbIb_LINK, 0xc6, "mov_ebib_link", 3, 0x07)

  DEFLINK(MOV_EvIv_LINK, 0xc7, "mov_eviv_link", 3, 0x07)

  /* FIXME: TODO 0xc8: enter_IwIb: F_NOMOD */

#define LEAVE_IMPL              \
{                  \
  dword_t _src, _sp, _bp;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _bp = GPR_S(MD_REG_eBP);            \
  SET_GPR_S(MD_REG_eSP, _bp);            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  \
  SET_GPR_V(MD_REG_eBP, _src);          \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(LEAVE,      0xc9,
      "leave",    "",
      FU_INVALID,                 F_MEM|F_LOAD|F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xca: retf_Iw: F_NOMOD */


#define RETF_Iw_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V + IMM_W;            \
  \
  SET_TPC_V(_src);              \
  SET_NPC_V(_src);              \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  UPDATE_CALLGRAPH_RETURN();            \
}
  DEFINST(RETF_Iw,    0xca,
      "retn",      "%Iw",
      FU_INVALID,                 F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_ICOMP|F_NOMOD|F_IMMW|F_UCODE|F_RETN,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RETF_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  SET_TPC_V(_src);              \
  SET_NPC_V(_src);              \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  UPDATE_CALLGRAPH_RETURN();            \
}
  DEFINST(RETF,      0xcb,
      "retn",      "",
      FU_INVALID,                 F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_ICOMP|F_NOMOD|F_UCODE|F_RETN,
      DGPR(MD_REG_eSP),
      DGPR(MD_REG_eSP), DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xcb: retf: F_NOMOD */

#define INT3_IMPL              \
{                  \
  /* do nothing - just a breakpoint */ \
}
  DEFINST(INT3,      0xcc,
      "int",      "%Ib",
      FU_INVALID,                 F_TRAP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define INT_Ib_IMPL              \
{                  \
  /* FIXME: implement... */            \
  if (IMM_B == 0x80)              \
  SYSCALL(Mop->fetch.inst);              \
  else                \
  DECLARE_FAULT(md_fault_unimpl);          \
}
  DEFINST(INT_Ib,      0xcd,
      "int",      "%Ib",
      FU_INVALID,                 F_TRAP|F_NOMOD|F_UIMM|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xce: into: F_NOMOD */

#define INTO_IMPL              \
{                  \
  /* do nothing - conditional jump into interrupt procedure */ \
}
  DEFINST(INTO,      0xce,
      "int",      "%Ib",
      FU_INVALID,                 F_TRAP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xcf: iret: F_NOMOD */

#define IRET_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  SET_TPC_V(_src);              \
  SET_NPC_V(_src);              \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  UPDATE_CALLGRAPH_RETURN();            \
}
  DEFINST(IRET,      0xcf,
      "retn",      "",
      FU_INVALID,                 F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_ICOMP|F_NOMOD|F_UCODE|F_RETN,
      DGPR(MD_REG_eSP),
      DGPR(MD_REG_eSP), DNA, DNA,
      DNA, DNA)



  DEFLINK(GRP2_Eb1_LINK, 0xd0, "grp2_eb1_link", 3, 0x07)

  DEFLINK(GRP2_Ev1_LINK, 0xd1, "grp2_ev1_link", 3, 0x07)

  DEFLINK(GRP2_EbCL_LINK, 0xd2, "grp2_ebcl_link", 3, 0x07)

  DEFLINK(GRP2_EvCL_LINK, 0xd3, "grp2_evcl_link", 3, 0x07)

/* GL: */
#define AAM_Ib_IMPL              \
{                  \
  byte_t tempAL = GPR_B(MD_REG_AL);          \
  if(IMM_B) { \
    SET_GPR_B(MD_REG_AH, tempAL / IMM_B); \
    SET_GPR_B(MD_REG_AL, tempAL % IMM_B); \
  } /* else should raise exception */ \
  else \
    warn("AAM called with zero Ib"); \
  SET_AFLAGS(AFLAGS_ALUB(GPR_B(MD_REG_AL)), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(AAM_Ib,      0xd4,
      "aam",      "%Ib",
      FU_INVALID,                 F_NOMOD|F_UIMM|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define AAD_Ib_IMPL              \
{                  \
  byte_t tempAL = GPR_B(MD_REG_AL);          \
  byte_t tempAH = GPR_B(MD_REG_AH);          \
  SET_GPR_B(MD_REG_AL,(tempAL + (tempAH * IMM_B)) & 0xff); \
  SET_GPR_B(MD_REG_AH,0); \
  SET_AFLAGS(AFLAGS_ALUB(GPR_B(MD_REG_AL)), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(AAD_Ib,      0xd5,
      "aad",      "%Ib",
      FU_INVALID,                 F_NOMOD|F_UIMM|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xd6: *unused* */

  /* FIXME: TODO 0xd7: xlatb: F_NOMOD */

  DEFLINK(GRPD8_LINK, 0xd8, "grpd8_link", 3, 0x07)

  DEFLINK(GRPD9_LINK, 0xd9, "grpd9_link", 3, 0x07)

  DEFLINK(GRPDA_LINK, 0xda, "grpda_link", 3, 0x07)

  DEFLINK(GRPDB_LINK, 0xdb, "grpdb_link", 3, 0x07)

  DEFLINK(GRPDC_LINK, 0xdc, "grpdc_link", 3, 0x07)

  DEFLINK(GRPDD_LINK, 0xdd, "grpdd_link", 3, 0x07)

  DEFLINK(GRPDE_LINK, 0xde, "grpde_link", 3, 0x07)

  DEFLINK(GRPDF_LINK, 0xdf, "grpdf_link", 3, 0x07)

#define LOOPNZ_Jb_IMPL              \
{                  \
  dword_t _count, _aflags;            \
  \
  SET_TPC(NPC + IMM_B);            \
  \
  _count = GPR_A(MD_REG_eCX) - 1;          \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  if (CC_EVAL(CC_NE, _aflags) && _count != 0)        \
  SET_NPC(NPC + IMM_B);            \
  \
  SET_GPR_A(MD_REG_eCX, _count);          \
}
  DEFINST(LOOPNZ_Jb,    0xe0,
      "loopnz",    "%Jb",
      FU_INVALID,                 F_ICOMP|F_CTRL|F_COND|F_DIRJMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define LOOPZ_Jb_IMPL              \
{                  \
  dword_t _count, _aflags;            \
  \
  SET_TPC(NPC + IMM_B);            \
  \
  _count = GPR_A(MD_REG_eCX) - 1;          \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  if (CC_EVAL(CC_E, _aflags) && _count != 0)        \
  SET_NPC(NPC + IMM_B);            \
  \
  SET_GPR_A(MD_REG_eCX, _count);          \
}
  DEFINST(LOOPZ_Jb,    0xe1,
      "loopz",    "%Jb",
      FU_INVALID,                 F_ICOMP|F_CTRL|F_COND|F_DIRJMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define LOOP_Jb_IMPL              \
{                  \
  dword_t _count;              \
  \
  SET_TPC(NPC + IMM_B);            \
  \
  _count = GPR_A(MD_REG_eCX) - 1;          \
  if (_count != 0)              \
  SET_NPC(NPC + IMM_B);            \
  \
  SET_GPR_A(MD_REG_eCX, _count);          \
}
  DEFINST(LOOP_Jb,    0xe2,
      "loop",      "%Jb",
      FU_INVALID,                 F_ICOMP|F_CTRL|F_COND|F_DIRJMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define JCXZ_Jb_IMPL              \
{                  \
  dword_t _count;              \
  \
  SET_TPC(NPC + IMM_B);            \
  \
  _count = GPR_A(MD_REG_eCX);            \
  if (_count == 0)              \
  SET_NPC(NPC + IMM_B);            \
}
  DEFINST(JCXZ_Jb,    0xe3,
      "j%eC",      "%Jb",
      FU_INVALID,                 F_CTRL|F_COND|F_DIRJMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define IN_ALIb_IMPL              \
{                  \
  byte_t port = IMM_B & 0xff; \
  fprintf(stderr,"IN_ALIb inb(%d)\n",port); \
  byte_t val = inb(port) & 0xff; \
  SET_GPR_B(MD_REG_AL,val); \
  return; \
}
  DEFINST(IN_ALIb,    0xe4,
      "AL",      "%Ib",
      FU_INVALID,                 F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define IN_eAXIb_IMPL              \
{                  \
  byte_t port = IMM_B & 0xff; \
  fprintf(stderr,"IN_eAXIb inw(%d)\n",port); \
  dword_t val = inw(port); \
  SET_GPR_D(MD_REG_EAX,val); \
  return; \
}
  DEFINST(IN_eAXIb,    0xe5,
      "i%eA",      "%Ib",
      FU_INVALID,                 F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define OUT_IbAL_IMPL              \
{                  \
  byte_t val = GPR_B(MD_REG_AL) & 0xff; \
  byte_t port = IMM_B & 0xff;  \
  fprintf(stderr,"OUT_IbAL outb(%.2x,%d)\n",val,port); \
  outb(val,port); \
  return; \
}
  DEFINST(OUT_IbAL,    0xe6,
      "",      "AL",
      FU_INVALID,                 F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define OUT_IbeAX_IMPL              \
{                  \
  dword_t val = GPR_D(MD_REG_EAX); \
  byte_t port = IMM_B & 0xff;  \
  fprintf(stderr,"OUT_IbeAX outw(%.2x,%d)\n",val,port); \
  outw(val,port); \
  return; \
}
  DEFINST(OUT_IbeAX,    0xe7,
      "",      "eA,Ib",
      FU_INVALID,                 F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CALLN_Jv_IMPL              \
{                  \
  dword_t _sp;                \
  md_addr_t _addr, _npc;            \
  enum md_fault_type _fault;            \
  \
  _npc = NPC;                \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_npc, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  SET_TPC(_npc + IMM_V);            \
  SET_NPC(_npc + IMM_V);            \
  UPDATE_CALLGRAPH_CALL();              \
}
  DEFINST(CALLN_Jv,    0xe8,
      "call",      "%Jv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_CTRL|F_UNCOND|F_NOMOD|F_IMMV|F_UCODE|F_CALL,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define JMPN_Jv_IMPL              \
{                  \
  SET_TPC(NPC + IMM_V);            \
  SET_NPC(NPC + IMM_V);            \
}
  DEFINST(JMPN_Jv,    0xe9,
      "jmp",      "%Jv",
      FU_INVALID,                 F_CTRL|F_UNCOND|F_DIRJMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xea: jmpf_Ap */


#define JMPF_Ap_IMPL              \
{                  \
  SET_TPC(NPC + IMM_V);            \
  SET_NPC(NPC + IMM_V);            \
}
  DEFINST(JMPF_Ap,    0xea,
      "jmp",      "%Jd",
      FU_INVALID,                 F_CTRL|F_UNCOND|F_DIRJMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define JMPN_Jb_IMPL              \
{                  \
  SET_TPC(NPC + IMM_B);            \
  SET_NPC(NPC + IMM_B);            \
}
  DEFINST(JMPN_Jb,    0xeb,
      "jmp",      "%Jb",
      FU_INVALID,                 F_CTRL|F_UNCOND|F_DIRJMP|F_NOMOD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define IN_ALDX_IMPL              \
{                  \
  word_t port = GPR_W(MD_REG_DX) & 0xffff; \
  byte_t val = inb(port) & 0xff; \
  fprintf(stderr,"IN_ALDX inb(%d) --> %.8x\n",port,val); \
  SET_GPR_B(MD_REG_AL,val); \
  return; \
}
  DEFINST(IN_ALDX,    0xec,
      "AL",      "DX",
      FU_INVALID,                 F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define IN_eAXDX_IMPL              \
{                  \
  word_t port = GPR_W(MD_REG_DX) & 0xffff; \
  dword_t val = inw(port); \
  fprintf(stderr,"IN_eAXDX inw(%d)\n",port); \
  SET_GPR_D(MD_REG_EAX,val); \
  return; \
}
  DEFINST(IN_eAXDX,    0xed,
      "eAX",      "DX",
      FU_INVALID,                 F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define OUT_DXAL_IMPL              \
{                  \
  byte_t val = GPR_B(MD_REG_AL) & 0xff; \
  word_t port = GPR_W(MD_REG_DX) & 0xffff;  \
  fprintf(stderr,"OUT_DXAL outb(%.8x,%d)\n",val,port); \
  outb(val,port); \
  return; \
}
  DEFINST(OUT_DXAL,    0xee,
      "",      "DX,AL",
      FU_INVALID,                 F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

/* GL: */
#define OUT_DXeAX_IMPL              \
{                  \
  dword_t val = GPR_D(MD_REG_EAX); \
  word_t port = GPR_W(MD_REG_DX) & 0xffff;  \
  fprintf(stderr,"OUT_DXeAX outw(%.8x,%d)\n",val,port); \
  outw(val,port); \
  return; \
}
  DEFINST(OUT_DXeAX,    0xef,
      "",      "DX,eAX",
      FU_INVALID,                 F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xf0: lock prefix */

  /* FIXME: TODO 0xf1: *unused* */

  /* FIXME: TODO 0xf2: repne prefix */

  /* FIXME: TODO 0xf3: repe prefix */

#ifdef FIXME
#define HLT_IMPL              \
{                  \
  DECLARE_FAULT(md_fault_unimpl);          \
}
#else
#define HLT_IMPL              \
{                  \
  extern jmp_buf sim_exit_buf;          \
  \
  fprintf(stderr, "** HLT executed...\n");        \
  longjmp(sim_exit_buf, /* exitcode + fudge */0 + 1);      \
}
#endif
  DEFINST(HLT,      0xf4,
      "hlt",      "",
      FU_INVALID,                 F_TRAP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMC_IMPL              \
{                  \
  SET_AFLAGS(AFLAGS(CF) ^ CF, CF);          \
}
  DEFINST(CMC,      0xf5,
      "cmc",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(GRP3_Eb_LINK, 0xf6, "grp3_eb_link", 3, 0x07)

  DEFLINK(GRP3_Ev_LINK, 0xf7, "grp3_ev_link", 3, 0x07)

#define CLC_IMPL              \
{                  \
  SET_AFLAGS(0, CF);              \
}
  DEFINST(CLC,      0xf8,
      "clc",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define STC_IMPL              \
{                  \
  SET_AFLAGS(CF, CF);              \
}
  DEFINST(STC,      0xf9,
      "stc",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xfa: cli: F_NOMOD */
#define CLI_IMPL              \
{                  \
  SET_AFLAGS(0, DF);              \
}
  DEFINST(CLI,      0xfa,
      "cli",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define STIF_IMPL              \
{                  \
  SET_AFLAGS(DF, DF);              \
}
  DEFINST(STIF,      0xfb,
      "sti",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xfb: sti: F_NOMOD */

#define CLD_IMPL              \
{                  \
  SET_AFLAGS(0, DF);              \
}
  DEFINST(CLD,      0xfc,
      "cld",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define STDF_IMPL              \
{                  \
  SET_AFLAGS(DF, DF);              \
}
  DEFINST(STDF,      0xfd,
      "std",      "",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(GRP4_Eb_LINK, 0xfe, "grp4_eb_link", 3, 0x07)

  DEFLINK(GRP5_Ev_LINK, 0xff, "grp5_ev_link", 3, 0x07)


CONNECT(LEA_RvMx_LINK)

#define LEA_RvMx_IMPL              \
{                  \
  md_addr_t _addr;              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  \
  SET_GPR_V(R, _addr);            \
}
  DEFINST(LEA_RvMx,    0x0200,
      "lea",      "%Rv,%Mx",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)



CONNECT(ADD_EbRb_LINK)

#define ADD_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_B(R);              \
  _res = _src1 + _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_MbRb,    0x0200,
      "add",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _res = _src1 + _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RMbRb,    0x03,
      "add",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(XCHG_EvGv_LINK)
  /*
#define XCHG_MvRv_IMPL              \
{                  \
md_addr_t _addr;              \
dword_t _dst, _src;                          \
enum md_fault_type _fault;            \
\
_addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
_dst = READ_V(_addr, _fault);          \
if (_fault != md_fault_none)          \
DECLARE_FAULT(_fault);            \
_src = GPR_V(R);                \
WRITE_V(_src, _addr, _fault);          \
if (_fault != md_fault_none)          \
DECLARE_FAULT(_fault);            \
SET_GPR_V(R, _dst);          \
}

DEFINST(XCHG_MvRv,    0x0200,
"xchgv",      "%Mv,%Rv",
FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
DNA,
DNA, DNA, DNA,
DNA, DNA)

#define XCHG_RMvRv_IMPL              \
{                  \
dword_t _dst, _src; \
\
_dst = GPR_V(RM);              \
_src = GPR_V(R);              \
SET_GPR_V(RM,_src);        \
SET_GPR_V(R,_dst);        \
}
DEFINST(XCHG_RMvRv,    0x03,
"xchgv",      "%Nv,%Rv",
FU_INVALID,                 F_ICOMP|F_UCODE,
DNA,
DNA, DNA, DNA,
DNA, DNA)
   */

CONNECT(CMPXCHG_EvRv_LINK)

#define CMPXCHG_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _eax, _dst, _src, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _eax = GPR_V(MD_REG_eAX);            \
  _dst = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _eax - _dst;          \
  if (_res == 0)           \
  {                \
    _src = GPR_V(R);                \
    WRITE_V(_src, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);            \
  }                          \
  else                        \
  {                          \
    SET_GPR_V(MD_REG_eAX, _dst);          \
  }                          \
  \
  SET_AFLAGS(AFLAGS_SUBV(_res, _eax, _dst), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMPXCHG_MvRv,    0x0200,
      "cmpxchg",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMPXCHG_RMvRv_IMPL              \
{                  \
  dword_t _eax, _dst, _src, _res; \
  \
  _eax = GPR_V(MD_REG_eAX);    \
  _dst = GPR_V(RM);              \
  _res = _eax - _dst;              \
  if (_res == 0)            \
  {                  \
    _src = GPR_V(R);              \
    SET_GPR_V(RM,_src);        \
  }            \
  else            \
  {            \
    SET_GPR_V(MD_REG_eAX, _dst);            \
  }            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _eax, _dst), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMPXCHG_RMvRv,    0x03,
      "cmpxchg",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMPXCHG8B_EvRv_LINK)

#define CMPXCHG8B_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _eax, _dst, _src, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _eax = GPR_V(MD_REG_eAX);            \
  _dst = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _eax - _dst;          \
  if (_res == 0)           \
  {                \
    _src = GPR_V(R);                \
    WRITE_V(_src, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);            \
  }                          \
  else                        \
  {                          \
    SET_GPR_V(MD_REG_eAX, _dst);          \
  }                          \
  \
  SET_AFLAGS(AFLAGS_SUBV(_res, _eax, _dst), OF|SF|ZF|AF|CF|PF);  \
}

  DEFINST(CMPXCHG8B_MvRv,    0x0200,
      "cmpxchg8b",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FENCE_LINK)

#define FENCE_IMPL	\
{	\
}

  DEFINST(FENCE,    0x0200,
      "fence",      "",
      FU_INVALID,                 F_FENCE|F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XADD_EvRv_LINK)

#define XADD_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _dst, _src, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _dst = READ_V(_addr, _fault);          \
  _src = GPR_V(R);                \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_V(R,_dst);            \
  _res = _src + _dst;          \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src, _dst), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(XADD_MvRv,    0x0200,
      "xadd",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XADD_RMvRv_IMPL              \
{                  \
  dword_t _dst, _src, _res; \
  \
  _dst = GPR_V(RM);              \
  _src = GPR_V(R);              \
  SET_GPR_V(R,_dst);            \
  _res = _src + _dst;              \
  SET_GPR_V(RM,_res);        \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src, _dst), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(XADD_RMvRv,    0x03,
      "xadd",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(ADD_EvRv_LINK)

#define ADD_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_V(R);              \
  _res = _src1 + _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_MvRv,    0x0200,
      "add",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _res = _src1 + _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RMvRv,    0x03,
      "add",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADD_RbEb_LINK)

#define ADD_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RbMb,    0x0200,
      "add",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _res = _src1 + _src2;            \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RbRMb,    0x03,
      "add",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADD_RvEv_LINK)

#define ADD_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RvMv,    0x0200,
      "add",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _res = _src1 + _src2;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RvRMv,    0x03,
      "add",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(OR_EbRb_LINK)

#define OR_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_B(R);              \
  _res = _src1 | _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_MbRb,    0x0200,
      "or",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _res = _src1 | _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RMbRb,    0x03,
      "or",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(OR_EvRv_LINK)

#define OR_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_V(R);              \
  _res = _src1 | _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_MvRv,    0x0200,
      "or",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _res = _src1 | _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RMvRv,    0x03,
      "or",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(OR_RbEb_LINK)

#define OR_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 | _src2;            \
  \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RbMb,    0x0200,
      "or",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _res = _src1 | _src2;            \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RbRMb,    0x03,
      "or",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(OR_RvEv_LINK)

#define OR_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 | _src2;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RvMv,    0x0200,
      "or",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _res = _src1 | _src2;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RvRMv,    0x03,
      "or",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADC_EbRb_LINK)

#define ADC_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_B(R);              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_MbRb,    0x0200,
      "adc",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RMbRb,    0x03,
      "adc",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADC_EvRv_LINK)

#define ADC_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_V(R);              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_MvRv,    0x0200,
      "adc",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RMvRv,    0x03,
      "adc",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADC_RbEb_LINK)

#define ADC_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RbMb,    0x0200,
      "adc",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RbRMb,    0x03,
      "adc",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADC_RvEv_LINK)

#define ADC_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RvMv,    0x0200,
      "adc",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RvRMv,    0x03,
      "adc",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SBB_EbRb_LINK)

#define SBB_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_B(R);              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 - _src2 - _cf;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_MbRb,    0x0200,
      "sbb",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SBB_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RMbRb,    0x03,
      "sbb",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SBB_EvRv_LINK)

#define SBB_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_V(R);              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 - _src2 - _cf;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_MvRv,    0x0200,
      "sbb",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


#define SBB_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RMvRv,    0x03,
      "sbb",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SBB_RbEb_LINK)

#define SBB_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 - _src2 - _cf;            \
  \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RbMb,    0x0200,
      "sbb",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SBB_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RbRMb,    0x03,
      "sbb",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SBB_RvEv_LINK)

#define SBB_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 - _src2 - _cf;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RvMv,    0x0200,
      "sbb",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SBB_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RvRMv,    0x03,
      "sbb",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(AND_EbRb_LINK)

#define AND_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_B(R);              \
  _res = _src1 & _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_MbRb,    0x0200,
      "and",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _res = _src1 & _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RMbRb,    0x03,
      "and",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(AND_EvRv_LINK)

#define AND_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_V(R);              \
  _res = _src1 & _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_MvRv,    0x0200,
      "and",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _res = _src1 & _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RMvRv,    0x03,
      "and",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(AND_RbEb_LINK)

#define AND_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 & _src2;            \
  \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RbMb,    0x0200,
      "and",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _res = _src1 & _src2;            \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RbRMb,    0x03,
      "and",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(AND_RvEv_LINK)

#define AND_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 & _src2;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RvMv,    0x0200,
      "and",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _res = _src1 & _src2;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RvRMv,    0x03,
      "and",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SUB_EbRb_LINK)

#define SUB_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_B(R);              \
  _res = _src1 - _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_MbRb,    0x0200,
      "sub",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _res = _src1 - _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RMbRb,    0x03,
      "sub",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SUB_EvRv_LINK)

#define SUB_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_V(R);              \
  _res = _src1 - _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_MvRv,    0x0200,
      "sub",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _res = _src1 - _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RMvRv,    0x03,
      "sub",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SUB_RbEb_LINK)

#define SUB_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RbMb,    0x0200,
      "sub",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _res = _src1 - _src2;            \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RbRMb,    0x03,
      "sub",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SUB_RvEv_LINK)

#define SUB_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RvMv,    0x0200,
      "sub",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _res = _src1 - _src2;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RvRMv,    0x03,
      "sub",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XOR_EbRb_LINK)

#define XOR_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_B(R);              \
  _res = _src1 ^ _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_MbRb,    0x0200,
      "xor",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _res = _src1 ^ _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RMbRb,    0x03,
      "xor",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XOR_EvRv_LINK)

#define XOR_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_V(R);              \
  _res = _src1 ^ _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_MvRv,    0x0200,
      "xor",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _res = _src1 ^ _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RMvRv,    0x03,
      "xor",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XOR_RbEb_LINK)

#define XOR_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 ^ _src2;            \
  \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RbMb,    0x0200,
      "xor",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _res = _src1 ^ _src2;            \
  SET_GPR_B(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RbRMb,    0x03,
      "xor",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XOR_RvEv_LINK)

#define XOR_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 ^ _src2;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RvMv,    0x0200,
      "xor",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _res = _src1 ^ _src2;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RvRMv,    0x03,
      "xor",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMP_EbRb_LINK)

#define CMP_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_B(R);              \
  _res = _src1 - _src2;            \
  \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_MbRb,    0x0200,
      "cmp",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMP_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RMbRb,    0x03,
      "cmp",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMP_EvRv_LINK)

#define CMP_MvRv_IMPL              \
{                  \
  md_addr_t _addr = 0;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault = md_fault_none;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_V(R);              \
  _res = _src1 - _src2;            \
  \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_MvRv,    0x0200,
      "cmp",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMP_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RMvRv,    0x03,
      "cmp",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMP_RbEb_LINK)

#define CMP_RbMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RbMb,    0x0200,
      "cmp",      "%Rb,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMP_RbRMb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(R);              \
  _src2 = GPR_B(RM);              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RbRMb,    0x03,
      "cmp",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMP_RvEv_LINK)

#define CMP_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RvMv,    0x0200,
      "cmp",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMP_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RvRMv,    0x03,
      "cmp",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  // skumar

CONNECT(BOUND_RvMv_LINK)

#define BOUND_RvMv_IMPL              \
{                  \
}
  DEFINST(BOUND_RvMv,    0x0300,
      "bound",    "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)
  // <--

CONNECT(IMUL_RvEvIv_LINK)

#define IMUL_RvMvIv_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  \
  _res = IMUL_V(_src1, _src2);          \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_IMULV(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_RvMvIv,    0x0200,
      "imul",      "%Rv,%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define IMUL_RvRMvIv_IMPL            \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = IMUL_V(_src1, _src2);          \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_IMULV(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_RvRMvIv,    0x03,
      "imul",      "%Rv,%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(IMUL_RvEvIb_LINK)

#define IMUL_RvMvIb_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = IMUL_V(_src1, _src2);          \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_IMULV(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_RvMvIb,    0x0200,
      "imul",      "%Rv,%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define IMUL_RvRMvIb_IMPL            \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _res = IMUL_V(_src1, _src2);          \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_IMULV(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_RvRMvIb,    0x03,
      "imul",      "%Rv,%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP1_EbIb_LINK)

  DEFLINK(ADD_EbIb_LINK, 0x00, "add_ebib_link", 6, 0x03)

  DEFLINK(OR_EbIb_LINK, 0x01, "or_ebib_link", 6, 0x03)

  DEFLINK(ADC_EbIb_LINK, 0x02, "adc_ebib_link", 6, 0x03)

  DEFLINK(SBB_EbIb_LINK, 0x03, "sbb_ebib_link", 6, 0x03)

  DEFLINK(AND_EbIb_LINK, 0x04, "and_ebib_link", 6, 0x03)

  DEFLINK(SUB_EbIb_LINK, 0x05, "sub_ebib_link", 6, 0x03)

  DEFLINK(XOR_EbIb_LINK, 0x06, "xor_ebib_link", 6, 0x03)

  DEFLINK(CMP_EbIb_LINK, 0x07, "cmp_ebib_link", 6, 0x03)


CONNECT(ADD_EbIb_LINK)

#define ADD_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 + _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_MbIb,    0x0200,
      "add",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 + _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RMbIb,    0x03,
      "add",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(OR_EbIb_LINK)

#define OR_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 | _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_MbIb,    0x0200,
      "or",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 | _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RMbIb,    0x03,
      "or",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADC_EbIb_LINK)

#define ADC_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_MbIb,    0x0200,
      "adc",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RMbIb,    0x03,
      "adc",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SBB_EbIb_LINK)

#define SBB_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 - _src2 - _cf;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_MbIb,    0x0200,
      "sbb",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SBB_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RMbIb,    0x03,
      "sbb",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(AND_EbIb_LINK)

#define AND_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 & _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_MbIb,    0x0200,
      "and",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 & _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RMbIb,    0x03,
      "and",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SUB_EbIb_LINK)

#define SUB_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 - _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_MbIb,    0x0200,
      "sub",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 - _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RMbIb,    0x03,
      "sub",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XOR_EbIb_LINK)

#define XOR_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 ^ _src2;            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_MbIb,    0x0200,
      "xor",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RMbIb,    0x03,
      "xor",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(CMP_EbIb_LINK)

#define CMP_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 - _src2;            \
  \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_MbIb,    0x0200,
      "cmp",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMP_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RMbIb,    0x03,
      "cmp",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP1_EvIv_LINK)

  DEFLINK(ADD_EvIv_LINK, 0x00, "add_eviv_link", 6, 0x03)

  DEFLINK(OR_EvIv_LINK, 0x01, "or_eviv_link", 6, 0x03)

  DEFLINK(ADC_EvIv_LINK, 0x02, "adc_eviv_link", 6, 0x03)

  DEFLINK(SBB_EvIv_LINK, 0x03, "sbb_eviv_link", 6, 0x03)

  DEFLINK(AND_EvIv_LINK, 0x04, "and_eviv_link", 6, 0x03)

  DEFLINK(SUB_EvIv_LINK, 0x05, "sub_eviv_link", 6, 0x03)

  DEFLINK(XOR_EvIv_LINK, 0x06, "xor_eviv_link", 6, 0x03)

  DEFLINK(CMP_EvIv_LINK, 0x07, "cmp_eviv_link", 6, 0x03)


CONNECT(ADD_EvIv_LINK)

#define ADD_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  \
  _res = _src1 + _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_MvIv,    0x0200,
      "add",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = _src1 + _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RMvIv,    0x03,
      "add",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(OR_EvIv_LINK)

#define OR_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  \
  _res = _src1 | _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_MvIv,    0x0200,
      "or",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = _src1 | _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RMvIv,    0x03,
      "or",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADC_EvIv_LINK)

#define ADC_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_MvIv,    0x0200,
      "adc",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RMvIv,    0x03,
      "adc",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SBB_EvIv_LINK)

#define SBB_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 - _src2 - _cf;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_MvIv,    0x0200,
      "sbb",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SBB_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RMvIv,    0x03,
      "sbb",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(AND_EvIv_LINK)

#define AND_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  \
  _res = _src1 & _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_MvIv,    0x0200,
      "and",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = _src1 & _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RMvIv,    0x03,
      "and",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SUB_EvIv_LINK)

#define SUB_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  \
  _res = _src1 - _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_MvIv,    0x0200,
      "sub",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = _src1 - _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RMvIv,    0x03,
      "sub",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XOR_EvIv_LINK)

#define XOR_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  \
  _res = _src1 ^ _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_MvIv,    0x0200,
      "xor",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RMvIv,    0x03,
      "xor",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMP_EvIv_LINK)

#define CMP_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_V;              \
  \
  _res = _src1 - _src2;            \
  \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_MvIv,    0x0200,
      "cmp",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMP_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RMvIv,    0x03,
      "cmp",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP1_EvIb_LINK)

  DEFLINK(ADD_EvIb_LINK, 0x00, "add_evib_link", 6, 0x03)

  DEFLINK(OR_EvIb_LINK, 0x01, "or_evib_link", 6, 0x03)

  DEFLINK(ADC_EvIb_LINK, 0x02, "adc_evib_link", 6, 0x03)

  DEFLINK(SBB_EvIb_LINK, 0x03, "sbb_evib_link", 6, 0x03)

  DEFLINK(AND_EvIb_LINK, 0x04, "and_evib_link", 6, 0x03)

  DEFLINK(SUB_EvIb_LINK, 0x05, "sub_evib_link", 6, 0x03)

  DEFLINK(XOR_EvIb_LINK, 0x06, "xor_evib_link", 6, 0x03)

  DEFLINK(CMP_EvIb_LINK, 0x07, "cmp_evib_link", 6, 0x03)


CONNECT(ADD_EvIb_LINK)

#define ADD_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 + _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_MvIb,    0x0200,
      "add",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADD_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 + _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADDV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(ADD_RMvIb,    0x03,
      "add",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(OR_EvIb_LINK)

#define OR_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 | _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_MvIb,    0x0200,
      "or",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define OR_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 | _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(OR_RMvIb,    0x03,
      "or",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ADC_EvIb_LINK)

#define ADC_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 + _src2 + _cf;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_MvIb,    0x0200,
      "adc",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADC_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _cf =  !!AFLAGS(CF);            \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ADCV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(ADC_RMvIb,    0x03,
      "adc",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SBB_EvIb_LINK)

#define SBB_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _cf, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  \
  _res = _src1 - _src2 - _cf;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_MvIb,    0x0200,
      "sbb",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SBB_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _cf, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SBBV(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFINST(SBB_RMvIb,    0x03,
      "sbb",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(AND_EvIb_LINK)

#define AND_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 & _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_MvIb,    0x0200,
      "and",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define AND_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 & _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(AND_RMvIb,    0x03,
      "and",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SUB_EvIb_LINK)

#define SUB_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 - _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_MvIb,    0x0200,
      "sub",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SUB_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 - _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(SUB_RMvIb,    0x03,
      "sub",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(XOR_EvIb_LINK)

#define XOR_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 ^ _src2;            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_MvIb,    0x0200,
      "xor",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XOR_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(XOR_RMvIb,    0x03,
      "xor",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMP_EvIb_LINK)

#define CMP_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = IMM_B;              \
  \
  _res = _src1 - _src2;            \
  \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_MvIb,    0x0200,
      "cmp",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


#define CMP_RMvIb_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 - _src2;            \
  SET_AFLAGS(AFLAGS_SUBV(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFINST(CMP_RMvIb,    0x03,
      "cmp",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(TEST_EbRb_LINK)

#define TEST_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_B(R);              \
  \
  _res = _src1 & _src2;            \
  \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_MbRb,    0x0200,
      "test",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define TEST_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_RMbRb,    0x03,
      "test",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(TEST_EvRv_LINK)

#define TEST_MvRv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_V(R);              \
  _res = _src1 & _src2;            \
  \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_MvRv,    0x0200,
      "test",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define TEST_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_RMvRv,    0x03,
      "test",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


  // skumar - sykora

  // EbRb
  // -----------------------------------------------------------------------

CONNECT(XCHG_EbRb_LINK)

#define XCHG_MbRb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = GPR_B(R);              \
  \
  WRITE_BYTE(_src2, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_B(R, _src1);            \
}
  DEFINST(XCHG_MbRb,    0x0200,
      "xchg",      "%Mb,%Rb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XCHG_RMbRb_IMPL              \
{                  \
  byte_t _src1, _src2;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = GPR_B(R);              \
  SET_GPR_B(RM, _src2);            \
  SET_GPR_B(R, _src1);             \
}
  DEFINST(XCHG_RMbRb,    0x03,
      "xchg",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  // EvGv
  // -----------------------------------------------------------------------

CONNECT(XCHG_EvGv_LINK)

#define XCHG_MvRv_IMPL                                                   \
{                                                                     \
  md_addr_t _addr;                                                    \
  dword_t _src1, _src2;                                          \
  enum md_fault_type _fault;                                          \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);                      \
  _src1 = READ_V(_addr, _fault);                                      \
  if (_fault != md_fault_none)                                        \
  DECLARE_FAULT(_fault);                                            \
  \
  _src2 = GPR_V(R);                                                   \
  \
  WRITE_V(_src2, _addr, _fault);                                       \
  if (_fault != md_fault_none)                                        \
  DECLARE_FAULT(_fault);                                            \
  SET_GPR_V(R, _src1);                                            \
} 
  DEFINST(XCHG_MvRv,               0x0200,
      "xchg",                  "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define XCHG_RMvRv_IMPL                                                  \
{                                                                     \
  dword_t _src1, _src2;                                          \
  \
  _src1 = GPR_V(RM);                                                  \
  _src2 = GPR_V(R);                                                   \
  SET_GPR_V(RM, _src2);                                               \
  SET_GPR_V(R, _src1);                                                \
}
  DEFINST(XCHG_RMvRv,              0x03,
      "xchg",                  "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(MOV_EbRb_LINK)

#define MOV_MbRb_IMPL              \
{                  \
  byte_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_B(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_BYTE(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(MOV_MbRb,    0x0200,
      "mov",      "%Mb,%Rb",
      FU_INVALID,                 F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RMbRb_IMPL              \
{                  \
  byte_t _src;              \
  \
  _src = GPR_B(R);              \
  SET_GPR_B(RM, _src);            \
}
  DEFINST(MOV_RMbRb,    0x03,
      "mov",      "%Nb,%Rb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOV_EvRv_LINK)

#define MOV_MvRv_IMPL              \
{                  \
  dword_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_V(R);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(MOV_MvRv,    0x0200,
      "mov",      "%Mv,%Rv",
      FU_INVALID,                 F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RMvRv_IMPL              \
{                  \
  dword_t _src;              \
  \
  _src = GPR_V(R);              \
  SET_GPR_V(RM, _src);            \
}
  DEFINST(MOV_RMvRv,    0x03,
      "mov",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOV_RbEb_LINK)

#define MOV_RbMb_IMPL              \
{                  \
  byte_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_B(R, _src);              \
}
  DEFINST(MOV_RbMb,    0x0200,
      "mov",      "%Rb,%Mb",
      FU_INVALID,                 F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RbRMb_IMPL              \
{                  \
  byte_t _src;              \
  \
  _src = GPR_B(RM);              \
  SET_GPR_B(R, _src);              \
}
  DEFINST(MOV_RbRMb,    0x03,
      "mov",      "%Rb,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOV_RvEv_LINK)

#define MOV_RvMv_IMPL              \
{                  \
  dword_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_V(R, _src);              \
}
  DEFINST(MOV_RvMv,    0x0200,
      "mov",      "%Rv,%Mv",
      FU_INVALID,                 F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RvRMv_IMPL              \
{                  \
  dword_t _src;              \
  \
  _src = GPR_V(RM);              \
  SET_GPR_V(R, _src);              \
}
  DEFINST(MOV_RvRMv,    0x03,
      "mov",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* UCSD */
CONNECT(MOV_SwEw_LINK)

#define MOV_SwMw_IMPL              \
{                  \
  byte_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_SEG_W(R, _src);              \
}
  DEFINST(MOV_SwMw,    0x0200,          
      "mov",      "%Rw,%Mw",
      FU_INVALID,                 F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_SwRMw_IMPL              \
{                  \
  byte_t _src;              \
  \
  _src = GPR_W(RM);              \
  SET_SEG_W(R, _src);              \
}
  DEFINST(MOV_SwRMw,    0x03,
      "mov",      "%Rw,%Nw",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* UCSD */
CONNECT(MOV_EwSw_LINK)

#define MOV_MwSw_IMPL              \
{                  \
  byte_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = SEG_W(R);              \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_BYTE(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(MOV_MwSw,    0x0200,          
      "mov",      "%Rw,%Mw",
      FU_INVALID,                 F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RMwSw_IMPL              \
{                  \
  byte_t _src;              \
  \
  _src = SEG_W(R);              \
  SET_GPR_D(RM, _src);              \
}
  DEFINST(MOV_RMwSw,    0x03,
      "mov",      "%Rw,%Nw",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(POP_Ev_LINK)

  DEFLINK(POP_Ev_LINK1, 0x00, "pop_ev_link1", 6, 0x03)

CONNECT(POP_Ev_LINK1)

#define POP_Mv_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  \
  /* FIXME: side-effect before fault detection */      \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(POP_Mv,      0x0200,
      "pop",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define POP_RMv_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _sp = _sp + SIZE_V;              \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  SET_GPR_V(RM, _src);            \
}
  DEFINST(POP_RMv,    0x03,
      "pop",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP2_EbIb_LINK)

  DEFLINK(ROL_EbIb_LINK, 0x00, "rol_ebib_link", 6, 0x03)

  DEFLINK(ROR_EbIb_LINK, 0x01, "ror_ebib_link", 6, 0x03)

  DEFLINK(RCL_EbIb_LINK, 0x02, "rcl_ebib_link", 6, 0x03)

  DEFLINK(RCR_EbIb_LINK, 0x03, "rcr_ebib_link", 6, 0x03)

  DEFLINK(SHL_EbIb_LINK, 0x04, "shl_ebib_link", 6, 0x03)

  DEFLINK(SHR_EbIb_LINK, 0x05, "shr_ebib_link", 6, 0x03)

  DEFLINK(SAR_EbIb_LINK, 0x07, "sar_ebib_link", 6, 0x03)


CONNECT(ROL_EbIb_LINK)

#define ROL_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x07;            \
  \
  _res = ROL_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_MbIb,    0x0200,
      "rol",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROL_RMbIb_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = IMM_B & 0x07;            \
  _res = ROL_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_RMbIb,    0x03,
      "rol",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ROR_EbIb_LINK)

#define ROR_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x07;            \
  \
  _res = ROR_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_MbIb,    0x0200,
      "ror",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROR_RMbIb_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = IMM_B & 0x07;            \
  _res = ROR_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_RMbIb,    0x03,
      "ror",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCL_EbIb_LINK)

#define RCL_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res, _carry;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % 9;          \
  \
  _res = RCL_B(_src, _carry, _shamt);          \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_MbIb,    0x0200,
      "rcl",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCL_RMbIb_IMPL              \
{                  \
  byte_t _src, _shamt, _res, _carry;          \
  \
  _src = GPR_B(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % 9;          \
  _res = RCL_B(_src, _carry, _shamt);          \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_RMbIb,    0x03,
      "rcl",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DGPR_B(RM),
      DGPR_B(RM), DNA, DNA,
      DNA, DNA)


CONNECT(RCR_EbIb_LINK)

#define RCR_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res, _carry;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % 9;          \
  \
  _res = RCR_B(_src, _carry, _shamt);          \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_MbIb,    0x0200,
      "rcr",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCR_RMbIb_IMPL              \
{                  \
  byte_t _src, _shamt, _res, _carry;          \
  \
  _src = GPR_B(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % 9;          \
  _res = RCR_B(_src, _carry, _shamt);          \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_RMbIb,    0x03,
      "rcr",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHL_EbIb_LINK)

#define SHL_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x1f;            \
  \
  _res = SHL_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_MbIb,    0x0200,
      "shl",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHL_RMbIb_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = IMM_B & 0x1f;            \
  _res = SHL_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_RMbIb,    0x03,
      "shl",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHR_EbIb_LINK)

#define SHR_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x1f;            \
  \
  _res = SHR_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt)                \
  SET_AFLAGS(AFLAGS_SHRB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFINST(SHR_MbIb,    0x0200,
      "shr",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHR_RMbIb_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = IMM_B & 0x1f;            \
  _res = SHR_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt)                \
  SET_AFLAGS(AFLAGS_SHRB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFINST(SHR_RMbIb,    0x03,
      "shr",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SAR_EbIb_LINK)

#define SAR_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x1f;            \
  \
  _res = SAR_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_MbIb,    0x0200,
      "sar",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SAR_RMbIb_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = IMM_B & 0x1f;            \
  _res = SAR_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_RMbIb,    0x03,
      "sar",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP2_EvIb_LINK)

  DEFLINK(ROL_EvIb_LINK, 0x00, "rol_evib_link", 6, 0x03)

  DEFLINK(ROR_EvIb_LINK, 0x01, "ror_evib_link", 6, 0x03)

  DEFLINK(RCL_EvIb_LINK, 0x02, "rcl_evib_link", 6, 0x03)

  DEFLINK(RCR_EvIb_LINK, 0x03, "rcr_evib_link", 6, 0x03)

  DEFLINK(SHL_EvIb_LINK, 0x04, "shl_evib_link", 6, 0x03)

  DEFLINK(SHR_EvIb_LINK, 0x05, "shr_evib_link", 6, 0x03)

  DEFLINK(SAR_EvIb_LINK, 0x07, "sar_evib_link", 6, 0x03)


CONNECT(ROL_EvIb_LINK)

#define ROL_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & (BITSIZE_V-1);          \
  \
  _res = ROL_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_MvIb,    0x0200,
      "rol",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROL_RMvIb_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = IMM_B & (BITSIZE_V-1);          \
  _res = ROL_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_RMvIb,    0x03,
      "rol",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ROR_EvIb_LINK)

#define ROR_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & (BITSIZE_V-1);          \
  \
  _res = ROR_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_MvIb,    0x0200,
      "ror",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROR_RMvIb_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = IMM_B & (BITSIZE_V-1);          \
  _res = ROR_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_RMvIb,    0x03,
      "ror",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCL_EvIb_LINK)

#define RCL_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % (BITSIZE_V+1);        \
  \
  _res = RCL_V(_src, _carry, _shamt);          \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_MvIb,    0x0200,
      "rcl",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCL_RMvIb_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  \
  _src = GPR_V(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % (BITSIZE_V+1);        \
  _res = RCL_V(_src, _carry, _shamt);          \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_RMvIb,    0x03,
      "rcl",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCR_EvIb_LINK)

#define RCR_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % (BITSIZE_V+1);        \
  \
  _res = RCR_V(_src, _carry, _shamt);          \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_MvIb,    0x0200,
      "rcr",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCR_RMvIb_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  \
  _src = GPR_V(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (IMM_B & 0x1f) % (BITSIZE_V+1);        \
  _res = RCR_V(_src, _carry, _shamt);          \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_RMvIb,    0x03,
      "rcr",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHL_EvIb_LINK)

#define SHL_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x1f;            \
  \
  _res = SHL_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_MvIb,    0x0200,
      "shl",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHL_RMvIb_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = IMM_B & 0x1f;            \
  _res = SHL_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_RMvIb,    0x03,
      "shl",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHR_EvIb_LINK)

#define SHR_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x1f;            \
  \
  _res = SHR_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHRV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHR_MvIb,    0x0200,
      "shr",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHR_RMvIb_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = IMM_B & 0x1f;            \
  _res = SHR_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHRV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHR_RMvIb,    0x03,
      "shr",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SAR_EvIb_LINK)

#define SAR_MvIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = IMM_B & 0x1f;            \
  \
  _res = SAR_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_MvIb,    0x0200,
      "sar",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SAR_RMvIb_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = IMM_B & 0x1f;            \
  _res = SAR_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_RMvIb,    0x03,
      "sar",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOV_EbIb_LINK)

  DEFLINK(MOV_MbIb_LINK, 0x00, "mov_mbib_link", 6, 0x03)


CONNECT(MOV_MbIb_LINK)

#define MOV_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src;              \
  enum md_fault_type _fault;            \
  \
  _src = IMM_B;              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_BYTE(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(MOV_MbIb,    0x0200,
      "mov",      "%Mb,%Ib",
      FU_INVALID,                 F_MEM|F_STORE|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RMbIb_IMPL              \
{                  \
  dword_t _src;              \
  \
  _src = IMM_B;              \
  SET_GPR_B(RM, _src);            \
}
  DEFINST(MOV_RMbIb,    0x03,
      "mov",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOV_EvIv_LINK)

  DEFLINK(MOV_MvIv_LINK, 0x00, "mov_mviv_link", 6, 0x03)


CONNECT(MOV_MvIv_LINK)

#define MOV_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src;              \
  enum md_fault_type _fault;            \
  \
  _src = IMM_V;              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(MOV_MvIv,    0x0200,
      "mov",      "%Mv,%Iv",
      FU_INVALID,                 F_MEM|F_STORE|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOV_RMvIv_IMPL              \
{                  \
  dword_t _src;              \
  \
  _src = IMM_V;              \
  SET_GPR_V(RM, _src);            \
}
  DEFINST(MOV_RMvIv,    0x03,
      "mov",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP2_Eb1_LINK)

  DEFLINK(ROL_Eb1_LINK, 0x00, "rol_eb1_link", 6, 0x03)

  DEFLINK(ROR_Eb1_LINK, 0x01, "ror_eb1_link", 6, 0x03)

  DEFLINK(RCL_Eb1_LINK, 0x02, "rcl_eb1_link", 6, 0x03)

  DEFLINK(RCR_Eb1_LINK, 0x03, "rcr_eb1_link", 6, 0x03)

  DEFLINK(SHL_Eb1_LINK, 0x04, "shl_eb1_link", 6, 0x03)

  DEFLINK(SHR_Eb1_LINK, 0x05, "shr_eb1_link", 6, 0x03)

  DEFLINK(SAR_Eb1_LINK, 0x07, "sar_eb1_link", 6, 0x03)


CONNECT(ROL_Eb1_LINK)

#define ROL_Mb1_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = ROL_B(_src, 1);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ROLB(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROL_Mb1,    0x0200,
      "rol",      "%Mb,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROL_RMb1_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = ROL_B(_src, 1);            \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_ROLB(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROL_RMb1,    0x03,
      "rol",      "%Nb,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ROR_Eb1_LINK)

#define ROR_Mb1_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = ROR_B(_src, 1);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_RORB(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROR_Mb1,    0x0200,
      "ror",      "%Mb,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROR_RMb1_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = ROR_B(_src, 1);            \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_RORB(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROR_RMb1,    0x03,
      "ror",      "%Nb,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCL_Eb1_LINK)

#define RCL_Mb1_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res, _carry;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _carry = !!AFLAGS(CF);            \
  _res = RCL_B(_src, _carry, 1);          \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_RCLB(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCL_Mb1,    0x0200,
      "rcl",      "%Mb,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCL_RMb1_IMPL              \
{                  \
  byte_t _src, _res, _carry;            \
  \
  _src = GPR_B(RM);              \
  _carry = !!AFLAGS(CF);            \
  _res = RCL_B(_src, _carry, 1);          \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_RCLB(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCL_RMb1,    0x03,
      "rcl",      "%Nb,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCR_Eb1_LINK)

#define RCR_Mb1_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res, _carry;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _carry = !!AFLAGS(CF);            \
  _res = RCR_B(_src, _carry, 1);          \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_RCRB(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCR_Mb1,    0x0200,
      "rcr",      "%Mb,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCR_RMb1_IMPL              \
{                  \
  byte_t _src, _res, _carry;            \
  \
  _src = GPR_B(RM);              \
  _carry = !!AFLAGS(CF);            \
  _res = RCR_B(_src, _carry, 1);          \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_RCRB(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCR_RMb1,    0x03,
      "rcr",      "%Nb,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHL_Eb1_LINK)

#define SHL_Mb1_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = SHL_B(_src, 1);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SHLB(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHL_Mb1,    0x0200,
      "shl",      "%Mb,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHL_RMb1_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = SHL_B(_src, 1);            \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_SHLB(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHL_RMb1,    0x03,
      "shl",      "%Nb,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHR_Eb1_LINK)

#define SHR_Mb1_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = SHR_B(_src, 1);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SHRB(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHR_Mb1,    0x0200,
      "shr",      "%Mb,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHR_RMb1_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = SHR_B(_src, 1);            \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_SHRB(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHR_RMb1,    0x03,
      "shr",      "%Nb,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SAR_Eb1_LINK)

#define SAR_Mb1_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = SAR_B(_src, 1);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SARB(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SAR_Mb1,    0x0200,
      "sar",      "%Mb,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SAR_RMb1_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = SAR_B(_src, 1);            \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_SARB(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SAR_RMb1,    0x03,
      "sar",      "%Nb,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP2_Ev1_LINK)

  DEFLINK(ROL_Ev1_LINK, 0x00, "rol_ev1_link", 6, 0x03)

  DEFLINK(ROR_Ev1_LINK, 0x01, "ror_ev1_link", 6, 0x03)

  DEFLINK(RCL_Ev1_LINK, 0x02, "rcl_ev1_link", 6, 0x03)

  DEFLINK(RCR_Ev1_LINK, 0x03, "rcr_ev1_link", 6, 0x03)

  DEFLINK(SHL_Ev1_LINK, 0x04, "shl_ev1_link", 6, 0x03)

  DEFLINK(SHR_Ev1_LINK, 0x05, "shr_ev1_link", 6, 0x03)

  DEFLINK(SAR_Ev1_LINK, 0x07, "sar_ev1_link", 6, 0x03)


CONNECT(ROL_Ev1_LINK)

#define ROL_Mv1_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = ROL_V(_src, 1);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_ROLV(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROL_Mv1,    0x0200,
      "rol",      "%Mv,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROL_RMv1_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = ROL_V(_src, 1);            \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_ROLV(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROL_RMv1,    0x03,
      "rol",      "%Nv,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ROR_Ev1_LINK)

#define ROR_Mv1_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = ROR_V(_src, 1);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_RORV(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROR_Mv1,    0x0200,
      "ror",      "%Mv,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROR_RMv1_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = ROR_V(_src, 1);            \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_RORV(_res, _src, 1), CF|OF);      \
}
  DEFINST(ROR_RMv1,    0x03,
      "ror",      "%Nv,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCL_Ev1_LINK)

#define RCL_Mv1_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _carry;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _carry = !!AFLAGS(CF);            \
  _res = RCL_V(_src, _carry, 1);          \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_RCLV(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCL_Mv1,    0x0200,
      "rcl",      "%Mv,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCL_RMv1_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _carry;              \
  \
  _src = GPR_V(RM);              \
  _carry = !!AFLAGS(CF);            \
  _res = RCL_V(_src, _carry, 1);          \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_RCLV(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCL_RMv1,    0x03,
      "rcl",      "%Nv,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCR_Ev1_LINK)

#define RCR_Mv1_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _carry;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _carry = !!AFLAGS(CF);            \
  _res = RCR_V(_src, _carry, 1);          \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_RCRV(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCR_Mv1,    0x0200,
      "rcr",      "%Mv,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCR_RMv1_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _carry;              \
  \
  _src = GPR_V(RM);              \
  _carry = !!AFLAGS(CF);            \
  _res = RCR_V(_src, _carry, 1);          \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_RCRV(_res, _src, 1), CF|OF);      \
}
  DEFINST(RCR_RMv1,    0x03,
      "rcr",      "%Nv,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHL_Ev1_LINK)

#define SHL_Mv1_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = SHL_V(_src, 1);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SHLV(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHL_Mv1,    0x0200,
      "shl",      "%Mv,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHL_RMv1_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = SHL_V(_src, 1);            \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SHLV(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHL_RMv1,    0x03,
      "shl",      "%Nv,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHR_Ev1_LINK)

#define SHR_Mv1_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = SHR_V(_src, 1);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SHRV(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHR_Mv1,    0x0200,
      "shr",      "%Mv,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHR_RMv1_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = SHR_V(_src, 1);            \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SHRV(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SHR_RMv1,    0x03,
      "shr",      "%Nv,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SAR_Ev1_LINK)

#define SAR_Mv1_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = SAR_V(_src, 1);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_SARV(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SAR_Mv1,    0x0200,
      "sar",      "%Mv,1",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SAR_RMv1_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = SAR_V(_src, 1);            \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_SARV(_res, _src, 1), OF|SF|ZF|CF|PF);    \
}
  DEFINST(SAR_RMv1,    0x03,
      "sar",      "%Nv,1",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP2_EbCL_LINK)

  DEFLINK(ROL_EbCL_LINK, 0x00, "rol_ebcl_link", 6, 0x03)

  DEFLINK(ROR_EbCL_LINK, 0x01, "ror_ebcl_link", 6, 0x03)

  DEFLINK(RCL_EbCL_LINK, 0x02, "rcl_ebcl_link", 6, 0x03)

  DEFLINK(RCR_EbCL_LINK, 0x03, "rcr_ebcl_link", 6, 0x03)

  DEFLINK(SHL_EbCL_LINK, 0x04, "shl_ebcl_link", 6, 0x03)

  DEFLINK(SHR_EbCL_LINK, 0x05, "shr_ebcl_link", 6, 0x03)

  DEFLINK(SAR_EbCL_LINK, 0x07, "sar_ebcl_link", 6, 0x03)


CONNECT(ROL_EbCL_LINK)

#define ROL_MbCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x07;          \
  \
  _res = ROL_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_MbCL,    0x0200,
      "rol",      "%Mb,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROL_RMbCL_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x07;          \
  _res = ROL_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_RMbCL,    0x03,
      "rol",      "%Nb,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ROR_EbCL_LINK)

#define ROR_MbCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x07;          \
  \
  _res = ROR_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_MbCL,    0x0200,
      "ror",      "%Mb,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROR_RMbCL_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x07;          \
  _res = ROR_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_RMbCL,    0x03,
      "ror",      "%Nb,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCL_EbCL_LINK)

#define RCL_MbCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res, _carry;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % 9;        \
  \
  _res = RCL_B(_src, _carry, _shamt);          \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_MbCL,    0x0200,
      "rcl",      "%Mb,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCL_RMbCL_IMPL              \
{                  \
  byte_t _src, _shamt, _res, _carry;          \
  \
  _src = GPR_B(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % 9;        \
  _res = RCL_B(_src, _carry, _shamt);          \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_RMbCL,    0x03,
      "rcl",      "%Nb,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCR_EbCL_LINK)

#define RCR_MbCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res, _carry;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % 9;        \
  \
  _res = RCR_B(_src, _carry, _shamt);          \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_MbCL,    0x0200,
      "rcr",      "%Mb,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCR_RMbCL_IMPL              \
{                  \
  byte_t _src, _shamt, _res, _carry;          \
  \
  _src = GPR_B(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % 9;        \
  _res = RCR_B(_src, _carry, _shamt);          \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRB(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_RMbCL,    0x03,
      "rcr",      "%Nb,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHL_EbCL_LINK)

#define SHL_MbCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  _res = SHL_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_MbCL,    0x0200,
      "shl",      "%Mb,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHL_RMbCL_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  _res = SHL_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_RMbCL,    0x03,
      "shl",      "%Nb,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHR_EbCL_LINK)

#define SHR_MbCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  _res = SHR_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHRB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHR_MbCL,    0x0200,
      "shr",      "%Mb,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHR_RMbCL_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  _res = SHR_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHRB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHR_RMbCL,    0x03,
      "shr",      "%Nb,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SAR_EbCL_LINK)

#define SAR_MbCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _shamt, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  _res = SAR_B(_src, _shamt);            \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_MbCL,    0x0200,
      "sar",      "%Mb,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SAR_RMbCL_IMPL              \
{                  \
  byte_t _src, _shamt, _res;            \
  \
  _src = GPR_B(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  _res = SAR_B(_src, _shamt);            \
  \
  SET_GPR_B(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARB(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_RMbCL,    0x03,
      "sar",      "%Nb,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP2_EvCL_LINK)

  DEFLINK(ROL_EvCL_LINK, 0x00, "rol_evcl_link", 6, 0x03)

  DEFLINK(ROR_EvCL_LINK, 0x01, "ror_evcl_link", 6, 0x03)

  DEFLINK(RCL_EvCL_LINK, 0x02, "rcl_evcl_link", 6, 0x03)

  DEFLINK(RCR_EvCL_LINK, 0x03, "rcr_evcl_link", 6, 0x03)

  DEFLINK(SHL_EvCL_LINK, 0x04, "shl_evcl_link", 6, 0x03)

  DEFLINK(SHR_EvCL_LINK, 0x05, "shr_evcl_link", 6, 0x03)

  DEFLINK(SAR_EvCL_LINK, 0x07, "sar_evcl_link", 6, 0x03)


CONNECT(ROL_EvCL_LINK)

#define ROL_MvCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & (BITSIZE_V-1);        \
  \
  _res = ROL_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_MvCL,    0x0200,
      "rol",      "%Mv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROL_RMvCL_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = GPR_B(MD_REG_CL) & (BITSIZE_V-1);        \
  _res = ROL_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_ROLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROL_RMvCL,    0x03,
      "rol",      "%Nv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(ROR_EvCL_LINK)

#define ROR_MvCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & (BITSIZE_V-1);        \
  \
  _res = ROR_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_MvCL,    0x0200,
      "ror",      "%Mv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ROR_RMvCL_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = GPR_B(MD_REG_CL) & (BITSIZE_V-1);        \
  _res = ROR_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RORV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(ROR_RMvCL,    0x03,
      "ror",      "%Nv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCL_EvCL_LINK)

#define RCL_MvCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % (BITSIZE_V+1);      \
  \
  _res = RCL_V(_src, _carry, _shamt);          \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_MvCL,    0x0200,
      "rcl",      "%Mv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCL_RMvCL_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  \
  _src = GPR_V(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % (BITSIZE_V+1);      \
  _res = RCL_V(_src, _carry, _shamt);          \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCLV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCL_RMvCL,    0x03,
      "rcl",      "%Nv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(RCR_EvCL_LINK)

#define RCR_MvCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % (BITSIZE_V+1);      \
  \
  _res = RCR_V(_src, _carry, _shamt);          \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_MvCL,    0x0200,
      "rcr",      "%Mv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define RCR_RMvCL_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt, _carry;            \
  \
  _src = GPR_V(RM);              \
  _carry = !!AFLAGS(CF);            \
  _shamt = (GPR_B(MD_REG_CL) & 0x1f) % (BITSIZE_V+1);      \
  _res = RCR_V(_src, _carry, _shamt);          \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_RCRV(_res, _src, _shamt), CF|OF);  \
}
  DEFINST(RCR_RMvCL,    0x03,
      "rcr",      "%Nv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHL_EvCL_LINK)

#define SHL_MvCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  _res = SHL_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_MvCL,    0x0200,
      "shl",      "%Mv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHL_RMvCL_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  _res = SHL_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHLV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHL_RMvCL,    0x03,
      "shl",      "%Nv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHR_EvCL_LINK)

#define SHR_MvCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  _res = SHR_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHRV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHR_MvCL,    0x0200,
      "shr",      "%Mv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHR_RMvCL_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  _res = SHR_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SHRV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SHR_RMvCL,    0x03,
      "shr",      "%Nv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SAR_EvCL_LINK)

#define SAR_MvCL_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  _res = SAR_V(_src, _shamt);            \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_MvCL,    0x0200,
      "sar",      "%Mv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SAR_RMvCL_IMPL              \
{                  \
  dword_t _src, _res;              \
  byte_t _shamt;              \
  \
  _src = GPR_V(RM);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  _res = SAR_V(_src, _shamt);            \
  \
  SET_GPR_V(RM, _res);            \
  if (_shamt) SET_AFLAGS(AFLAGS_SARV(_res, _src, _shamt), OF|SF|ZF|CF|PF);\
}
  DEFINST(SAR_RMvCL,    0x03,
      "sar",      "%Nv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP3_Eb_LINK)

  DEFLINK(TEST_EbIb_LINK, 0x00, "test_ebib_link", 6, 0x03)

  DEFLINK(NOT_Eb_LINK, 0x02, "not_eb_link", 6, 0x03)

  DEFLINK(NEG_Eb_LINK, 0x03, "neg_eb_link", 6, 0x03)

  DEFLINK(MUL_Eb_LINK, 0x04, "mul_eb_link", 6, 0x03)

  DEFLINK(IMUL_Eb_LINK, 0x05, "imul_eb_link", 6, 0x03)

  DEFLINK(DIV_Eb_LINK, 0x06, "div_eb_link", 6, 0x03)

  DEFLINK(IDIV_Eb_LINK, 0x07, "idiv_eb_link", 6, 0x03)


CONNECT(TEST_EbIb_LINK)

#define TEST_MbIb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = IMM_B;              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_MbIb,    0x0200,
      "test",      "%Mb,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define TEST_RMbIb_IMPL              \
{                  \
  byte_t _src1, _src2, _res;            \
  \
  _src1 = GPR_B(RM);              \
  _src2 = IMM_B;              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_RMbIb,    0x03,
      "test",      "%Nb,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(NOT_Eb_LINK)

#define NOT_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = ~_src;              \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(NOT_Mb,      0x0200,
      "not",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define NOT_RMb_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = ~_src;              \
  \
  SET_GPR_B(RM, _res);            \
}
  DEFINST(NOT_RMb,    0x03,
      "not",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(NEG_Eb_LINK)

#define NEG_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = -_src;              \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_NEGB(_res, _src), OF|SF|ZF|AF|CF|PF);    \
}
  DEFINST(NEG_Mb,      0x0200,
      "neg",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define NEG_RMb_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = -_src;              \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_NEGB(_res, _src), OF|SF|ZF|AF|CF|PF);    \
}
  DEFINST(NEG_RMb,    0x03,
      "neg",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MUL_Eb_LINK)

#define MUL_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2;            \
  word_t _res;              \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = MUL_B(_src1, _src2);            \
  \
  SET_GPR_W(MD_REG_AX, _res);            \
  SET_AFLAGS(AFLAGS_MULB(_res), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFINST(MUL_Mb,      0x0200,
      "mul",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MUL_RMb_IMPL              \
{                  \
  byte_t _src1, _src2;            \
  word_t _res;              \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = GPR_B(RM);              \
  _res = MUL_B(_src1, _src2);            \
  SET_GPR_W(MD_REG_AX, _res);            \
  SET_AFLAGS(AFLAGS_MULB(_res), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFINST(MUL_RMb,    0x03,
      "mul",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(IMUL_Eb_LINK)

#define IMUL_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src1, _src2;            \
  word_t _res;              \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = IMUL_B(_src1, _src2);          \
  \
  SET_GPR_W(MD_REG_AX, _res);            \
  SET_AFLAGS(AFLAGS_IMULB(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_Mb,    0x0200,
      "imul",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define IMUL_RMb_IMPL              \
{                  \
  byte_t _src1, _src2;            \
  word_t _res;              \
  \
  _src1 = GPR_B(MD_REG_AL);            \
  _src2 = GPR_B(RM);              \
  _res = IMUL_B(_src1, _src2);          \
  SET_GPR_W(MD_REG_AX, _res);            \
  SET_AFLAGS(AFLAGS_IMULB(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_RMb,    0x03,
      "imul",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(DIV_Eb_LINK)

#define DIV_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  word_t _src1;              \
  byte_t _src2, _quo, _rem;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_W(MD_REG_AX);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  _quo = QUO_B(_src1, _src2);            \
  _rem = REM_B(_src1, _src2);            \
  \
  SET_GPR_B(MD_REG_AL, _quo);            \
  SET_GPR_B(MD_REG_AH, _rem);            \
  SET_AFLAGS(AFLAGS_DIVB(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(DIV_Mb,      0x0200,
      "div",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define DIV_RMb_IMPL              \
{                  \
  word_t _src1;              \
  byte_t _src2, _quo, _rem;            \
  \
  _src1 = GPR_W(MD_REG_AX);            \
  _src2 = GPR_B(RM);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  _quo = QUO_B(_src1, _src2);            \
  _rem = REM_B(_src1, _src2);            \
  \
  SET_GPR_B(MD_REG_AL, _quo);            \
  SET_GPR_B(MD_REG_AH, _rem);            \
  SET_AFLAGS(AFLAGS_DIVB(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(DIV_RMb,    0x03,
      "div",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(IDIV_Eb_LINK)

#define IDIV_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  word_t _src1;              \
  byte_t _src2, _quo, _rem;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_W(MD_REG_AX);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  _quo = IQUO_B(_src1, _src2);          \
  _rem = IREM_B(_src1, _src2);          \
  \
  SET_GPR_B(MD_REG_AL, _quo);            \
  SET_GPR_B(MD_REG_AH, _rem);            \
  SET_AFLAGS(AFLAGS_IDIVB(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(IDIV_Mb,    0x0200,
      "idiv",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define IDIV_RMb_IMPL              \
{                  \
  word_t _src1;              \
  byte_t _src2, _quo, _rem;            \
  \
  _src1 = GPR_W(MD_REG_AX);            \
  _src2 = GPR_B(RM);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  _quo = IQUO_B(_src1, _src2);          \
  _rem = IREM_B(_src1, _src2);          \
  \
  SET_GPR_B(MD_REG_AL, _quo);            \
  SET_GPR_B(MD_REG_AH, _rem);            \
  SET_AFLAGS(AFLAGS_IDIVB(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(IDIV_RMb,    0x03,
      "idiv",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP3_Ev_LINK)

  DEFLINK(TEST_EvIv_LINK, 0x00, "test_eviv_link", 6, 0x03)

  DEFLINK(NOT_Ev_LINK, 0x02, "not_ev_link", 6, 0x03)

  DEFLINK(NEG_Ev_LINK, 0x03, "neg_ev_link", 6, 0x03)

  DEFLINK(MUL_Ev_LINK, 0x04, "mul_ev_link", 6, 0x03)

  DEFLINK(IMUL_Ev_LINK, 0x05, "imul_ev_link", 6, 0x03)

  DEFLINK(DIV_Ev_LINK, 0x06, "div_ev_link", 6, 0x03)

  DEFLINK(IDIV_Ev_LINK, 0x07, "idiv_ev_link", 6, 0x03)


CONNECT(TEST_EvIv_LINK)

#define TEST_MvIv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _src2 = IMM_V;              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_MvIv,    0x0200,
      "test",      "%Mv,%Iv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define TEST_RMvIv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_V;              \
  _res = _src1 & _src2;            \
  SET_AFLAGS(AFLAGS_ALUV(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(TEST_RMvIv,    0x03,
      "test",      "%Nv,%Iv",
      FU_INVALID,                 F_ICOMP|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(NOT_Ev_LINK)

#define NOT_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = ~_src;              \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(NOT_Mv,      0x0200,
      "not",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define NOT_RMv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = ~_src;              \
  \
  SET_GPR_V(RM, _res);            \
}
  DEFINST(NOT_RMv,    0x03,
      "not",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(NEG_Ev_LINK)

#define NEG_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = -_src;              \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_NEGV(_res, _src), OF|SF|ZF|AF|CF|PF);    \
}
  DEFINST(NEG_Mv,      0x0200,
      "neg",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define NEG_RMv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = -_src;              \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_NEGV(_res, _src), OF|SF|ZF|AF|CF|PF);    \
}
  DEFINST(NEG_RMv,    0x03,
      "neg",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MUL_Ev_LINK)

#define MUL_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _reshi, _reslo;        \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _reshi = MULHI_V(_src1, _src2);          \
  _reslo = MULLO_V(_src1, _src2);          \
  \
  SET_GPR_V(MD_REG_eDX, _reshi);          \
  SET_GPR_V(MD_REG_eAX, _reslo);          \
  SET_AFLAGS(AFLAGS_MULV(_reshi), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFINST(MUL_Mv,      0x0200,
      "mul",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MUL_RMv_IMPL              \
{                  \
  dword_t _src1, _src2, _reshi, _reslo;        \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = GPR_V(RM);              \
  \
  _reshi = MULHI_V(_src1, _src2);          \
  _reslo = MULLO_V(_src1, _src2);          \
  \
  SET_GPR_V(MD_REG_eDX, _reshi);          \
  SET_GPR_V(MD_REG_eAX, _reslo);          \
  SET_AFLAGS(AFLAGS_MULV(_reshi), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFINST(MUL_RMv,    0x03,
      "mul",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(IMUL_Ev_LINK)

#define IMUL_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _reshi, _reslo;        \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _reshi = IMULHI_V(_src1, _src2);          \
  _reslo = IMULLO_V(_src1, _src2);          \
  \
  SET_GPR_V(MD_REG_eDX, _reshi);          \
  SET_GPR_V(MD_REG_eAX, _reslo);          \
  SET_AFLAGS(AFLAGS_IMULHIV(_reshi, _reslo), OF|CF/*|SF|ZF|AF|PF*/);  \
}
  DEFINST(IMUL_Mv,    0x0200,
      "imul",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define IMUL_RMv_IMPL              \
{                  \
  dword_t _src1, _src2, _reshi, _reslo;        \
  \
  _src1 = GPR_V(MD_REG_eAX);            \
  _src2 = GPR_V(RM);              \
  \
  _reshi = IMULHI_V(_src1, _src2);          \
  _reslo = IMULLO_V(_src1, _src2);          \
  \
  SET_GPR_V(MD_REG_eDX, _reshi);          \
  SET_GPR_V(MD_REG_eAX, _reslo);          \
  SET_AFLAGS(AFLAGS_IMULHIV(_reshi, _reslo), OF|CF/*|SF|ZF|AF|PF*/);  \
}
  DEFINST(IMUL_RMv,    0x03,
      "imul",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(DIV_Ev_LINK)

#define DIV_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1hi, _src1lo, _src2, _quo=0, _rem=0;        \
  enum md_fault_type _fault;            \
  \
  _src1hi = GPR_V(MD_REG_eDX);          \
  _src1lo = GPR_V(MD_REG_eAX);          \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none) {        \
  DECLARE_FAULT(_fault);            \
  } \
  if (_src2 == 0) {             \
  /*DECLARE_FAULT(md_fault_div0);*/          \
    warn("div0 fault"); \
  } else { \
  _quo = QUO_V(_src1hi, _src1lo, _src2);        \
  _rem = REM_V(_src1hi, _src1lo, _src2);        \
  } \
  SET_GPR_V(MD_REG_eAX, _quo);          \
  SET_GPR_V(MD_REG_eDX, _rem);          \
  SET_AFLAGS(AFLAGS_DIVV(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(DIV_Mv,      0x0200,
      "div",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define DIV_RMv_IMPL              \
{                  \
  dword_t _src1hi, _src1lo, _src2, _quo, _rem;        \
  \
  _src1hi = GPR_V(MD_REG_eDX);          \
  _src1lo = GPR_V(MD_REG_eAX);          \
  _src2 = GPR_V(RM);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _quo = QUO_V(_src1hi, _src1lo, _src2);        \
  _rem = REM_V(_src1hi, _src1lo, _src2);        \
  \
  SET_GPR_V(MD_REG_eAX, _quo);          \
  SET_GPR_V(MD_REG_eDX, _rem);          \
  SET_AFLAGS(AFLAGS_DIVV(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(DIV_RMv,    0x03,
      "div",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(IDIV_Ev_LINK)

#define IDIV_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1hi, _src1lo, _src2, _quo, _rem;        \
  enum md_fault_type _fault;            \
  \
  _src1hi = GPR_V(MD_REG_eDX);          \
  _src1lo = GPR_V(MD_REG_eAX);          \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _quo = IQUO_V(_src1hi, _src1lo, _src2);        \
  _rem = IREM_V(_src1hi, _src1lo, _src2);        \
  \
  SET_GPR_V(MD_REG_eAX, _quo);          \
  SET_GPR_V(MD_REG_eDX, _rem);          \
  SET_AFLAGS(AFLAGS_IDIVV(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(IDIV_Mv,    0x0200,
      "idiv",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define IDIV_RMv_IMPL              \
{                  \
  sdword_t _src1hi, _src1lo, _src2, _quo, _rem;        \
  \
  _src1hi = GPR_V(MD_REG_eDX);          \
  _src1lo = GPR_V(MD_REG_eAX);          \
  _src2 = GPR_V(RM);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _quo = IQUO_V(_src1hi, _src1lo, _src2);        \
  _rem = IREM_V(_src1hi, _src1lo, _src2);        \
  \
  SET_GPR_V(MD_REG_eAX, _quo);          \
  SET_GPR_V(MD_REG_eDX, _rem);          \
  SET_AFLAGS(AFLAGS_IDIVV(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFINST(IDIV_RMv,    0x03,
      "idiv",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP4_Eb_LINK)

  DEFLINK(INC_Eb_LINK, 0x00, "inc_eb_link", 6, 0x03)

  DEFLINK(DEC_Eb_LINK, 0x01, "dec_eb_link", 6, 0x03)


CONNECT(INC_Eb_LINK)

#define INC_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src + 1;              \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_INCB(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(INC_Mb,      0x0200,
      "inc",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define INC_RMb_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = _src + 1;              \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_INCB(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(INC_RMb,    0x03,
      "inc",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(DEC_Eb_LINK)

#define DEC_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src - 1;              \
  \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_DECB(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(DEC_Mb,      0x0200,
      "dec",      "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define DEC_RMb_IMPL              \
{                  \
  byte_t _src, _res;              \
  \
  _src = GPR_B(RM);              \
  _res = _src - 1;              \
  \
  SET_GPR_B(RM, _res);            \
  SET_AFLAGS(AFLAGS_DECB(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(DEC_RMb,    0x03,
      "dec",      "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP5_Ev_LINK)

  DEFLINK(INC_Ev_LINK, 0x00, "inc_ev_link", 6, 0x03)

  DEFLINK(DEC_Ev_LINK, 0x01, "dec_ev_link", 6, 0x03)

  DEFLINK(CALLN_Ev_LINK, 0x02, "calln_ev_link", 6, 0x03)

  DEFLINK(CALLF_Mv_LINK, 0x03, "callf_mv_link", 6, 0x03)

  DEFLINK(JMPN_Ev_LINK, 0x04, "jmpn_ev_link", 6, 0x03)

  DEFLINK(JMPF_Mv_LINK, 0x05, "jmpf_mv_link", 6, 0x03) 

  DEFLINK(PUSH_Ev_LINK, 0x06, "push_ev_link", 6, 0x03)


CONNECT(CALLN_Ev_LINK)

#define CALLN_Mv_IMPL              \
{                  \
  dword_t _sp;                \
  md_addr_t _addr, _npc, _tpc;          \
  enum md_fault_type _fault;            \
  \
  /* UCSD FIXME: not sure about the call *%gs system call interface */\
  if ( SEG_INDEX == MD_REG_GS && DISP == 0x10)                        \
  {                                                                   \
    SYSCALL(Mop->fetch.inst);              \
  }                                                                   \
  else                \
  {                                                                   \
    _npc = NPC;              \
    _sp = GPR_S(MD_REG_eSP);          \
    _sp = _sp - SIZE_V;            \
    \
    _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
    WRITE_V(_npc, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    \
    _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
    \
    _tpc = READ_V(_addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    \
    SET_GPR_S(MD_REG_eSP, _sp);          \
    SET_TPC(_tpc);              \
    SET_NPC(_tpc);              \
    UPDATE_CALLGRAPH_CALL();                \
  }                                                                   \
}
  DEFINST(CALLN_Mv,    0x0200,
      "call",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_CTRL|F_UNCOND|F_UCODE|F_CALL,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CALLN_RMv_IMPL              \
{                  \
  dword_t _sp;                \
  md_addr_t _addr, _npc, _tpc;          \
  enum md_fault_type _fault;            \
  \
  _npc = NPC;                \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_npc, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _tpc = GPR_V(RM);              \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
  SET_TPC(_tpc);              \
  SET_NPC(_tpc);              \
  UPDATE_CALLGRAPH_CALL();              \
}
  DEFINST(CALLN_RMv,    0x03,
      "call",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_CTRL|F_UNCOND|F_UCODE|F_CALL,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(CALLF_Mv_LINK)

#define CALLF_Mv_IMPL              \
{                  \
  dword_t _sp;                \
  md_addr_t _addr, _npc, _tpc;          \
  enum md_fault_type _fault;            \
  \
  /* UCSD FIXME: not sure about the call *%gs system call interface */\
  if ( SEG_INDEX == MD_REG_GS && DISP == 0x10)                        \
  {                                                                   \
    SYSCALL(Mop->fetch.inst);              \
  }                                                                   \
  else                \
  {                                                                   \
    _npc = NPC;              \
    _sp = GPR_S(MD_REG_eSP);          \
    _sp = _sp - SIZE_V;            \
    \
    _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
    WRITE_V(_npc, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    \
    _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
    \
    _tpc = READ_V(_addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    \
    SET_GPR_S(MD_REG_eSP, _sp);          \
    SET_TPC(_tpc);              \
    SET_NPC(_tpc);              \
    UPDATE_CALLGRAPH_CALL();                \
  }                                                                   \
}
  DEFINST(CALLF_Mv,    0x0200,
      "call",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_CTRL|F_UNCOND|F_UCODE|F_CALL,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(JMPN_Ev_LINK)

#define JMPN_Mv_IMPL              \
{                  \
  md_addr_t _addr, _tpc;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _tpc = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_TPC(_tpc);              \
  SET_NPC(_tpc);              \
}
  DEFINST(JMPN_Mv,    0x0200,
      "jmp",      "%Mv",
      FU_INVALID,                 F_CTRL|F_UNCOND|F_INDIRJMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define JMPN_RMv_IMPL              \
{                  \
  md_addr_t _tpc;              \
  \
  _tpc = GPR_V(RM);              \
  \
  SET_TPC(_tpc);              \
  SET_NPC(_tpc);              \
}
  DEFINST(JMPN_RMv,    0x03,
      "jmp",      "%Nv",
      FU_INVALID,                 F_CTRL|F_UNCOND|F_INDIRJMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(JMPF_Mv_LINK)

#define JMPF_Mv_IMPL              \
{                  \
  md_addr_t _addr, _tpc;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  					\
  _tpc = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_TPC(_tpc);              \
  SET_NPC(_tpc);              \
  thread->regs.regs_S.w[0]= _tpc;  \
}	
  DEFINST(JMPF_Mv,    0x03,
      "jmp",      "%Mv",
      FU_INVALID,                 F_CTRL|F_UNCOND|F_INDIRJMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(INC_Ev_LINK)

#define INC_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src + 1;              \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_INCV(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(INC_Mv,      0x0200,
      "inc",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define INC_RMv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = _src + 1;              \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_INCV(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(INC_RMv,    0x03,
      "inc",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(DEC_Ev_LINK)

#define DEC_Mv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src - 1;              \
  \
  WRITE_V(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_DECV(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(DEC_Mv,      0x0200,
      "dec",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define DEC_RMv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  _res = _src - 1;              \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_DECV(_res), OF|SF|ZF|AF|PF);      \
}
  DEFINST(DEC_RMv,    0x03,
      "dec",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(PUSH_Ev_LINK)

#define PUSH_Mv_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(PUSH_Mv,    0x0200,
      "push",      "%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define PUSH_RMv_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_V(RM);              \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_V;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
}
  DEFINST(PUSH_RMv,    0x03,
      "push",      "%Nv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(TWOESC_LINK)

  /* DEFLINK(GRP6_LINK, 0x00, 3, 0x07) */

  /* DEFLINK(GRP7_LINK, 0x01, 3, 0x07) */

  /* FIXME: TODO 0x02: LAR_GvEw */

  /* FIXME: TODO 0x03: LSL_GvEw */

  /* FIXME: TODO 0x06: CLTS: F_NOMOD */

  /* FIXME: TODO 0x08: INVD: F_NOMOD */

  /* FIXME: TODO 0x09: WBINVD: F_NOMOD */

  /* FIXME: TODO 0x0b: UD2: F_NOMOD */

  /* FIXME: TODO 0x20: MOV_RdCd */

  /* FIXME: TODO 0x21: MOV_RdDd */

  /* FIXME: TODO 0x22: MOV_CdRd */

  /* FIXME: TODO 0x23: MOV_DdRd */

  /* FIXME: TODO 0x30: WRMSR: F_NOMOD */

  // cristiano

/*#define STMXCSR_Mw_IMPL              \
{                  \
}
DEFINST(STMXCSR_Mw,    0xae,
"stmxcsr",    "%Mw",
FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
DNA,
DNA, DNA, DNA,
DNA, DNA)

*/
  // skumar
#define RDTSC_IMPL              \
{                  \
  SET_GPR_V(MD_REG_eAX, timestamp[thread->id] & 0xffffffff);      \
  SET_GPR_V(MD_REG_eDX, (timestamp[thread->id] >> 32) & 0xffffffff);    \
  timestamp[thread->id] += 100;            \
}
  DEFINST(RDTSC,    0x31,
      "rdtsc",      "%Rv, %Rv",
      FU_INVALID,                F_NOMOD|F_UCODE/*GL*/ /*TODO: F_PRIV ? */,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0x32: RDMSR: F_NOMOD */

  /* FIXME: TODO 0x33: RDPMC: F_NOMOD */

  /* FIXME: TODO 0x34: SYSENTER */

  /* FIXME: TODO 0x35: SYSEXIT */


#define SYSENTER_IMPL              \
{                  \
  SET_GPR_V(MD_REG_eAX, timestamp[thread->id] & 0xffffffff);      \
  SET_GPR_V(MD_REG_eDX, (timestamp[thread->id] >> 32) & 0xffffffff);    \
  timestamp[thread->id] += 100;            \
}
  DEFINST(SYSENTER,    0x34,
      "sysenter",      "%Ib",
      FU_INVALID,                F_TRAP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


  DEFLINK(CMOV_RvEv_LINK, 0x4f40, "cmov_rvev_link", 6, 0x03)

#define JCC_Jv_IMPL              \
{                  \
  dword_t _aflags;              \
  \
  SET_TPC(NPC + IMM_V);            \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  if (CC_EVAL(CC, _aflags))            \
  SET_NPC(NPC + IMM_V);            \
}
  DEFINST(JCC_Jv,      0x8f80,
      "j%cc",      "%Jv",
      FU_INVALID,                 F_CTRL|F_COND|F_DIRJMP|F_NOMOD|F_IMMV|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(SETCC_Eb_LINK, 0x9f90, "setcc_eb_link", 6, 0x03)

#define PUSHFS_IMPL PUSH_NONSENSE_IMPL
  DEFINST(PUSHFS,    0xa0,
      "push fs",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define POPFS_IMPL POP_NONSENSE_IMPL
  DEFINST(POPFS,    0xa1,
      "pop fs",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* Original code from below.  Rewritten to avoid multi-byte char.
     SET_GPR_V(MD_REG_eBX, 'uneG' );                                  \
     SET_GPR_V(MD_REG_eDX, 'Ieni' );                                  \
     SET_GPR_V(MD_REG_eCX, 'letn' );                                  \
   */

#define CPUID_IMPL               \
{                   \
  dword_t _res = 1;                                                     \
  dword_t _tmp; \
  SET_GPR_V(MD_REG_eAX, _res);  /* pretend to be GenuineIntel */ \
  _tmp = (('u'<<24)|('n'<<16)|('e'<<8)|('G')); \
  SET_GPR_V(MD_REG_eBX, _tmp );                 \
  _tmp = (('I'<<24)|('e'<<16)|('n'<<8)|('i')); \
  SET_GPR_V(MD_REG_eDX, _tmp );                 \
  _tmp = (('l'<<24)|('e'<<16)|('t'<<8)|('n')); \
  SET_GPR_V(MD_REG_eCX, _tmp );                 \
}

  DEFINST(CPUID,    0xa2,
      "cpuid",    "",
      FU_INVALID,                 F_ICOMP|F_UCODE|F_NOMOD,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(BT_EvRv_LINK, 0xa3, "bt_evrv_link", 6, 0x03)

  DEFLINK(SHLD_EvRvIb_LINK, 0xa4, "shld_evrvib_link", 6, 0x03)

  DEFLINK(SHLD_EvRvCL_LINK, 0xa5, "shld_evrvcl_link", 6, 0x03)

  /* UCSD */ 
#define PUSHGS_IMPL              \
{                  \
  dword_t _src, _sp;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = SEG_W(MD_REG_GS);            \
  _sp = GPR_S(MD_REG_eSP);            \
  _sp = _sp - SIZE_W;              \
  \
  _addr = AGEN_S(SEG_SS, _sp, 0, 0, 0);        \
  WRITE_V(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_GPR_S(MD_REG_eSP, _sp);            \
} 
  DEFINST(PUSHGS,    0xa8,
      "push gs",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define POPGS_IMPL POP_NONSENSE_IMPL
  DEFINST(POPGS,    0xa9,
      "pop gs",      "",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO 0xaa: RSM: F_NOMOD */

  DEFLINK(BTS_EvRv_LINK, 0xab, "bts_evrv_link", 6, 0x03)

  DEFLINK(SHRD_EvRvIb_LINK, 0xac, "shrd_evrvib_link", 6, 0x03)

  DEFLINK(SHRD_EvRvCL_LINK, 0xad, "shrd_evrvcl_link", 6, 0x03)

  DEFLINK(IMUL_RvEv_LINK, 0xaf, "imul_evrv_link", 6, 0x03)

  /* FIXME: TODO 0xb0: CMPXCHG_EbRb */

  DEFLINK(CMPXCHG_EvRv_LINK, 0xb1, "cmpxchg_evrv_link", 6, 0x03)

  DEFLINK(CMPXCHG8B_EvRv_LINK, 0xc7, "cmpxchg8b_evrv_link", 6, 0x03)

  DEFLINK(FENCE_LINK, 0xae, "fence", 7, 0x03)

  /* FIXME: TODO 0xb2: LSS_Mp */

  DEFLINK(BTR_EvRv_LINK, 0xb3, "btr_evrv_link", 6, 0x03)

  /* FIXME: TODO 0xb4: LFS_Mp */

  /* FIXME: TODO 0xb5: LGS_Mp */

  DEFLINK(MOVZX_RvEb_LINK, 0xb6, "movzx_rveb_link", 6, 0x03)

  DEFLINK(MOVZX_RvEw_LINK, 0xb7, "movzx_rvew_link", 6, 0x03)

  DEFLINK(GRP8_EvIb_LINK, 0xba, "grp8_evib_link", 3, 0x07)

  DEFLINK(BTC_EvRv_LINK, 0xbb, "btc_evrv_link", 6, 0x03)

  DEFLINK(BSF_RvEv_LINK, 0xbc, "bsf_rvev_link", 6, 0x03)

  DEFLINK(BSR_RvEv_LINK, 0xbd, "bsr_rvev_link", 6, 0x03)

  DEFLINK(MOVSX_RvEb_LINK, 0xbe, "movsx_rveb_link", 6, 0x03)

  DEFLINK(MOVSX_RvEw_LINK, 0xbf, "movsx_rvew_link", 6, 0x03)

  /* FIXME: TODO 0xc0: XADD_EbRb */

  DEFLINK(XADD_EvRv_LINK, 0xc1, "xadd_evrv_link", 6, 0x03)

#define BSWAP_ROd_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_D(RO);              \
  _res = BSWAP(_src);              \
  SET_GPR_D(RO, _res);            \
}
  DEFINST(BSWAP_ROd,    0xcfc8,
      "bswap",    "%Qd",
      FU_INVALID,                 F_ICOMP|F_NOMOD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(CMOV_RvEv_LINK)

#define CMOV_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _aflags, _res;          \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(md_fault_none)          \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  \
  _res = CC_EVAL(CC, _aflags) ? _src2 : _src1;      \
  \
  SET_GPR_V(R, _res);              \
}
  DEFINST(CMOV_RvMv,    0x0200,
      "cmov%cc",    "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define CMOV_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _aflags, _res;          \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  \
  _res = CC_EVAL(CC, _aflags) ? _src2 : _src1;      \
  \
  SET_GPR_V(R, _res);              \
}
  DEFINST(CMOV_RvRMv,    0x03,
      "cmov%cc",    "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SETCC_Eb_LINK)

#define SETCC_Mb_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _aflags;              \
  byte_t _res;              \
  enum md_fault_type _fault;            \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  \
  _res = CC_EVAL(CC, _aflags) ? 1 : 0;        \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_BYTE(_res, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(md_fault_none);          \
}
  DEFINST(SETCC_Mb,    0x0200,
      "set%cc",    "%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SETCC_RMb_IMPL              \
{                  \
  dword_t _aflags;              \
  byte_t _res;              \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  \
  _res = CC_EVAL(CC, _aflags) ? 1 : 0;        \
  \
  SET_GPR_B(RM, _res);            \
}
  DEFINST(SETCC_RMb,    0x03,
      "set%cc",    "%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BT_EvRv_LINK)

#define BT_MvRv_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1, _src2;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = GPR_V(R);              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BT_MvRv,    0x0200,
      "bt",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BT_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BT_RMvRv,    0x03,
      "bt",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHLD_EvRvIb_LINK)

#define SHLD_MvRvIb_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _shamt, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_V(R);              \
  _shamt = IMM_B & 0x1f;            \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_V-_shamt));  \
    \
    WRITE_V(_res, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    SET_AFLAGS(AFLAGS_SHLDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHLD_MvRvIb,    0x0200,
      "shld",      "%Mv,%Rv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHLD_RMvRvIb_IMPL            \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _shamt = IMM_B & 0x1f;            \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_V-_shamt));  \
    \
    SET_GPR_V(RM, _res);            \
    SET_AFLAGS(AFLAGS_SHLDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHLD_RMvRvIb,    0x03,
      "shld",      "%Nv,%Rv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHLD_EvRvCL_LINK)

#define SHLD_MvRvCL_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _shamt, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_V(R);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_V-_shamt));  \
    \
    WRITE_V(_res, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    SET_AFLAGS(AFLAGS_SHLDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHLD_MvRvCL,    0x0200,
      "shld",      "%Mv,%Rv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHLD_RMvRvCL_IMPL            \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_V-_shamt));  \
    \
    SET_GPR_V(RM, _res);            \
    SET_AFLAGS(AFLAGS_SHLDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHLD_RMvRvCL,    0x03,
      "shld",      "%Nv,%Rv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHRD_EvRvIb_LINK)

#define SHRD_MvRvIb_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _shamt, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_V(R);              \
  _shamt = IMM_B & 0x1f;            \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src2 << (BITSIZE_V - _shamt)) | (_src1 >> _shamt);  \
    \
    WRITE_V(_res, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    SET_AFLAGS(AFLAGS_SHRDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHRD_MvRvIb,    0x0200,
      "shrd",      "%Mv,%Rv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHRD_RMvRvIb_IMPL            \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _shamt = IMM_B & 0x1f;            \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src2 << (BITSIZE_V - _shamt)) | (_src1 >> _shamt);  \
    \
    SET_GPR_V(RM, _res);            \
    SET_AFLAGS(AFLAGS_SHRDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHRD_RMvRvIb,    0x03,
      "shrd",      "%Nv,%Rv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(SHRD_EvRvCL_LINK)

#define SHRD_MvRvCL_IMPL            \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _shamt, _res;          \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = GPR_V(R);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src2 << (BITSIZE_V - _shamt)) | (_src1 >> _shamt);  \
    \
    WRITE_V(_res, _addr, _fault);          \
    if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);          \
    SET_AFLAGS(AFLAGS_SHRDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHRD_MvRvCL,    0x0200,
      "shrd",      "%Mv,%Rv,CL",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHRD_RMvRvCL_IMPL            \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  _shamt = GPR_B(MD_REG_CL) & 0x1f;          \
  \
  if (_shamt > 0 && _shamt < BITSIZE_V)        \
  {                  \
    _res = (_src2 << (BITSIZE_V - _shamt)) | (_src1 >> _shamt);  \
    \
    SET_GPR_V(RM, _res);            \
    SET_AFLAGS(AFLAGS_SHRDV(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFINST(SHRD_RMvRvCL,    0x03,
      "shrd",      "%Nv,%Rv,CL",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BTS_EvRv_LINK)

#define BTS_MvRv_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = GPR_V(R);              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  WRITE_V(_res, _bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTS_MvRv,    0x0200,
      "bts",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BTS_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTS_RMvRv,    0x03,
      "bts",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(IMUL_RvEv_LINK)

#define IMUL_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _src1 = GPR_V(R);              \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 * _src2;            \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_IMULV(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_RvMv,    0x0200,
      "imul",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define IMUL_RvRMv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(R);              \
  _src2 = GPR_V(RM);              \
  _res = _src1 * _src2;            \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_IMULV(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFINST(IMUL_RvRMv,    0x03,
      "imul",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BTR_EvRv_LINK)

#define BTR_MvRv_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = GPR_V(R);              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  WRITE_V(_res, _bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTR_MvRv,    0x0200,
      "btr",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BTR_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTR_RMvRv,    0x03,
      "btr",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BTC_EvRv_LINK)

#define BTC_MvRv_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1, _src2, _res;            \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = GPR_V(R);              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  WRITE_V(_res, _bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTC_MvRv,    0x0200,
      "btc",      "%Mv,%Rv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BTC_RMvRv_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_V(RM);              \
  _src2 = GPR_V(R);              \
  \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTC_RMvRv,    0x03,
      "btc",      "%Nv,%Rv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOVZX_RvEb_LINK)

#define MOVZX_RvMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src;              \
  dword_t _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = MOVZX_VB(_src);            \
  \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVZX_RvMb,    0x0200,
      "movzx",    "%Rv,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOVZX_RvRMb_IMPL            \
{                  \
  byte_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_B(RM);              \
  _res = MOVZX_VB(_src);            \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVZX_RvRMb,    0x03,
      "movzx",    "%Rv,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOVZX_RvEw_LINK)

#define MOVZX_RvMw_IMPL              \
{                  \
  md_addr_t _addr;              \
  word_t _src;              \
  dword_t _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = MOVZX_VW(_src);            \
  \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVZX_RvMw,    0x0200,
      "movzx",    "%Rv,%Mw",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOVZX_RvRMw_IMPL            \
{                  \
  word_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_W(RM);              \
  _res = MOVZX_VW(_src);            \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVZX_RvRMw,    0x03,
      "movzx",    "%Rv,%Nw",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRP8_EvIb_LINK)

  DEFLINK(BT_EvIb_LINK, 0x04, "bt_evib_link", 6, 0x03)

  DEFLINK(BTS_EvIb_LINK, 0x05, "bts_evib_link", 6, 0x03)

  DEFLINK(BTR_EvIb_LINK, 0x06, "btr_evib_link", 6, 0x03)

  DEFLINK(BTC_EvIb_LINK, 0x07, "btc_evib_link", 6, 0x03)


CONNECT(BT_EvIb_LINK)

#define BT_MvIb_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1;              \
  byte_t _src2;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = IMM_B;              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BT_MvIb,    0x0200,
      "bt",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BT_RMvIb_IMPL              \
{                  \
  dword_t _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BT_RMvIb,    0x03,
      "bt",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BTS_EvIb_LINK)

#define BTS_MvIb_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1, _res;              \
  byte_t _src2;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = IMM_B;              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  WRITE_V(_res, _bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTS_MvIb,    0x0200,
      "bts",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BTS_RMvIb_IMPL              \
{                  \
  dword_t _src1, _res;              \
  byte_t _src2;              \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTS_RMvIb,    0x03,
      "bts",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BTR_EvIb_LINK)

#define BTR_MvIb_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1, _res;              \
  byte_t _src2;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = IMM_B;              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  WRITE_V(_res, _bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTR_MvIb,    0x0200,
      "btr",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BTR_RMvIb_IMPL              \
{                  \
  dword_t _src1, _res;              \
  byte_t _src2;              \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTR_RMvIb,    0x03,
      "btr",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BTC_EvIb_LINK)

#define BTC_MvIb_IMPL              \
{                  \
  md_addr_t _addr, _bitaddr;            \
  dword_t _src1, _res;              \
  byte_t _src2;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = IMM_B;              \
  _bitaddr = _addr + ((_src2 >> LOGBITSIZE_V) << LOGSIZE_V);    \
  _src1 = READ_V(_bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  WRITE_V(_res, _bitaddr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTC_MvIb,    0x0200,
      "btc",      "%Mv,%Ib",
      FU_INVALID,                 F_ICOMP|F_MEM|F_STORE|F_LOAD|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BTC_RMvIb_IMPL              \
{                  \
  dword_t _src1, _res;              \
  byte_t _src2;              \
  \
  _src1 = GPR_V(RM);              \
  _src2 = IMM_B;              \
  \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_V)-1));    \
  \
  SET_GPR_V(RM, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_V)-1)), CF);  \
}
  DEFINST(BTC_RMvIb,    0x03,
      "btc",      "%Nv,%Ib",
      FU_INVALID,                 F_ICOMP|F_IMMB|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BSF_RvEv_LINK)

#define BSF_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BSF_V(_src);              \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_BSFV(_src), ZF);          \
}
  DEFINST(BSF_RvMv,    0x0200,
      "bsf",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BSF_RvRMv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  \
  _res = BSF_V(_src);              \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_BSFV(_src), ZF);          \
}
  DEFINST(BSF_RvRMv,    0x03,
      "bsf",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(BSR_RvEv_LINK)

#define BSR_RvMv_IMPL              \
{                  \
  md_addr_t _addr;              \
  dword_t _src, _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_V(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = BSR_V(_src);              \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_BSRV(_src), ZF);          \
}
  DEFINST(BSR_RvMv,    0x0200,
      "bsr",      "%Rv,%Mv",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define BSR_RvRMv_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_V(RM);              \
  \
  _res = BSR_V(_src);              \
  \
  SET_GPR_V(R, _res);              \
  SET_AFLAGS(AFLAGS_BSRV(_src), ZF);          \
}
  DEFINST(BSR_RvRMv,    0x03,
      "bsr",      "%Rv,%Nv",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOVSX_RvEb_LINK)

#define MOVSX_RvMb_IMPL              \
{                  \
  md_addr_t _addr;              \
  byte_t _src;              \
  dword_t _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = MOVSX_VB(_src);            \
  \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVSX_RvMb,    0x0200,
      "movsx",    "%Rv,%Mb",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOVSX_RvRMb_IMPL            \
{                  \
  byte_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_B(RM);              \
  _res = MOVSX_VB(_src);            \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVSX_RvRMb,    0x03,
      "movsx",    "%Rv,%Nb",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(MOVSX_RvEw_LINK)

#define MOVSX_RvMw_IMPL              \
{                  \
  md_addr_t _addr;              \
  word_t _src;              \
  dword_t _res;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = MOVSX_VW(_src);            \
  \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVSX_RvMw,    0x0200,
      "movsx",    "%Rv,%Mw",
      FU_INVALID,                 F_ICOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define MOVSX_RvRMw_IMPL            \
{                  \
  word_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_W(RM);              \
  _res = MOVSX_VW(_src);            \
  SET_GPR_V(R, _res);              \
}
  DEFINST(MOVSX_RvRMw,    0x03,
      "movsx",    "%Rv,%Nw",
      FU_INVALID,                 F_ICOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRPD8_LINK)

  DEFLINK(FADD_Es_LINK, 0x00, "fadd_es_link", 6, 0x03)

  DEFLINK(FMUL_Es_LINK, 0x01, "fmul_es_link", 6, 0x03)

  DEFLINK(FCOM_Es_LINK, 0x02, "fcom_es_link", 6, 0x03)

  DEFLINK(FCOMP_Es_LINK, 0x03, "fcomp_es_link", 6, 0x03)

  DEFLINK(FSUB_Es_LINK, 0x04, "fsub_es_link", 6, 0x03)

  DEFLINK(FSUBR_Es_LINK, 0x05, "fsubr_es_link", 6, 0x03)

  DEFLINK(FDIV_Es_LINK, 0x06, "fdiv_es_link", 6, 0x03)

  DEFLINK(FDIVR_Es_LINK, 0x07, "fdivr_es_link", 6, 0x03)


CONNECT(FADD_Es_LINK)

#define FADD_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FADD_Ms,    0x0200,
      "fadd",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FADD_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  _res = _src1 + _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FADD_ST0STi,    0x03,
      "fadd",      "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FMUL_Es_LINK)

#define FMUL_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 * _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FMUL_Ms,    0x0200,
      "fmul",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FMUL_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  _res = _src1 * _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FMUL_ST0STi,    0x03,
      "fmul",      "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FCOM_Es_LINK)

#define FCOM_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
}
  DEFINST(FCOM_Ms,    0x0200,
      "fcom",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCOM_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
}
  DEFINST(FCOM_ST0STi,    0x03,
      "fcom",      "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FCOMP_Es_LINK)

#define FCOMP_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
}
  DEFINST(FCOMP_Ms,    0x0200,
      "fcomp",    "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCOMP_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
}
  DEFINST(FCOMP_ST0STi,    0x03,
      "fcomp",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSUB_Es_LINK)

#define FSUB_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSUB_Ms,    0x0200,
      "fsub",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSUB_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  _res = _src1 - _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSUB_ST0STi,    0x03,
      "fsub",      "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSUBR_Es_LINK)

#define FSUBR_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src2 - _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSUBR_Ms,    0x0200,
      "fsubr",    "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSUBR_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  _res = _src2 - _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSUBR_ST0STi,    0x03,
      "fsubr",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FDIV_Es_LINK)

#define FDIV_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src1 / _src2;            \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FDIV_Ms,    0x0200,
      "fdiv",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FDIV_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src1 / _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FDIV_ST0STi,    0x03,
      "fdiv",      "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FDIVR_Es_LINK)

#define FDIVR_Ms_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src1 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src2 / _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FDIVR_Ms,    0x0200,
      "fdivr",    "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FDIVR_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  if (_src1 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src2 / _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FDIVR_ST0STi,    0x03,
      "fdivr",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRPD9_LINK)

  DEFLINK(FLD_Es_LINK, 0x00, "fld_es_link", 6, 0x03)

  DEFLINK(FXCH_ST0STi_LINK, 0x01, "fxch_stosti_link", 6, 0x03)

  DEFLINK(FST_Ms_LINK, 0x02, "fst_ms_link", 6, 0x03)

  DEFLINK(FSTP_Ms_LINK, 0x03, "fstp_ms_link", 6, 0x03)

  DEFLINK(FLDENV_Mx_LINK, 0x04, "fldenv_mx_link", 6, 0x03)

  DEFLINK(FLDCW_Mw_LINK, 0x05, "fldcw_mw_link", 6, 0x03)

  DEFLINK(FSTENV_Mx_LINK, 0x06, "fstenv_mx_link", 6, 0x03)

  DEFLINK(FSTCW_Mw_LINK, 0x07, "fstcw_mw_link", 6, 0x03)


CONNECT(FLD_Es_LINK)

#define FLD_Ms_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _src);            \
}
  DEFINST(FLD_Ms,      0x0200,
      "fld",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FLD_ST0STi_IMPL              \
{                  \
  efloat_t _src;              \
  \
  _src = FPR(STI);              \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _src);            \
}
  DEFINST(FLD_ST0STi,    0x03,
      "fld",      "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FXCH_ST0STi_LINK)

#define FXCH_ST0STi_IMPL            \
{                  \
  efloat_t _tmp, _src;            \
  \
  _tmp = FPR(MD_REG_ST0);            \
  _src = FPR(STI);              \
  SET_FPR(MD_REG_ST0, _src);            \
  SET_FPR(STI, _tmp);              \
}
  DEFINST(FXCH_ST0STi,    0x03,
      "fxch",      "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FST_Ms_LINK)

#define FST_Ms_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2S(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(FST_Ms,      0x0200,
      "fst",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(FNOP_LINK, 0x03, "fnop_link", 0, 0x07)


CONNECT(FNOP_LINK)

#define FNOP_IMPL              \
{                  \
  /* nada... */              \
}
  DEFINST(FNOP,      0x00,
      "fnop",      "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSTP_Ms_LINK)

#define FSTP_Ms_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2S(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  FPSTACK_POP();              \
}
  DEFINST(FSTP_Ms,    0x0200,
      "fstp",      "%Ms",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FLDENV_Mx_LINK)

  /* FIXME: TODO: 0x0200: FLDENV_Mx */

  DEFLINK(FCHS_LINK, 0x03, "fchs_link", 0, 0x07)


CONNECT(FCHS_LINK)

#define FCHS_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _res = -_src;              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCHS,      0x00,
      "fchs",      "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FABS_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _res = fabs(_src);              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FABS,      0x01,
      "fabs",      "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FTST_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = (efloat_t)0.0;            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
}
  DEFINST(FTST,      0x04,
      "ftst",      "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FXAM_IMPL              \
{                  \
  efloat_t _src;              \
  word_t _fsw = 0;              \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  if (_src < 0.0)              \
  _fsw |= C1;              \
  if (isnan(_src))              \
  _fsw |= C0;              \
  else if (isinf(_src))            \
  _fsw |= (C2|C0);              \
  else if (_src == 0.0)            \
  _fsw |= C3;              \
  else                \
  _fsw |= C2;              \
  \
  SET_FSW(_fsw, C0|C1|C2|C3);            \
}
  DEFINST(FXAM,      0x05,
      "fxam",      "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FLDCW_Mw_LINK)

#if 1
#define FLDCW_Mw_IMPL              \
{                  \
  word_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_WORD(_addr, _fault);        \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_CWD(_src, 0xffff);            \
}
  DEFINST(FLDCW_Mw,    0x0200,
      "fldcw",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)
#endif

  DEFLINK(FLDC_LINK, 0x03, "fldc_link", 0, 0x07)


CONNECT(FLDC_LINK)

#define FLDC_IMPL              \
{                  \
  efloat_t _src;              \
  \
  _src = FPCONST(RM);              \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _src);            \
}
  DEFINST(FLDC,      0x0600,
      "fld%lc",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSTENV_Mx_LINK)

  /* FIXME: TODO: 0x0200: FSTENV_Mx */

  DEFLINK(F2XM1_LINK, 0x03, "f2xm1_link", 0, 0x07)


CONNECT(F2XM1_LINK)

#define F2XM1_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _res = pow(2.0, _src) - 1.0;          \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(F2XM1,      0x00,
      "f2xm1",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FYL2X_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(MD_REG_ST1);            \
  \
  _res = _src2 * (log(_src1)/log(2.0));        \
  \
  FPSTACK_POP();              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FYL2X,      0x01,
      "fyl2x",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FPTAN_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _res = tan(_src);              \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, (efloat_t)1.0);          \
  SET_FPR(MD_REG_ST1, _res);            \
}
  DEFINST(FPTAN,      0x02,
      "fptan",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FPATAN_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(MD_REG_ST1);            \
  \
  _res = atan(_src2/_src1);            \
  \
  FPSTACK_POP();              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FPATAN,      0x03,
      "fpatan",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO: 0x04: FXTRACT */

#define FPREM1_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(MD_REG_ST1);            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = drem(_src1, _src2);            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FPREM1,      0x05,
      "fprem1",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO: 0x06: FDECSTP */

  /* FIXME: TODO: 0x07: FINCSTP */


CONNECT(FSTCW_Mw_LINK)

#if 1
#define FSTCW_Mw_IMPL              \
{                  \
  word_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = CWD(0xffff);                    \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_WORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(FSTCW_Mw,    0x0200,
      "fstcw",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)
#endif

  DEFLINK(FPREM_LINK, 0x03, "fprem_link", 0, 0x07)


CONNECT(FPREM_LINK)

#define FPREM_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(MD_REG_ST1);            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = fmod(_src1, _src2);            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FPREM,      0x00,
      "fprem",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FYL2XP1_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(MD_REG_ST1);            \
  \
  _res = _src2 * (log(_src1 + 1.0)/log(2.0));        \
  \
  FPSTACK_POP();              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FYL2XP1,    0x01,
      "fyl2xp1",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSQRT_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _res = sqrt(_src);              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSQRT,      0x02,
      "fsqrt",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSINCOS_IMPL              \
{                  \
  efloat_t _src, _res1, _res2;          \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _res1 = sin(_src);              \
  _res2 = cos(_src);              \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _res2);            \
  SET_FPR(MD_REG_ST1, _res1);            \
}
  DEFINST(FSINCOS,    0x03,
      "fsincos",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FRNDINT_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _res = rint(_src);              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FRNDINT,    0x04,
      "frndint",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSCALE_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(MD_REG_ST1);            \
  \
  _res = _src1 * pow(2.0, _src2);          \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSCALE,      0x05,
      "fscale",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSIN_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _res = sin(_src);              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSIN,      0x06,
      "fsin",      "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCOS_IMPL              \
{                  \
  efloat_t _src, _res;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _res = cos(_src);              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCOS,      0x07,
      "fcos",      "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(GRPDA_LINK)

  DEFLINK(FIADD_Md_LINK, 0x00, "fiadd_md_link", 6, 0x03)

  DEFLINK(FIMUL_Md_LINK, 0x01, "fimul_md_link", 6, 0x03)

  DEFLINK(FICOM_Md_LINK, 0x02, "ficom_md_link", 6, 0x03)

  DEFLINK(FICOMP_Md_LINK, 0x03, "ficomp_md_link", 6, 0x03)

  DEFLINK(FISUB_Md_LINK, 0x04, "fisub_md_link", 6, 0x03)

  DEFLINK(FISUBR_Md_LINK, 0x05, "fisubr_md_link", 6, 0x03)

  DEFLINK(FIDIV_Md_LINK, 0x06, "fidiv_md_link", 6, 0x03)

  DEFLINK(FIDIVR_Md_LINK, 0x07, "fidivr_md_link", 6, 0x03)


CONNECT(FIADD_Md_LINK)

#define FIADD_Md_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIADD_Md,      0x0200,
      "fiadd",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCMOVB_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_B, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVB_ST0STi,    0x03,
      "fcmovb",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIMUL_Md_LINK)

#define FIMUL_Md_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 * _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIMUL_Md,    0x0200,
      "fimul",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCMOVE_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_E, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVE_ST0STi,    0x03,
      "fcmove",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FICOM_Md_LINK)

#define FICOM_Md_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
}
  DEFINST(FICOM_Md,    0x0200,
      "ficom",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCMOVBE_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_BE, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVBE_ST0STi,    0x03,
      "fcmovbe",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FICOMP_Md_LINK)

#define FICOMP_Md_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
}
  DEFINST(FICOMP_Md,    0x0200,
      "ficomp",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCMOVU_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_U, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVU_ST0STi,    0x03,
      "fcmovu",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FISUB_Md_LINK)

#define FISUB_Md_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FISUB_Md,    0x0200,
      "fisub",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FISUBR_Md_LINK)

#define FISUBR_Md_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src2 - _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FISUBR_Md,    0x0200,
      "fisubr",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(FUCOMPP_LINK, 0x03, "fucompp_link", 0, 0x07)


CONNECT(FUCOMPP_LINK)

#define FUCOMPP_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_FSW(FSW_FUCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
  FPSTACK_POP();              \
}
  DEFINST(FUCOMPP,    0x01,
      "fucompp",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIDIV_Md_LINK)

#define FIDIV_Md_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src1 / _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIDIV_Md,    0x0200,
      "fidiv",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIDIVR_Md_LINK)

#define FIDIVR_Md_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src1 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src2 / _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIDIVR_Md,    0x0200,
      "fidivr",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRPDB_LINK)

  DEFLINK(FILD_Md_LINK, 0x00, "fild_md_link", 6, 0x03)

  DEFLINK(FCMOVNE_ST0STi_LINK, 0x01, "fcmovne_stosti_link", 6, 0x03)

  DEFLINK(FIST_Md_LINK, 0x02, "fist_md_link", 6, 0x03)

  DEFLINK(FISTP_Md_LINK, 0x03, "fistp_md_link", 6, 0x03)

  DEFLINK(FCLEX_LINK, 0x04, "fclex_link", 6, 0x03)

  DEFLINK(FLD_Me_LINK, 0x05, "fld_me_link", 6, 0x03)

  DEFLINK(FCOMI_ST0STi_LINK, 0x06, "fcomi_stosti_link", 6, 0x03)

  DEFLINK(FSTP_Me_LINK, 0x07, "fstp_me_link", 6, 0x03)


CONNECT(FILD_Md_LINK)

#define FILD_Md_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _src);            \
}
  DEFINST(FILD_Md,    0x0200,
      "fild",      "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCMOVNB_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_NB, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVNB_ST0STi,    0x03,
      "fcmovnb",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FCMOVNE_ST0STi_LINK)

#define FCMOVNE_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_NE, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVNE_ST0STi,    0x03,
      "fcmovne",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIST_Md_LINK)

#define FIST_Md_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2D(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(FIST_Md,    0x0200,
      "fist",      "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCMOVNBE_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_NBE, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVNBE_ST0STi,  0x03,
      "fcmovnbe",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FISTP_Md_LINK)

#define FISTP_Md_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2D(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  FPSTACK_POP();              \
}
  DEFINST(FISTP_Md,    0x0200,
      "fistp",    "%Md",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FCMOVNU_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  \
  _res = FCC_EVAL(FCC_NU, _aflags) ? _src2 : _src1;      \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FCMOVNU_ST0STi,    0x03,
      "fcmovnu",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FCLEX_LINK)

  DEFLINK(FCLEX1_LINK, 0x03, "fclex1_link", 0, 0x03)


CONNECT(FCLEX1_LINK)

#define FCLEX_IMPL              \
{                  \
  SET_FSW(0, IE|DE|ZE|OE|UE|PE|FSF|ES);        \
}
  DEFINST(FCLEX,      0x02,
      "fclex",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(FLD_Me_LINK)

#define FLD_Me_IMPL              \
{                  \
  qword_t _src1;              \
  dword_t _src2;              \
  efloat_t _res;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src1 = READ_QWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = READ_DWORD(_addr+8, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = QW2E(_src1, _src2);            \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FLD_Me,      0x0200,
      "fld",      "%Me",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FUCOMI_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_AFLAGS(AFLAGS_FUCOMI(_src1, _src2), ZF|PF|CF);      \
}
  DEFINST(FUCOMI_ST0STi,    0x03,
      "fucomi",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FCOMI_ST0STi_LINK)

#define FCOMI_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_AFLAGS(AFLAGS_FCOMI(_src1, _src2), ZF|PF|CF);      \
}
  DEFINST(FCOMI_ST0STi,    0x03,
      "fcomi",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSTP_Me_LINK)

#define FSTP_Me_IMPL              \
{                  \
  efloat_t _src;              \
  qword_t _src1;              \
  dword_t _src2;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  _src1 = E2Qw(_src);              \
  _src2 = E2qW(_src);              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_QWORD(_src1, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  WRITE_DWORD(_src2, _addr+8, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  FPSTACK_POP();              \
}
  DEFINST(FSTP_Me,    0x0200,
      "fstp",      "%Me",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRPDC_LINK)

  DEFLINK(FADD_Et_LINK, 0x00, "fadd_et_link", 6, 0x03)

  DEFLINK(FMUL_Et_LINK, 0x01, "fmul_et_link", 6, 0x03)

  DEFLINK(FCOM_Mt_LINK, 0x02, "fcom_mt_link", 6, 0x03)

  DEFLINK(FCOMP_Mt_LINK, 0x03, "fcomp_mt_link", 6, 0x03)

  DEFLINK(FSUB_Et_LINK, 0x04, "fsub_et_link", 6, 0x03)

  DEFLINK(FSUBR_Et_LINK, 0x05, "fsubr_et_link", 6, 0x03)

  DEFLINK(FDIV_Et_LINK, 0x06, "fdiv_et_link", 6, 0x03)

  DEFLINK(FDIVR_Et_LINK, 0x07, "fdivr_et_link", 6, 0x03)


CONNECT(FADD_Et_LINK)

#define FADD_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FADD_Mt,    0x0200,
      "fadd",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FADD_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_FPR(STI, _res);              \
}
  DEFINST(FADD_STiST0,    0x03,
      "fadd",      "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FMUL_Et_LINK)

#define FMUL_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 * _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FMUL_Mt,    0x0200,
      "fmul",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FMUL_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src1 * _src2;            \
  \
  SET_FPR(STI, _res);              \
}
  DEFINST(FMUL_STiST0,    0x03,
      "fmul",      "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FCOM_Mt_LINK)

#define FCOM_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
}
  DEFINST(FCOM_Mt,    0x0200,
      "fcom",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FCOMP_Mt_LINK)

#define FCOMP_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
}
  DEFINST(FCOMP_Mt,    0x0200,
      "fcomp",    "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSUB_Et_LINK)

#define FSUB_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSUB_Mt,    0x0200,
      "fsub",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSUBR_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src2 - _src1;            \
  \
  SET_FPR(STI, _res);              \
}
  DEFINST(FSUBR_STiST0,    0x03,
      "fsubr",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSUBR_Et_LINK)

#define FSUBR_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src2 - _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FSUBR_Mt,    0x0200,
      "fsubr",    "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSUB_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_FPR(STI, _res);              \
}
  DEFINST(FSUB_STiST0,    0x03,
      "fsub",      "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FDIV_Et_LINK)

#define FDIV_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src1 / _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FDIV_Mt,    0x0200,
      "fdiv",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FDIVR_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  if (_src1 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src2 / _src1;            \
  \
  SET_FPR(STI, _res);              \
}
  DEFINST(FDIVR_STiST0,    0x03,
      "fdivr",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FDIVR_Et_LINK)

#define FDIVR_Mt_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src1 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src2 / _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FDIVR_Mt,    0x0200,
      "fdivr",    "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FDIV_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src1 / _src2;            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  SET_FPR(STI, _res);              \
}
  DEFINST(FDIV_STiST0,    0x03,
      "fdiv",      "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRPDD_LINK)

  DEFLINK(FLD_Mt_LINK, 0x00, "fld_mt_link", 6, 0x03)

  DEFLINK(FST_Et_LINK, 0x02, "fst_et_link", 6, 0x03)

  DEFLINK(FSTP_Et_LINK, 0x03, "fstp_et_link", 6, 0x03)

  DEFLINK(FRSTOR_Mx_LINK, 0x04, "frstor_mx_link", 6, 0x03)

  DEFLINK(FUCOMP_STi_LINK, 0x05, "fucomp_sti_link", 6, 0x03)

  /* DEFLINK(FSAVE_Mx_LINK, 0x06, "fsave_mx_link", 6, 0x03) */

  DEFLINK(FSTSW_Mw_LINK, 0x07, "fstsw_mw_link", 6, 0x03)


CONNECT(FSTSW_Mw_LINK)

#define FSTSW_Mw_IMPL              \
{                  \
  word_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FSW(C0|C1|C2|C3);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_WORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(FSTSW_Mw,    0x0200,
      "fstsw",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FLD_Mt_LINK)

#define FLD_Mt_IMPL              \
{                  \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  efloat_t _src;              \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _src);            \
}
  DEFINST(FLD_Mt,      0x0200,
      "fld",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /* FIXME: TODO: 0x03: FFREE_STi */


CONNECT(FST_Et_LINK)

#define FST_Mt_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2T(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(FST_Mt,      0x0200,
      "fst",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FST_STi_IMPL              \
{                  \
  efloat_t _src;              \
  \
  _src = FPR(MD_REG_ST0);            \
  SET_FPR(STI, _src);              \
}
  DEFINST(FST_STi,    0x03,
      "fst",      "%Si",
      FU_INVALID,                 F_FCOMP|F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FSTP_Et_LINK)

#define FSTP_Mt_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2T(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  FPSTACK_POP();              \
}
  DEFINST(FSTP_Mt,    0x0200,
      "fstp",      "%Mt",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSTP_STi_IMPL              \
{                  \
  efloat_t _src;              \
  \
  _src = FPR(MD_REG_ST0);            \
  SET_FPR(STI, _src);              \
  FPSTACK_POP();              \
}
  DEFINST(FSTP_STi,    0x03,
      "fstp",      "%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FRSTOR_Mx_LINK)

  /* FIXME: TODO: 0x0200: FRSTOR_Mx */

#define FUCOM_STi_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_FSW(FSW_FUCOM(_src1, _src2), C0|C2|C3);        \
}
  DEFINST(FUCOM_STi,    0x03,
      "fucom",    "%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FUCOMP_STi_LINK)

#define FUCOMP_STi_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_FSW(FSW_FUCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
}
  DEFINST(FUCOMP_STi,    0x03,
      "fucomp",    "%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRPDE_LINK)

  DEFLINK(FIADD_Mw_LINK, 0x00, "fiadd_mw_link", 6, 0x03)

  DEFLINK(FIMUL_Mw_LINK, 0x01, "fimul_mw_link", 6, 0x03)

  DEFLINK(FICOM_Mw_LINK, 0x02, "ficom_mw_link", 6, 0x03)

  DEFLINK(FICOMP_Mw_LINK, 0x03, "ficomp_mw_link", 6, 0x03)

  DEFLINK(FISUB_Mw_LINK, 0x04, "fisub_mw_link", 6, 0x03)

  DEFLINK(FISUBR_Mw_LINK, 0x05, "fisubr_mw_link", 6, 0x03)

  DEFLINK(FIDIV_Mw_LINK, 0x06, "fidiv_mw_link", 6, 0x03)

  DEFLINK(FIDIVR_Mw_LINK, 0x07, "fidivr_mw_link", 6, 0x03)


CONNECT(FIADD_Mw_LINK)

#define FIADD_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIADD_Mw,    0x0200,
      "fiadd",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FADDP_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src1 + _src2;            \
  \
  SET_FPR(STI, _res);              \
  FPSTACK_POP();              \
}
  DEFINST(FADDP_STiST0,    0x03,
      "faddp",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIMUL_Mw_LINK)

#define FIMUL_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 * _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIMUL_Mw,    0x0200,
      "fimul",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FMULP_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src1 * _src2;            \
  \
  SET_FPR(STI, _res);              \
  FPSTACK_POP();              \
}
  DEFINST(FMULP_STiST0,    0x03,
      "fmulp",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FICOM_Mw_LINK)

#define FICOM_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
}
  DEFINST(FICOM_Mw,    0x0200,
      "ficom",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FICOMP_Mw_LINK)

#define FICOMP_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
}
  DEFINST(FICOMP_Mw,    0x0200,
      "ficomp",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  DEFLINK(FCOMPP_LINK, 0x03, "fcompp_link", 0, 0x07)


CONNECT(FCOMPP_LINK)

#define FCOMPP_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(MD_REG_ST1);            \
  \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  FPSTACK_POP();              \
  FPSTACK_POP();              \
}
  DEFINST(FCOMPP,      0x01,
      "fcompp",    "",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FISUB_Mw_LINK)

#define FISUB_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FISUB_Mw,    0x0200,
      "fisub",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSUBRP_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src2 - _src1;            \
  \
  SET_FPR(STI, _res);              \
  FPSTACK_POP();              \
}
  DEFINST(FSUBRP_STiST0,    0x03,
      "fsubp",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FISUBR_Mw_LINK)

#define FISUBR_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  _res = _src2 - _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FISUBR_Mw,    0x0200,
      "fisubr",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FSUBP_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  _res = _src1 - _src2;            \
  \
  SET_FPR(STI, _res);              \
  FPSTACK_POP();              \
}
  DEFINST(FSUBP_STiST0,    0x03,
      "fsubp",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIDIV_Mw_LINK)

#define FIDIV_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src1 / _src2;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIDIV_Mw,    0x0200,
      "fidiv",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FDIVRP_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  if (_src1 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src2 / _src1;            \
  \
  SET_FPR(STI, _res);              \
  FPSTACK_POP();              \
}
  DEFINST(FDIVRP_STiST0,    0x03,
      "fdivrp",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIDIVR_Mw_LINK)

#define FIDIVR_Mw_IMPL              \
{                  \
  efloat_t _src1, _src2, _res;          \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src2 = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  if (_src1 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src2 / _src1;            \
  \
  SET_FPR(MD_REG_ST0, _res);            \
}
  DEFINST(FIDIVR_Mw,    0x0200,
      "fidivr",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FDIVP_STiST0_IMPL            \
{                  \
  efloat_t _src1, _src2, _res;          \
  \
  _src1 = FPR(STI);              \
  _src2 = FPR(MD_REG_ST0);            \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src1 / _src2;            \
  \
  SET_FPR(STI, _res);              \
  FPSTACK_POP();              \
}
  DEFINST(FDIVP_STiST0,    0x03,
      "fdivp",    "%Si,ST(0)",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(GRPDF_LINK)

  DEFLINK(FILD_Mw_LINK, 0x00, "fild_mw_link", 6, 0x03)

  DEFLINK(FIST_Mw_LINK, 0x02, "fist_mw_link", 6, 0x03)

  DEFLINK(FISTP_Mw_LINK, 0x03, "fistp_mw_link", 6, 0x03)

  DEFLINK(FBLD_Mx_Mw_LINK, 0x04, "fbld_mx_mw_link", 6, 0x03)

  DEFLINK(FILD_Mq_LINK, 0x05, "fild_mq_link", 6, 0x03)

  DEFLINK(FBSTP_Mx_LINK, 0x06, "fbstp_mx_link", 6, 0x03)

  DEFLINK(FISTP_Mq_LINK, 0x07, "fistp_mq_link", 6, 0x03)


CONNECT(FILD_Mw_LINK)

#define FILD_Mw_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _src);            \
}
  DEFINST(FILD_Mw,    0x0200,
      "fild",      "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FIST_Mw_LINK)

#define FIST_Mw_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2W(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFINST(FIST_Mw,    0x0200,
      "fist",      "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FISTP_Mw_LINK)

#define FISTP_Mw_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2W(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  FPSTACK_POP();              \
}
  DEFINST(FISTP_Mw,    0x0200,
      "fistp",    "%Mw",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FBLD_Mx_Mw_LINK)

#define FSTSW_AX_IMPL              \
{                  \
  word_t _src;              \
  \
  _src = FSW(0xffff);             \
  SET_GPR_W(MD_REG_AX, _src);            \
}
  DEFINST(FSTSW_AX,    0x03,
      "fstsw",    "AX",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

CONNECT(FILD_Mq_LINK)

#define FILD_Mq_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  _src = READ_Q2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  \
  FPSTACK_PUSH();              \
  SET_FPR(MD_REG_ST0, _src);            \
}
  DEFINST(FILD_Mq,    0x0200,
      "fild",      "%Mq",
      FU_INVALID,                 F_FCOMP|F_MEM|F_LOAD|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define FUCOMIP_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_AFLAGS(AFLAGS_FUCOMI(_src1, _src2), ZF|PF|CF);      \
  FPSTACK_POP();              \
}
  DEFINST(FUCOMIP_ST0STi,    0x03,
      "fucomip",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FBSTP_Mx_LINK)

  /* FIXME: TODO: 0x0200: FBSTP_Mx */

#define FCOMIP_ST0STi_IMPL            \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(MD_REG_ST0);            \
  _src2 = FPR(STI);              \
  \
  SET_AFLAGS(AFLAGS_FCOMI(_src1, _src2), ZF|PF|CF);      \
  FPSTACK_POP();              \
}
  DEFINST(FCOMIP_ST0STi,    0x03,
      "fcomip",    "ST(0),%Si",
      FU_INVALID,                 F_FCOMP|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)


CONNECT(FISTP_Mq_LINK)

#define FISTP_Mq_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(MD_REG_ST0);            \
  \
  _addr = AGEN_A(SEG, BASE, INDEX, SCALE, DISP);      \
  WRITE_E2Q(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  FPSTACK_POP();              \
}
  DEFINST(FISTP_Mq,    0x0200,
      "fistp",    "%Mq",
      FU_INVALID,                 F_FCOMP|F_MEM|F_STORE|F_UCODE,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

  /******** UOP Definitions ***********************/
  /* ideps labeled with "PRD" are for enforcing
     partial-register dependencies */

#define ADDB_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = _src1 + _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDB,      0x00,
      "addb",      "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ADDBI_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _res = _src1 + _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDBI,      0x00,
      "addb",      "%Db,%Sb,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define SETFLAGSW_IMPL              \
{                  \
  dword_t _src;              \
  \
  _src = GPR_W(URD);              \
  if (ISUV)                \
  SET_AFLAGS(_src, OF|SF|ZF|AF|CF|PF);        \
}
  DEFUOP(SETFLAGSW,      0x00,
      "setflags",      "",
      FU_IEU,      F_ICOMP,
      DNA,
      DGPR_W(URD), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define GETFLAGSW_IMPL              \
{                  \
  dword_t _src = AFLAGS(~0);            \
  dword_t _orig = GPR_D(URD);             \
  \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _src);            \
}
  DEFUOP(GETFLAGSW,      0x00,
      "getflags",      "",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URD)/*PRD*/, DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define SETFLAGSD_IMPL              \
{                  \
  dword_t _src;              \
  \
  _src = GPR_D(URD);              \
  if (ISUV)                \
  SET_AFLAGS(_src, OF|SF|ZF|AF|CF|PF);        \
}
  DEFUOP(SETFLAGSD,      0x00,
      "setflags",      "",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DNA, DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define GETFLAGSD_IMPL              \
{                  \
  dword_t _src = AFLAGS(~0);            \
  \
  SET_GPR_D(URD, _src);            \
}
  DEFUOP(GETFLAGSD,      0x00,
      "getflags",      "",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DNA, DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

/* CPUID sets four different registers, and so we
   break it into four separate uops */
/* pretend to be GenuineIntel */
#define CPUID1_IMPL              \
{                  \
  SET_GPR_D(URD, 1);   \
}
  DEFUOP(CPUID1,    0x00,
      "cpuid",    "",
      FU_IEU,                 F_ICOMP,
      DGPR_D(URD),
      DGPR_D(MD_REG_EAX), DNA, DNA,
      DNA, DNA)
#define CPUID2_IMPL              \
{                  \
  dword_t _tmp; \
  _tmp = (('u'<<24)|('n'<<16)|('e'<<8)|('G')); \
  SET_GPR_D(URD, _tmp ); \
}
  DEFUOP(CPUID2,    0x00,
      "cpuid",    "",
      FU_IEU,                 F_ICOMP,
      DGPR_W(URD),
      DGPR_W(MD_REG_EAX), DNA, DNA,
      DNA, DNA)
#define CPUID3_IMPL              \
{                  \
  dword_t _tmp; \
  _tmp = (('I'<<24)|('e'<<16)|('n'<<8)|('i')); \
  SET_GPR_D(URD, _tmp ); \
}
  DEFUOP(CPUID3,    0x00,
      "cpuid",    "",
      FU_IEU,                 F_ICOMP,
      DGPR_D(URD),
      DGPR_D(MD_REG_EAX), DNA, DNA,
      DNA, DNA)
#define CPUID4_IMPL              \
{                  \
  dword_t _tmp; \
  _tmp = (('l'<<24)|('e'<<16)|('t'<<8)|('n')); \
  SET_GPR_D(URD, _tmp ); \
}
  DEFUOP(CPUID4,    0x00,
      "cpuid",    "",
      FU_IEU,                 F_ICOMP,
      DGPR_D(URD),
      DGPR_D(MD_REG_EAX), DNA, DNA,
      DNA, DNA)

  /* end of CPUID uops */

  /* RDTSC writes two registers, so break into two uops */
#define RDTSC1_IMPL \
{                            \
  SET_GPR_D(URD, thread->stat.num_insn / (long long) 0xffffffff);    \
}
  DEFUOP(RDTSC1,    0x00,
      "rdtsc",    "",
      FU_IEU,                 F_ICOMP,
      DGPR_D(URD),
      DNA, DNA, DNA,
      DNA, DNA)
#define RDTSC2_IMPL \
{                            \
  SET_GPR_D(URD, thread->stat.num_insn % (long long) 0xffffffff);    \
}
  DEFUOP(RDTSC2,    0x00,
      "rdtsc",    "",
      FU_IEU,                 F_ICOMP,
      DGPR_D(URD),
      DNA, DNA, DNA,
      DNA, DNA)

  /* end of RDTSC uops */

/* non-memory CMPXCHG uops */
/* original single-uop definition for reference: */
#if 0
#define CMPXCHGW_ORIG_IMPL         \
{                  \
  word_t _res, _eax, _src, _dst;        \
  \
  _eax = GPR_W(URS);              \
  _src = GPR_W(URT);              \
  _dst = GPR_W(URD);              \
  _res = _eax - _dst;      /* UOP1 */    \
  if (_res == 0)               \
  {                \
    SET_GPR_W(URD,_src);   /* UOP2 */    \
  }                \
  else                \
  {                \
    SET_GPR_W(URS, _dst);  /* UOP3 */    \
  }                \
  \
  if (ISUV)                /* UOP1 */    \
  SET_AFLAGS(AFLAGS_SUBW(_res, _eax, _dst), OF|SF|ZF|AF|CF|PF);  \
}
#endif
/* Uop operands:
   UOP1: D(TMP0), S(EAX), T(RM)
   UOP2: D(RM),   S(R),   T(TMP0)
   UOP3: D(EAX),  S(RM),  T(TMP0)
 */

#define CMPXCHG1W_IMPL /* do CMP */             \
{                  \
  word_t _res, _eax, _dst;        \
  \
  _eax = GPR_W(URS);              \
  _dst = GPR_W(URT);              \
  _res = _eax - _dst;            \
  SET_GPR_W(URD,_res);          /* store diff in tmp0 */ \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBW(_res, _eax, _dst), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(CMPXCHG1W,    0x00,
      "cmpxchgw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DNA/*PRD not needed since writing to tmp0*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)
#define CMPXCHG2W_IMPL /* write if CMP==0 */             \
{                  \
  word_t _diff, _src, _dst;        \
  \
  _diff = GPR_W(URT);              \
  _src = GPR_W(URS);              \
  _dst = GPR_W(URD);              \
  if (_diff == 0) {                \
    SET_GPR_W(URD,_src);          \
  } else { \
    SET_GPR_W(URD,_dst); /* move onto self */         \
  } \
  \
}
  DEFUOP(CMPXCHG2W,    0x00,
      "cmpxchgw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD),
      DNA, DNA)
#define CMPXCHG3W_IMPL /* write if CMP!=0 */             \
{                  \
  word_t _diff, _eax, _src;        \
  \
  _diff = GPR_W(URT);              \
  _src = GPR_W(URS);              \
  _eax = GPR_W(URD);              \
  if (_diff != 0) {             \
    SET_GPR_W(URD, _src);      \
  } else {                \
    SET_GPR_W(URD, _eax); /* move onto self */     \
  }                \
}
  DEFUOP(CMPXCHG3W,    0x00,
      "cmpxchgw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD),
      DNA, DNA)
  

  /* double-word version */
#define CMPXCHG1D_IMPL /* do CMP */             \
{                  \
  word_t _res, _eax, _dst;        \
  \
  _eax = GPR_D(URS);              \
  _dst = GPR_D(URT);              \
  _res = _eax - _dst;            \
  SET_GPR_D(URD,_res);          /* store diff in tmp0 */ \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBW(_res, _eax, _dst), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(CMPXCHG1D,    0x00,
      "cmpxchgw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)
#define CMPXCHG2D_IMPL /* write if CMP==0 */             \
{                  \
  word_t _diff, _src, _dst;        \
  \
  _diff = GPR_D(URT);              \
  _src = GPR_D(URS);              \
  _dst = GPR_D(URD);              \
  if (_diff == 0) {                \
    SET_GPR_D(URD,_src);          \
  } else { \
    SET_GPR_D(URD,_dst); /* move onto self */         \
  } \
  \
}
  DEFUOP(CMPXCHG2D,    0x00,
      "cmpxchgw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_D(URD),
      DNA, DNA)
#define CMPXCHG3D_IMPL /* write if CMP!=0 */             \
{                  \
  word_t _diff, _eax, _src;        \
  \
  _diff = GPR_D(URT);              \
  _src = GPR_D(URS);              \
  _eax = GPR_D(URD);              \
  if (_diff != 0) {             \
    SET_GPR_D(URD, _src);      \
  } else {                \
    SET_GPR_D(URD, _eax); /* move onto self */     \
  }                \
}
  DEFUOP(CMPXCHG3D,    0x00,
      "cmpxchgw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_D(URD),
      DNA, DNA)

  /* supporting uops (CMOVs) for register-memory CMPXCHG */
#define CMPXCHGMEM_CMOVW_IMPL              \
{                  \
  word_t _orig, _src, _cond;        \
  \
  _orig = GPR_W(URD);              \
  _src = GPR_W(URS);              \
  _cond = GPR_W(URT);              \
  if (_cond != 0) {             \
    SET_GPR_W(URD, _src);      \
  } else {                \
    SET_GPR_W(URD, _orig); /* move onto self */     \
  }                \
}
  DEFUOP(CMPXCHGMEM_CMOVW,    0x00,
      "cmpxchgmem-cmovw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URD), DGPR_D(URS), DGPR_D(URT),
      DNA, DNA)
#define CMPXCHGMEM_CMOVNW_IMPL              \
{                  \
  word_t _orig, _src, _cond;        \
  \
  _orig = GPR_W(URD);              \
  _src = GPR_W(URS);              \
  _cond = GPR_W(URT);              \
  if (_cond == 0) {             \
    SET_GPR_W(URD, _src);      \
  } else {                \
    SET_GPR_W(URD, _orig); /* move onto self */     \
  }                \
}
  DEFUOP(CMPXCHGMEM_CMOVNW,    0x00,
      "cmpxchgmem-cmovw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URD), DGPR_D(URS), DGPR_D(URT),
      DNA, DNA)
#define CMPXCHGMEM_CMOVD_IMPL              \
{                  \
  dword_t _orig, _src, _cond;        \
  \
  _orig = GPR_D(URD);              \
  _src = GPR_D(URS);              \
  _cond = GPR_D(URT);              \
  if (_cond != 0) {             \
    SET_GPR_D(URD, _src);      \
  } else {                \
    SET_GPR_D(URD, _orig); /* move onto self */     \
  }                \
}
  DEFUOP(CMPXCHGMEM_CMOVD,    0x00,
      "cmpxchgmem-cmovd",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URD), DGPR_D(URS), DGPR_D(URT),
      DNA, DNA)
#define CMPXCHGMEM_CMOVND_IMPL              \
{                  \
  dword_t _orig, _src, _cond;        \
  \
  _orig = GPR_D(URD);              \
  _src = GPR_D(URS);              \
  _cond = GPR_D(URT);              \
  if (_cond == 0) {             \
    SET_GPR_D(URD, _src);      \
  } else {                \
    SET_GPR_D(URD, _orig); /* move onto self */     \
  }                \
}
  DEFUOP(CMPXCHGMEM_CMOVND,    0x00,
      "cmpxchgmem-cmovd",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URD), DGPR_D(URS), DGPR_D(URT),
      DNA, DNA)
  

  /* end of CMPXCHG nastiness */



  // segment is a source 
#define ADDSSW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = SEG_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 + _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDW(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDSSW,      0x00,
      "addssw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DSEG(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

  // segment is the destination
#define ADDSW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 + _src2;            \
  SET_SEG_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDW(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDSW,      0x00,
      "addws",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DSEG(URD),
      DGPR_W(URS), DGPR_W(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)


#define ADDW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 + _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDW(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDW,      0x00,
      "addw",      "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ADDWI_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _res = _src1 + _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDW(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDWI,      0x00,
      "addw",      "%Dw,%Sw,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ADDSSD_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = SEG_W(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 + _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDD(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDSSD,      0x00,
      "addssd",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DSEG(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)


#define ADDSD_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 + _src2;            \
  SET_SEG_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDD(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDSD,      0x00,
      "addsd",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DSEG(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)


#define ADDD_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 + _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDD(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDD,      0x00,
      "addd",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ADDDI_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _res = _src1 + _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADDD(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(ADDDI,      0x00,
      "addd",      "%Dd,%Sd,%Id",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ORB_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = _src1 | _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ORB,      0x00,
      "orb",      "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ORBI_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _res = _src1 | _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ORBI,      0x00,
      "orb",      "%Db,%Sb,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ORW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 | _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUW(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ORW,      0x00,
      "orw",      "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ORWI_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _res = _src1 | _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUW(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ORWI,      0x00,
      "orw",      "%Dw,%Sw,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ORD_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 | _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUD(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ORD,      0x00,
      "ord",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ORDI_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _res = _src1 | _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUD(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ORDI,      0x00,
      "ord",      "%Dd,%Sd,%Id",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ADCB_IMPL              \
{                  \
  byte_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(ADCB,      0x00,
      "adcb",      "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define ADCBI_IMPL              \
{                  \
  byte_t _res, _src1, _src2, _cf;          \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADCB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(ADCBI,      0x00,
      "adcb",      "%Db,%Sb,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define ADCW_IMPL              \
{                  \
  word_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADCW(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(ADCW,      0x00,
      "adcw",      "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define ADCWI_IMPL              \
{                  \
  word_t _res, _src1, _src2, _cf;          \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADCW(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(ADCWI,      0x00,
      "adcw",      "%Dw,%Sw,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define ADCD_IMPL              \
{                  \
  dword_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADCD(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(ADCD,      0x00,
      "adcd",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define ADCDI_IMPL              \
{                  \
  dword_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 + _src2 + _cf;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ADCD(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(ADCDI,      0x00,
      "adcd",      "%Dd,%Sd,%Id",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define SBBB_IMPL              \
{                  \
  byte_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(SBBB,      0x00,
      "sbbb",      "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define SBBBI_IMPL              \
{                  \
  byte_t _res, _src1, _src2, _cf;          \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SBBB(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(SBBBI,      0x00,
      "sbbb",      "%Db,%Sb,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define SBBW_IMPL              \
{                  \
  word_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SBBW(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(SBBW,      0x00,
      "sbbw",      "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define SBBWI_IMPL              \
{                  \
  word_t _res, _src1, _src2, _cf;          \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SBBW(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(SBBWI,      0x00,
      "sbbw",      "%Dw,%Sw,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define SBBD_IMPL              \
{                  \
  dword_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SBBD(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(SBBD,      0x00,
      "sbbd",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define SBBDI_IMPL              \
{                  \
  dword_t _res, _src1, _src2, _cf;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _cf = !!AFLAGS(CF);              \
  _res = _src1 - _src2 - _cf;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SBBD(_res, _src1, _src2, _cf), OF|SF|ZF|AF|CF|PF);\
}
  DEFUOP(SBBDI,      0x00,
      "sbbd",      "%Dd,%Sd,%Id",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DAFLAGS(CF))

#define ANDB_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = _src1 & _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ANDB,      0x00,
      "andb",      "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ANDBI_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _res = _src1 & _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ANDBI,      0x00,
      "andb",      "%Db,%Sb,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ANDW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 & _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUW(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ANDW,      0x00,
      "andw",      "%Dw,%Sw,%Tw",
      FU_IEU,                  F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ANDWI_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _res = _src1 & _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUW(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ANDWI,      0x00,
      "andw",      "%Dw,%Sw,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ANDD_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 & _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUD(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ANDD,      0x00,
      "andd",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define ANDDI_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _res = _src1 & _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUD(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(ANDDI,      0x00,
      "andd",      "%Dd,%Sd,%Id",
      FU_IEU,      F_ICOMP, 
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)
#define SUBB_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = _src1 - _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(SUBB,      0x00,
      "subb",      "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define SUBBI_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _res = _src1 - _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBB(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(SUBBI,      0x00,
      "subb",      "%Db,%Sb,%Ib",
      FU_IEU,      F_ICOMP, 
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)
#define SUBW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 - _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBW(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(SUBW,      0x00,
      "subw",      "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define SUBWI_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _res = _src1 - _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBW(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(SUBWI,      0x00,
      "subw",      "%Dw,%Sw,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define SUBD_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 - _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBD(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(SUBD,      0x00,
      "subd",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define SUBDI_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _res = _src1 - _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_SUBD(_res, _src1, _src2), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(SUBDI,      0x00,
      "subd",      "%Dd,%Sd,%Id",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define XORB_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = _src1 ^ _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(XORB,      0x00,
      "xorb",      "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP, 
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define XORBI_IMPL              \
{                  \
  byte_t _res, _src1, _src2;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUB(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(XORBI,      0x00,
      "xorb",      "%Db,%Sb,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define XORW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 ^ _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUW(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(XORW,      0x00,
      "xorw",      "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define XORWI_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUW(_res), OF|SF|ZF|AF|CF|PF);  \
}
  DEFUOP(XORWI,      0x00,
      "xorw",      "%Dw,%Sw,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define XORD_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 ^ _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUD(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(XORD,      0x00,
      "xord",      "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define XORDI_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _res = _src1 ^ _src2;            \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_ALUD(_res), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(XORDI,      0x00,
      "xord",      "%Dd,%Sd,%Id",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define INCB_IMPL              \
{                  \
  byte_t _res, _src;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _res = _src + 1;              \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_INCB(_res), OF|SF|ZF|AF|PF);      \
}
  DEFUOP(INCB,      0x00,
      "incb",      "%Db,%Sb",
      FU_IEU,      F_ICOMP,  
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|PF), DNA)

#define INCW_IMPL              \
{                  \
  word_t _res, _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = _src + 1;              \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_INCW(_res), OF|SF|ZF|AF|PF);      \
}
  DEFUOP(INCW,      0x00,
      "incw",      "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|PF), DNA)

#define INCD_IMPL              \
{                  \
  dword_t _res, _src;              \
  \
  _src = GPR_D(URS);              \
  _res = _src + 1;              \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_INCD(_res), OF|SF|ZF|AF|PF);      \
}
  DEFUOP(INCD,      0x00,
      "incd",      "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|PF), DNA)

#define DECB_IMPL              \
{                  \
  byte_t _res, _src;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _res = _src - 1;              \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_DECB(_res), OF|SF|ZF|AF|PF);      \
}
  DEFUOP(DECB,      0x00,
      "decb",      "%Db,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|PF), DNA)

#define DECW_IMPL              \
{                  \
  word_t _res, _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = _src - 1;              \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_DECW(_res), OF|SF|ZF|AF|PF);      \
}
  DEFUOP(DECW,      0x00,
      "decw",      "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|PF), DNA)

#define DECD_IMPL              \
{                  \
  dword_t _res, _src;              \
  \
  _src = GPR_D(URS);              \
  _res = _src - 1;              \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_DECD(_res), OF|SF|ZF|AF|PF);      \
}
  DEFUOP(DECD,      0x00,
      "decd",      "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|PF), DNA)

#define ROLB_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = GPR_B(URT) & 0x07;            \
  _res = ROL_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_ROLB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(ROLB,      0x00,
      "rolb",      "%Db,%Sb,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|CF), DNA)

#define ROLBI_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = UIMMB & 0x07;            \
  _res = ROL_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_ROLB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(ROLBI,      0x00,
      "rolb",      "%Db,%Sb,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DNA)

#define ROLW_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = GPR_B(URT) & (BITSIZE_W-1);        \
  _res = ROL_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_ROLW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(ROLW,      0x00,
      "rolw",      "%Dw,%Sw,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF), DNA)

#define ROLWI_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = UIMMB & (BITSIZE_W-1);          \
  SET_GPR_D(URD, _orig);            \
  _res = ROL_W(_src, _shamt);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_ROLW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(ROLWI,      0x00,
      "rolw",      "%Dw,%Sw,%Ib",
      FU_SHIFT,      F_ICOMP,  
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DNA)


#define ROLD_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = GPR_B(URT) & (BITSIZE_D-1);        \
  _res = ROL_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_ROLD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(ROLD,      0x00,
      "rold",      "%Dd,%Sd,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(OF|CF), DNA)

#define ROLDI_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = UIMMB & (BITSIZE_D-1);          \
  _res = ROL_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_ROLD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(ROLDI,      0x00,
      "rold",      "%Dd,%Sd,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|CF), DNA)

#define RORB_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = GPR_B(URT) & 0x07;            \
  _res = ROR_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RORB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RORB,      0x00,
      "rorb",      "%Db,%Sb,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|CF), DNA)

#define RORBI_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = UIMMB & 0x07;            \
  _res = ROR_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RORB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RORBI,      0x00,
      "rorb",      "%Db,%Sb,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DNA)

#define RORW_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = GPR_B(URT) & (BITSIZE_W-1);        \
  _res = ROR_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RORW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RORW,      0x00,
      "rorw",      "%Dw,%Sw,%Tb",
      FU_SHIFT,      F_ICOMP,    
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF), DNA)

#define RORWI_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = UIMMB & (BITSIZE_W-1);          \
  _res = ROR_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RORW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RORWI,      0x00,
      "rorw",      "%Dw,%Sw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DNA)

#define RORD_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = GPR_B(URT) & (BITSIZE_D-1);        \
  _res = ROR_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RORD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RORD,      0x00,
      "rord",      "%Dd,%Sd,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(OF|CF), DNA)

#define RORDI_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = UIMMB & (BITSIZE_D-1);          \
  _res = ROR_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RORD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RORDI,      0x00,
      "rord",      "%Dd,%Sd,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD), 
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|CF), DNA)

#define RCLB_IMPL              \
{                  \
  byte_t _res, _src, _cf, _shamt;          \
  \
  _src = GPR_B(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (GPR_B(URT) & 0x1f) % 9;          \
  _res = RCL_B(_src, _cf, _shamt);          \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCLB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCLB,      0x00,
      "rclb",      "%Db,%Sb,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCLBI_IMPL              \
{                  \
  byte_t _res, _src, _cf, _shamt;          \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (UIMMB & 0x1f) % 9;          \
  _res = RCL_B(_src, _cf, _shamt);          \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCLB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCLBI,      0x00,
      "rclb",      "%Db,%Sb,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCLW_IMPL              \
{                  \
  word_t _res, _src, _cf;            \
  byte_t _shamt;              \
  \
  _src = GPR_W(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (GPR_B(URT) & 0x1f) % (BITSIZE_W+1);      \
  _res = RCL_W(_src, _cf, _shamt);          \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCLW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCLW,      0x00,
      "rclw",      "%Dw,%Sw,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCLWI_IMPL              \
{                  \
  word_t _res, _src, _cf;            \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (UIMMB & 0x1f) % (BITSIZE_W+1);        \
  _res = RCL_W(_src, _cf, _shamt);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCLW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCLWI,      0x00,
      "rclw",      "%Dw,%Sw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCLD_IMPL              \
{                  \
  dword_t _res, _src, _cf;            \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (GPR_B(URT) & 0x1f) % (BITSIZE_D+1);      \
  _res = RCL_D(_src, _cf, _shamt);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCLD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCLD,      0x00,
      "rcld",      "%Dd,%Sd,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCLDI_IMPL              \
{                  \
  dword_t _res, _src, _cf;            \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (UIMMB & 0x1f) % (BITSIZE_D+1);        \
  _res = RCL_D(_src, _cf, _shamt);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCLD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCLDI,      0x00,
      "rcld",      "%Dd,%Sd,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF)) 

#define RCRB_IMPL              \
{                  \
  byte_t _res, _src, _cf, _shamt;          \
  \
  _src = GPR_B(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (GPR_B(URT) & 0x1f) % 9;          \
  _res = RCR_B(_src, _cf, _shamt);          \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCRB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCRB,      0x00,
      "rcrb",      "%Db,%Sb,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCRBI_IMPL              \
{                  \
  byte_t _res, _src, _cf, _shamt;          \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (UIMMB & 0x1f) % 9;          \
  _res = RCR_B(_src, _cf, _shamt);          \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCRB(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCRBI,      0x00,
      "rcrb",      "%Db,%Sb,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCRW_IMPL              \
{                  \
  word_t _res, _src, _cf;            \
  byte_t _shamt;              \
  \
  _src = GPR_W(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (GPR_B(URT) & 0x1f) % (BITSIZE_W+1);      \
  _res = RCR_W(_src, _cf, _shamt);          \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCRW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCRW,      0x00,
      "rcrw",      "%Dw,%Sw,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DNA/*PRD handled by uop flow*/,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCRWI_IMPL              \
{                  \
  word_t _res, _src, _cf;            \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (UIMMB & 0x1f) % (BITSIZE_W+1);        \
  _res = RCR_W(_src, _cf, _shamt);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCRW(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCRWI,      0x00,
      "rcrw",      "%Dw,%Sw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCRD_IMPL              \
{                  \
  dword_t _res, _src, _cf;            \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (GPR_B(URT) & 0x1f) % (BITSIZE_D+1);      \
  _res = RCR_D(_src, _cf, _shamt);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCRD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCRD,      0x00,
      "rcrd",      "%Dd,%Sd,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define RCRDI_IMPL              \
{                  \
  dword_t _res, _src, _cf;            \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _cf = !!AFLAGS(CF);              \
  _shamt = (UIMMB & 0x1f) % (BITSIZE_D+1);        \
  _res = RCR_D(_src, _cf, _shamt);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_RCRD(_res, _src, _shamt), OF|CF);    \
}
  DEFUOP(RCRDI,      0x00,
      "rcrd",      "%Dd,%Sd,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|CF), DAFLAGS(CF))

#define SHLB_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SHL_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHLB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHLB,      0x00,
      "shlb",      "%Db,%Sb,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHLBI_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SHL_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHLB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHLBI,      0x00,
      "shlb",      "%Db,%Sb,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHLW_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SHL_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHLW(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHLW,      0x00,
      "shlw",      "%Dw,%Sw,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHLWI_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SHL_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHLW(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHLWI,      0x00,
      "shlw",      "%Dw,%Sw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHLD_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SHL_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHLD(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHLD,      0x00,
      "shld",      "%Dd,%Sd,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHLDI_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SHL_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHLD(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHLDI,      0x00,
      "shld",      "%Dd,%Sd,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHRB_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SHR_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHRB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHRB,      0x00,
      "shrb",      "%Db,%Sb,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHRBI_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SHR_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHRB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHRBI,      0x00,
      "shrb",      "%Db,%Sb,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHRW_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SHR_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHRW(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHRW,      0x00,
      "shrw",      "%Dw,%Sw,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHRWI_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SHR_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHRW(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHRWI,      0x00,
      "shrw",      "%Dw,%Sw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHRD_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SHR_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHRD(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHRD,      0x00,
      "shrd",      "%Dd,%Sd,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SHRDI_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SHR_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SHRD(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SHRDI,      0x00,
      "shrd",      "%Dd,%Sd,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SARB_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SAR_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SARB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SARB,      0x00,
      "sarb",      "%Db,%Sb,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SARBI_IMPL              \
{                  \
  byte_t _res, _src, _shamt;            \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SAR_B(_src, _shamt);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SARB(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SARBI,      0x00,
      "sarb",      "%Db,%Sb,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SARW_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SAR_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SARW(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SARW,      0x00,
      "sarw",      "%Dw,%Sw,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SARWI_IMPL              \
{                  \
  word_t _res, _src;              \
  byte_t _shamt;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SAR_W(_src, _shamt);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SARW(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SARWI,      0x00,
      "sarw",      "%Dw,%Sw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SARD_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = GPR_B(URT) & 0x1f;            \
  _res = SAR_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SARD(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SARD,      0x00,
      "sard",      "%Dd,%Sd,%Tb",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define SARDI_IMPL              \
{                  \
  dword_t _res, _src;              \
  byte_t _shamt;              \
  \
  _src = GPR_D(URS);              \
  _shamt = UIMMB & 0x1f;            \
  _res = SAR_D(_src, _shamt);            \
  SET_GPR_D(URD, _res);            \
  if (ISUV && _shamt)              \
  SET_AFLAGS(AFLAGS_SARD(_res, _src, _shamt), OF|SF|ZF|CF|PF);  \
}
  DEFUOP(SARDI,      0x00,
      "sard",      "%Dd,%Sd,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|CF|PF), DNA)

#define NOTB_IMPL              \
{                  \
  byte_t _res, _src;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _res = ~_src;              \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
}
  DEFUOP(NOTB,      0x00,
      "notb",      "%Db,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DNA, DNA)

#define NOTW_IMPL              \
{                  \
  word_t _res, _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = ~_src;              \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(NOTW,      0x00,
      "notw",      "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

#define NOTD_IMPL              \
{                  \
  dword_t _res, _src;              \
  \
  _src = GPR_D(URS);              \
  _res = ~_src;              \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(NOTD,      0x00,
      "notd",      "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)

#define NEGB_IMPL              \
{                  \
  byte_t _res, _src;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = GPR_B(URS);              \
  _res = -_src;              \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_NEGB(_res, _src), OF|SF|ZF|AF|CF|PF);    \
}
  DEFUOP(NEGB,      0x00,
      "negb",      "%Db,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define NEGW_IMPL              \
{                  \
  word_t _res, _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = -_src;              \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_NEGW(_res, _src), OF|SF|ZF|AF|CF|PF);    \
}
  DEFUOP(NEGW,      0x00,
      "negw",      "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define NEGD_IMPL              \
{                  \
  dword_t _res, _src;              \
  \
  _src = GPR_D(URS);              \
  _res = -_src;              \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_NEGD(_res, _src), OF|SF|ZF|AF|CF|PF);    \
}
  DEFUOP(NEGD,      0x00,
      "negd",      "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define IMULB_IMPL              \
{                  \
  byte_t _src1, _src2;            \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = IMUL_B(_src1, _src2);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULB(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULB,      0x00,
      "imulb",    "%Dw,%Sb,%Tb",
      FU_IMUL,           F_ICOMP,
      DGPR_W(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULBI_IMPL              \
{                  \
  byte_t _src1, _src2;            \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _res = IMUL_B(_src1, _src2);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULB(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULBI,      0x00,
      "imulb",    "%Dw,%Sb,%Ib",
      FU_IMUL,    F_ICOMP,
      DGPR_W(URD),
      DGPR_B(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULW_IMPL              \
{                  \
  word_t _src1, _src2;            \
  dword_t _res;              \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = IMUL_W(_src1, _src2);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULW(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULW,      0x00,
      "imulw",    "%Dd,%Sw,%Tw",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD),
      DGPR_W(URS), DGPR_W(URT), DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULWI_IMPL              \
{                  \
  word_t _src1, _src2;            \
  dword_t _res;              \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMW;              \
  _res = IMUL_W(_src1, _src2);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULW(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULWI,      0x00,
      "imulw",    "%Dd,%Sw,%Iw",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD),
      DGPR_W(URS), DNA, DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULD_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = IMUL_D(_src1, _src2);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULD(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULD,      0x00,
      "imuld",    "%Dd,%Sd,%Td",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULDI_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMD;              \
  _res = IMUL_D(_src1, _src2);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULD(_res, _src1, _src2), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULDI,      0x00,
      "imuld",    "%Dd,%Sd,%Id",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD), 
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define MULB_IMPL              \
{                  \
  byte_t _src1, _src2;            \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = MUL_B(_src1, _src2);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_MULB(_res), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFUOP(MULB,      0x00,
      "mulb",      "%Dw,%Sb,%Tb",
      FU_IMUL,    F_ICOMP,
      DGPR_W(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define MULBI_IMPL              \
{                  \
  byte_t _src1, _src2;            \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = UIMMB;              \
  _res = MUL_B(_src1, _src2);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_MULB(_res), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFUOP(MULBI,      0x00,
      "mulb",      "%Dw,%Sb,%Ib",
      FU_IMUL,    F_ICOMP,
      DGPR_W(URD),
      DGPR_B(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define QUOB_IMPL              \
{                  \
  word_t _src1;              \
  byte_t _res, _src2;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_B(URT);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = QUO_B(_src1, _src2);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
}
  DEFUOP(QUOB,      0x00,
      "quob",      "%Db,%Sw,%Tb",
      FU_IDIV,      F_ICOMP,
      DGPR_B(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DNA, DNA)

#define QUOW_IMPL              \
{                  \
  word_t _src1hi, _src1lo, _src2, _res;        \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1hi = GPR_W(URS);            \
  _src1lo = GPR_W(URT);            \
  _src2 = GPR_W(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = QUO_W(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(QUOW,      0x00,
      "quow",      "%Dw,%Sw,%Tw,%Uw",
      FU_IDIV,      F_ICOMP,
      DGPR_W(URD), /* PRD not needed since dest is always a temp */
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URU),
      DNA, DNA)

#define QUOD_IMPL              \
{                  \
  dword_t _src1hi, _src1lo, _src2, _res;        \
  \
  _src1hi = GPR_D(URS);            \
  _src1lo = GPR_D(URT);            \
  _src2 = GPR_D(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = QUO_D(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(QUOD,      0x00,
      "quod",      "%Dd,%Sd,%Td,%Ud",
      FU_IDIV,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_D(URU),
      DNA, DNA)

#define REMB_IMPL              \
{                  \
  word_t _src1;              \
  byte_t _res, _src2;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_B(URT);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = REM_B(_src1, _src2);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_DIVB(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(REMB,      0x00,
      "remb",      "%Db,%Sw,%Tb",
      FU_IDIV,      F_ICOMP,
      DGPR_B(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define REMW_IMPL              \
{                  \
  word_t _src1hi, _src1lo, _src2, _res;        \
  dword_t _orig = GPR_D(URD);             \
  assert(URS==URD); /* added to check PRD assumption described below */ \
  \
  _src1hi = GPR_W(URS);            \
  _src1lo = GPR_W(URT);            \
  _src2 = GPR_W(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = REM_W(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_DIVW(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(REMW,      0x00,
      "remw",      "%Dw,%Sw,%Tw,%Uw",
      FU_IDIV,      F_ICOMP,
      DGPR_W(URD), /* PRD not explicitly listed because URS always equals URD in x86flow.def */
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URU),
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define REMD_IMPL              \
{                  \
  dword_t _src1hi, _src1lo, _src2, _res;        \
  \
  _src1hi = GPR_D(URS);            \
  _src1lo = GPR_D(URT);            \
  _src2 = GPR_D(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = REM_D(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_DIVD(), (OF|SF|ZF|AF|CF|PF));      \
}
  DEFUOP(REMD,      0x00,
      "remd",      "%Dd,%Sd,%Td,%Ud",
      FU_IDIV,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_D(URU),
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define IQUOB_IMPL              \
{                  \
  word_t _src1;              \
  byte_t _res, _src2;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_B(URT);              \
  if(_src2 == 0) {  \
    if(Mop->oracle.spec_mode) _res = 0; \
    else fatal("non-speculative divide by zero"); \
  } else _res = IQUO_B(_src1, _src2);          \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
}
  DEFUOP(IQUOB,      0x00,
      "iquob",    "%Db,%Sw,%Tb",
      FU_IDIV,      F_ICOMP,
      DGPR_B(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DNA, DNA)

#define IQUOW_IMPL              \
{                  \
  word_t _src1hi, _src1lo, _src2, _res;        \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1hi = GPR_W(URS);            \
  _src1lo = GPR_W(URT);            \
  _src2 = GPR_W(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = IQUO_W(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(IQUOW,      0x00,
      "iquow",    "%Dw,%Sw,%Tw,%Uw",
      FU_IDIV,     F_ICOMP,
      DGPR_W(URD), /* PRD not needed since dest is always a temp */
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URU),
      DNA, DNA)

#define IQUOD_IMPL              \
{                  \
  dword_t _src1hi, _src1lo, _src2, _res;        \
  \
  _src1hi = GPR_D(URS);            \
  _src1lo = GPR_D(URT);            \
  _src2 = GPR_D(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = IQUO_D(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(IQUOD,      0x00,
      "iquod",    "%Dd,%Sd,%Td,%Ud",
      FU_IDIV,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_D(URU),
      DNA, DNA)

#define IREMB_IMPL              \
{                  \
  word_t _src1;              \
  byte_t _res, _src2;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_B(URT);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = REM_B(_src1, _src2);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_DIVB(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(IREMB,      0x00,
      "iremb",    "%Db,%Sw,%Tb",
      FU_IDIV,      F_ICOMP,
      DGPR_B(URD), 
      DGPR_W(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define IREMW_IMPL              \
{                  \
  word_t _src1hi, _src1lo, _src2, _res;        \
  dword_t _orig = GPR_D(URD);             \
  assert(URS==URD); /* added to check PRD assumption described below */ \
  \
  _src1hi = GPR_W(URS);            \
  _src1lo = GPR_W(URT);            \
  _src2 = GPR_W(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = IREM_W(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_DIVW(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(IREMW,      0x00,
      "iremw",    "%Dw,%Sw,%Tw,%Uw",
      FU_IDIV,      F_ICOMP,
      DGPR_W(URD), /* PRD not needed because URS always equals URD in x86flow.def (should use UOP_R3 instead?) */
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URU),
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define IREMD_IMPL              \
{                  \
  dword_t _src1hi, _src1lo, _src2, _res;        \
  \
  _src1hi = GPR_D(URS);            \
  _src1lo = GPR_D(URT);            \
  _src2 = GPR_D(URU);              \
  \
  if (_src2 == 0)              \
  DECLARE_FAULT(md_fault_div0);          \
  \
  _res = IREM_D(_src1hi, _src1lo, _src2);        \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_DIVD(), OF|SF|ZF|AF|CF|PF);      \
}
  DEFUOP(IREMD,      0x00,
      "iremd",    "%Dd,%Sd,%Td,%Ud",
      FU_IDIV,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_D(URU),
      DAFLAGS(OF|SF|ZF|AF|CF|PF), DNA)

#define MULHIW_IMPL              \
{                  \
  word_t _src1, _src2, _res;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = MULHI_W(_src1, _src2);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_MULW(_res), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFUOP(MULHIW,      0x00,
      "mulhiw",    "%Dw,%Sw,%Tw",
      FU_IMUL,    F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define MULHID_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = MULHI_D(_src1, _src2);          \
  SET_GPR_D(URD, _res);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_MULD(_res), OF|CF/*|SF|ZF|AF|PF*/);    \
}
  DEFUOP(MULHID,      0x00,
      "mulhid",    "%Dd,%Sd,%Td",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define MULLOW_IMPL              \
{                  \
  word_t _src1, _src2, _res;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = MULLO_W(_src1, _src2);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(MULLOW,      0x00,
      "mullow",    "%Dw,%Sw,%Tw",
      FU_IMUL,    F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define MULLOD_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = MULLO_D(_src1, _src2);          \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(MULLOD,      0x00,
      "mullod",    "%Dd,%Sd,%Td",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULHIW_IMPL              \
{                  \
  word_t _src1, _src2, _reshi, _reslo;        \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _reshi = IMULHI_W(_src1, _src2);          \
  _reslo = IMULLO_W(_src1, _src2);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _reshi);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULHIW(_reshi, _reslo), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULHIW,    0x00,
      "imulhiw",    "%Dw,%Sw,%Tw",
      FU_IMUL,    F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULHID_IMPL              \
{                  \
  dword_t _src1, _src2, _reshi, _reslo;        \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _reshi = IMULHI_D(_src1, _src2);          \
  _reslo = IMULLO_D(_src1, _src2);          \
  SET_GPR_D(URD, _reshi);            \
  if (ISUV)                \
  SET_AFLAGS(AFLAGS_IMULHID(_reshi, _reslo), OF|CF/*|SF|ZF|AF|PF*/);\
}
  DEFUOP(IMULHID,    0x00,
      "imulhid",    "%Dd,%Sd,%Td",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULLOW_IMPL              \
{                  \
  word_t _src1, _src2, _res;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = IMULLO_W(_src1, _src2);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(IMULLOW,    0x00,
      "mullow",    "%Dw,%Sw,%Tw",
      FU_IMUL,    F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define IMULLOD_IMPL              \
{                  \
  dword_t _src1, _src2, _res;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = IMULLO_D(_src1, _src2);          \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(IMULLOD,    0x00,
      "imullod",    "%Dd,%Sd,%Td",
      FU_IMUL,    F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DAFLAGS(OF|CF/*SF|ZF|AF|PF*/), DNA)

#define BSWAP_IMPL              \
{                  \
  dword_t _res, _src;              \
  \
  _src = GPR_D(URS);              \
  _res = BSWAP(_src);              \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(BSWAP,      0x00,
      "bswap",    "%Dd,%Sd",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)

#define CMOVW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _aflags;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  \
  _res = CC_EVAL(ULIT, _aflags) ? _src2 : _src1;      \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(CMOVW,      0x00,
      "cmov%cc",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DNA, DNA)

#define CMOVD_IMPL              \
{                  \
  dword_t _res, _src1, _src2, _aflags;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  \
  _res = CC_EVAL(ULIT, _aflags) ? _src2 : _src1;      \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(CMOVD,      0x00,
      "cmov%cc",    "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DNA, DNA)

#define SETCC_IMPL              \
{                  \
  dword_t _aflags;              \
  byte_t _res;              \
  dword_t _orig = GPR_DB(URS);             \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  _res = CC_EVAL(UCC, _aflags) ? 1 : 0;        \
  SET_GPR_DB(URS, _orig);            \
  SET_GPR_B(URS, _res);            \
}
  DEFUOP(SETCC,      0x00,
      "set%cc",    "%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URS),
      DGPR_B(URS)/*PRD*/, DNA, DNA,
      DNA, DAFLAGS(OF|SF|ZF|CF|PF))

#define BTSW_IMPL              \
{                  \
  word_t _res, _src1;              \
  byte_t _src2;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_B(URT);              \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_W)-1));    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_W)-1)), CF);  \
}
  DEFUOP(BTSW,      0x00,
      "btsw",      "%Dw,%Sw,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(CF), DNA)

#define BTSWI_IMPL              \
{                  \
  word_t _res, _src1;              \
  byte_t _src2;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMB;              \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_W)-1));    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_W)-1)), CF);  \
}
  DEFUOP(BTSWI,      0x00,
      "btsw",      "%Dw,%Sw,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(CF), DNA)

#define BTSD_IMPL              \
{                  \
  dword_t _res, _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_B(URT);              \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_D)-1));    \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_D)-1)), CF);  \
}
  DEFUOP(BTSD,      0x00,
      "btsd",      "%Dd,%Sd,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(CF), DNA)

#define BTSDI_IMPL              \
{                  \
  dword_t _res, _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMB;              \
  _res = BTS_V(_src1, _src2 & ((1 << LOGBITSIZE_D)-1));    \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_D)-1)), CF);  \
}
  DEFUOP(BTSDI,      0x00,
      "btsd",      "%Dd,%Sd,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(CF), DNA)

#define BTRW_IMPL              \
{                  \
  word_t _res, _src1;              \
  byte_t _src2;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_B(URT);              \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_W)-1));    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_W)-1)), CF);  \
}
  DEFUOP(BTRW,      0x00,
      "btrw",      "%Dw,%Sw,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(CF), DNA)

#define BTRWI_IMPL              \
{                  \
  word_t _res, _src1;              \
  byte_t _src2;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMB;              \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_W)-1));    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_W)-1)), CF);  \
}
  DEFUOP(BTRWI,      0x00,
      "btrw",      "%Dw,%Sw,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(CF), DNA)

#define BTRD_IMPL              \
{                  \
  dword_t _res, _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_B(URT);              \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_D)-1));    \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_D)-1)), CF);  \
}
  DEFUOP(BTRD,      0x00,
      "btrd",      "%Dd,%Sd,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(CF), DNA)

#define BTRDI_IMPL              \
{                  \
  dword_t _res, _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMB;              \
  _res = BTR_V(_src1, _src2 & ((1 << LOGBITSIZE_D)-1));    \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_D)-1)), CF);  \
}
  DEFUOP(BTRDI,      0x00,
      "btrd",      "%Dd,%Sd,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(CF), DNA)

#define BTCW_IMPL              \
{                  \
  word_t _res, _src1;              \
  byte_t _src2;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_B(URT);              \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_W)-1));    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_W)-1)), CF);  \
}
  DEFUOP(BTCW,      0x00,
      "btcw",      "%Dw,%Sw,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_B(URT), DGPR_W(URD)/*PRD*/,
      DAFLAGS(CF), DNA)

#define BTCWI_IMPL              \
{                  \
  word_t _res, _src1;              \
  byte_t _src2;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMB;              \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_W)-1));    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_W)-1)), CF);  \
}
  DEFUOP(BTCWI,      0x00,
      "btcw",      "%Dw,%Sw,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(CF), DNA)

#define BTCD_IMPL              \
{                  \
  dword_t _res, _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_B(URT);              \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_D)-1));    \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_D)-1)), CF);  \
}
  DEFUOP(BTCD,      0x00,
      "btcd",      "%Dd,%Sd,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_B(URT), DNA,
      DAFLAGS(CF), DNA)

#define BTCDI_IMPL              \
{                  \
  dword_t _res, _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMB;              \
  _res = BTC_V(_src1, _src2 & ((1 << LOGBITSIZE_D)-1));    \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BTV(_src1, _src2 & ((1 << LOGBITSIZE_D)-1)), CF);  \
}
  DEFUOP(BTCDI,      0x00,
      "btcd",      "%Dd,%Sd,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(CF), DNA)

#define MOVSXBW_IMPL              \
{                  \
  byte_t _src;              \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_B(URS);              \
  _res = MOVSX_WB(_src);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(MOVSXBW,    0x00,
      "movsxbw",    "%Dw,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_B(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

#define MOVSXBD_IMPL              \
{                  \
  byte_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_B(URS);              \
  _res = MOVSX_DB(_src);            \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(MOVSXBD,    0x00,
      "movsxbd",    "%Dd,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_B(URS), DNA, DNA,
      DNA, DNA)

#define MOVSXWW_IMPL              \
{                  \
  word_t _src;              \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = MOVSX_WW(_src);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(MOVSXWW,    0x00,
      "movsxww",    "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

#define MOVSXWD_IMPL              \
{                  \
  word_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_W(URS);              \
  _res = MOVSX_DW(_src);            \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(MOVSXWD,    0x00,
      "movsxwd",    "%Dd,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_W(URS), DNA, DNA,
      DNA, DNA)

#define MOVZXBW_IMPL              \
{                  \
  byte_t _src;              \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_B(URS);              \
  _res = MOVZX_WB(_src);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(MOVZXBW,    0x00,
      "movzxbw",    "%Dw,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_B(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

#define MOVZXBD_IMPL              \
{                  \
  byte_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_B(URS);              \
  _res = MOVZX_DB(_src);            \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(MOVZXBD,    0x00,
      "movzxbd",    "%Dd,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_B(URS), DNA, DNA,
      DNA, DNA)

#define MOVZXWW_IMPL              \
{                  \
  word_t _src;              \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = MOVZX_WW(_src);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(MOVZXWW,    0x00,
      "movzxww",    "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

#define MOVZXWD_IMPL              \
{                  \
  word_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_W(URS);              \
  _res = MOVZX_DW(_src);            \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(MOVZXWD,    0x00,
      "movzxwd",    "%Dd,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_W(URS), DNA, DNA,
      DNA, DNA)

#define BSFW_IMPL              \
{                  \
  word_t _res, _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = BSF_W(_src);              \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BSFW(_src), ZF);          \
}
  DEFUOP(BSFW,      0x00,
      "bsfw",      "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(ZF), DNA)

#define BSFD_IMPL              \
{                  \
  dword_t _res, _src;              \
  \
  _src = GPR_D(URS);              \
  _res = BSF_D(_src);              \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BSFD(_src), ZF);          \
}
  DEFUOP(BSFD,      0x00,
      "bsfd",      "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(ZF), DNA)

#define BSRW_IMPL              \
{                  \
  word_t _res, _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = BSR_W(_src);              \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
  SET_AFLAGS(AFLAGS_BSRW(_src), ZF);          \
}
  DEFUOP(BSRW,      0x00,
      "bsrw",      "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DAFLAGS(ZF), DNA)

#define BSRD_IMPL              \
{                  \
  dword_t _res, _src;              \
  \
  _src = GPR_D(URS);              \
  _res = BSR_D(_src);              \
  SET_GPR_D(URD, _res);            \
  SET_AFLAGS(AFLAGS_BSRD(_src), ZF);          \
}
  DEFUOP(BSRD,      0x00,
      "bsrd",      "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DAFLAGS(ZF), DNA)

#define INT_IMPL              \
{                  \
  /* XXX FIXME: implement... */                 \
  /* Cast Hack for x86 could break eio support */                     \
  if (UIMMUB == 0x80)              \
  SYSCALL(*(md_inst_t*)uop);                                        \
  else                \
  DECLARE_FAULT(md_fault_unimpl);          \
}
  DEFUOP(INT,      0x00,
      "int",      "%Ib",
      FU_NA,      F_TRAP,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define SHLDW_IMPL              \
{                  \
  word_t _src1, _src2, _shamt, _res;          \
  dword_t _orig = GPR_D(URD);             \
  assert(URS==URD); /* added to check PRD assumption described below */ \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _shamt = GPR_B(URU) & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_W)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_W-_shamt));  \
    \
    SET_GPR_D(URD, _orig);            \
    SET_GPR_W(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHLDW(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHLDW,      0x00,
      "shldw",    "%Dw,%Sw,%Tw,%Ub",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD), /* PRD not needed because URS always equals URD in x86flow.def (should use UOP_R3 instead?) */
      DGPR_W(URS), DGPR_W(URT), DGPR_B(URU),
      DNA, DNA)

#define SHLDWI_IMPL              \
{                  \
  word_t _src1, _src2, _shamt, _res;          \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _shamt = UIMMB & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_W)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_W-_shamt));  \
    \
    SET_GPR_D(URD, _orig);            \
    SET_GPR_W(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHLDW(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHLDWI,      0x00,
      "shldwi",    "%Dw,%Sw,%Tw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DNA, DNA)

#define SHLDD_IMPL              \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _shamt = GPR_B(URU) & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_D)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_D-_shamt));  \
    \
    SET_GPR_D(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHLDD(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHLDD,      0x00,
      "shldd",    "%Dd,%Sd,%Td,%Ub",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_B(URU),
      DNA, DNA)

#define SHLDDI_IMPL              \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _shamt = UIMMB & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_D)        \
  {                  \
    _res = (_src1 << _shamt) | (_src2 >> (BITSIZE_D-_shamt));  \
    \
    SET_GPR_D(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHLDD(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHLDDI,      0x00,
      "shlddi",    "%Dd,%Sd,%Td,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DNA, DNA)

#define SHRDW_IMPL              \
{                  \
  word_t _src1, _src2, _shamt, _res;          \
  dword_t _orig = GPR_D(URD);             \
  \
  assert(URS==URD); /* added to check PRD assumption described below */ \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _shamt = GPR_B(URU) & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_W)        \
  {                  \
    _res = (_src2 << (BITSIZE_W - _shamt)) | (_src1 >> _shamt);  \
    \
    SET_GPR_D(URD, _orig);            \
    SET_GPR_W(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHRDW(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHRDW,      0x00,
      "shrdw",    "%Dw,%Sw,%Tw,%Ub",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD), /* PRD not needed because URS always equals URD in x86flow.def (should use UOP_R3 instead?) */
      DGPR_W(URS), DGPR_W(URT), DGPR_B(URU),
      DNA, DNA)

#define SHRDWI_IMPL              \
{                  \
  word_t _src1, _src2, _shamt, _res;          \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _shamt = UIMMB & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_W)        \
  {                  \
    _res = (_src2 << (BITSIZE_W - _shamt)) | (_src1 >> _shamt);  \
    \
    SET_GPR_D(URD, _orig);            \
    SET_GPR_W(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHRDW(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHRDWI,      0x00,
      "shrdwi",    "%Dw,%Sw,%Tw,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DNA, DNA)

#define SHRDD_IMPL              \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _shamt = GPR_B(URU) & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_D)        \
  {                  \
    _res = (_src2 << (BITSIZE_D - _shamt)) | (_src1 >> _shamt);  \
    \
    SET_GPR_D(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHRDD(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHRDD,      0x00,
      "shrdd",    "%Dd,%Sd,%Td,%Ub",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_B(URU),
      DNA, DNA)

#define SHRDDI_IMPL              \
{                  \
  dword_t _src1, _src2, _shamt, _res;          \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _shamt = UIMMB & 0x1f;            \
  if (_shamt > 0 && _shamt < BITSIZE_D)        \
  {                  \
    _res = (_src2 << (BITSIZE_D - _shamt)) | (_src1 >> _shamt);  \
    \
    SET_GPR_D(URD, _res);            \
    SET_AFLAGS(AFLAGS_SHRDD(_res, _src1, _shamt), OF|CF|SF|ZF|PF);  \
  }                  \
}
  DEFUOP(SHRDDI,      0x00,
      "shrddi",    "%Dd,%Sd,%Td,%Ib",
      FU_SHIFT,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DNA, DNA)


  /* system-level operations */

#define UHLT_IMPL              \
{                  \
  extern jmp_buf sim_exit_buf;          \
  \
  if(!Mop->oracle.spec_mode) { \
    fprintf(stderr, "** UHLT executed...\n");        \
    longjmp(sim_exit_buf, /* exitcode + fudge */0 + 1);      \
  } \
}
  DEFUOP(UHLT,      0x00,
      "uhlt",      "",
      FU_NA,      F_TRAP,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define ADDFW_IMPL              \
{                  \
  dword_t _orig = GPR_D(URD);             \
  SET_GPR_D(URD, _orig);        \
  if (!AFLAGS(DF))              \
  SET_GPR_W(URD, GPR_W(URS) + UIMMB);        \
  else                \
  SET_GPR_W(URD, GPR_W(URS) - UIMMB);        \
}
  DEFUOP(ADDFW,      0x00,
      "addfw",    "%Dw,%Sw,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DAFLAGS(DF))

#define ADDFD_IMPL              \
{                  \
  if (!AFLAGS(DF))              \
  SET_GPR_D(URD, GPR_D(URS) + UIMMB);        \
  else                \
  SET_GPR_D(URD, GPR_D(URS) - UIMMB);        \
}
  DEFUOP(ADDFD,      0x00,
      "addfd",    "%Dd,%Sd,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DNA, DAFLAGS(DF))

  /* memory access instructions */
  /* WARNING: Be careful about the use of AGEN vs. STA in uop flows.
     AGEN is used to compute an address that will be stored in a
     register, whereas STA (and the BGEN equivalents) is used
     specifically in combination with a STD uop.  The choice
     affects store-queue allocation and execution port assignment.
     Like the Intel implementations, loads are single uops (i.e.
     they do not have separate AGEN uops associated with them as
     you may be used to from the old-skool SimpleScalar organization). */

#define AGENW_IMPL              \
{                  \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  SET_GPR_D(URD, _addr);            \
}
  DEFUOP(AGENW,      0x00,
      "agenw",    "%Dw,%Sw,%Tw,%Li,%Iw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_W(URS), DGPR_W(URT), DSEG(USG),
      DNA, DNA)

#define AGEND_IMPL              \
{                  \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  SET_GPR_D(URD, _addr);            \
}
  DEFUOP(AGEND,      0x00,
      "agend",    "%Dd,%Sd,%Td,%Li,%Id",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DSEG(USG),
      DNA, DNA)

  /* These uops are identical to AGEN, but these will be allocated
     a store queue entry */

#define STAW_IMPL  AGENW_IMPL
  DEFUOP(STAW,      0x00,
      "staw",    "%Dw,%Sw,%Tw,%Li,%Iw",
      FU_STA,      F_ICOMP,
      DGPR_D(URD),
      DGPR_W(URS), DGPR_W(URT), DSEG(USG),
      DNA, DNA)

#define STAD_IMPL  AGEND_IMPL
  DEFUOP(STAD,      0x00,
      "stad",    "%Dd,%Sd,%Td,%Li,%Id",
      FU_STA,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DSEG(USG),
      DNA, DNA)

  /* All load instructions have mnenomics of the form
     OPXY, where OP is the opcode (e.g., LDB), X is the
     width specifier for the AGEN, and Y is the width
     specifier for the loaded data.  This implements loads
     as single uops, which is different from the
     traditional SimpleScalar AGEN-LD sequence (but Intel
     cores use single-uop loads).
   */

#define LDWB_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  byte_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
}
  DEFUOP(LDWB,      0x00,
      "ldb",      "%Db,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DGPR_B(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG)/*PRD handled by uop flow*/,
      DNA, DNA)

#define LDDB_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  byte_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_BYTE(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
}
  DEFUOP(LDDB,      0x00,
      "ldb",      "%Db,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DGPR_B(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG)/*PRD handled by uop flow*/,
      DNA, DNA)

#define STB_IMPL              \
{                  \
  byte_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_B(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_BYTE(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(STB,      0x00,
      "stb",      "%Db,(%Sd)",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URD), DGPR_B(URS), DNA,
      DNA, DNA)

#define LDSWW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  word_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_SEG_W(URD, _res);            \
}
  DEFUOP(LDSWW,      0x00,
      "ldsw",      "%Dw,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DSEG(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define LDSDW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  word_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_SEG_W(URD, _res);            \
}
  DEFUOP(LDSDW,      0x00,
      "ldsw",      "%Dw,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DSEG(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)


#define LDWW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(LDWW,      0x00,
      "ldw",      "%Dw,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DGPR_W(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG)/*No PRD since op only used by MOV[ZS]X */,
      DNA, DNA)

#define LDDW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  word_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(LDDW,      0x00,
      "ldw",      "%Dw,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DGPR_W(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG)/*No PRD since op only used by MOV[ZS]X */,
      DNA, DNA)

#define STSW_IMPL              \
{                  \
  word_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = SEG_W(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_WORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(STSW,      0x00,
      "stsw",      "%Dw,(%Sd)",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DSEG(URD), DNA,
      DNA, DNA)


#define STW_IMPL              \
{                  \
  word_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_W(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_WORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(STW,      0x00,
      "stw",      "%Dw,(%Sd)",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DGPR_W(URD), DNA,
      DNA, DNA)

#define LDSWD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_DWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_SEG_W(URD, _res);            \
}
  DEFUOP(LDSWD,      0x00,
      "ldsd",      "%Dd,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DSEG(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define LDSDD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_DWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_SEG_W(URD, _res);            \
}
  DEFUOP(LDSDD,      0x00,
      "ldsd",      "%Dd,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DSEG(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)


#define LDWD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_DWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(LDWD,      0x00,
      "ldd",      "%Dd,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DGPR_D(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define LDDD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_DWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(LDDD,      0x00,
      "ldd",      "%Dd,(%Sd)",
      FU_LD,      F_MEM|F_LOAD,
      DGPR_D(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define STSD_IMPL              \
{                  \
  dword_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = SEG_W(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_DWORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(STSD,      0x00,
      "stsd",      "%Dd,(%Sd)",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DSEG(URD), DNA,
      DNA, DNA)


#define STD_IMPL              \
{                  \
  dword_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = GPR_D(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_DWORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(STD,      0x00,
      "std",      "%Dd,(%Sd)",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DGPR_D(URD), DNA,
      DNA, DNA)

#define LDPCWW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_TPC_D(_res);              \
  SET_NPC_D(_res);              \
}
  DEFUOP(LDPCWW,      0x00,
      "ldpcw",    "PC,(%Sd)",
      FU_LD,      F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_RETN,
      DNA,
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define LDPCDW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_TPC_D(_res);              \
  SET_NPC_D(_res);              \
}
  DEFUOP(LDPCDW,      0x00,
      "ldpcw",    "PC,(%Sd)",
      FU_LD,      F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_RETN,
      DNA,
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define STPCW_IMPL              \
{                  \
  dword_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = NPC;                \
  _addr = GPR_D(URS);              \
  WRITE_WORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(STPCW,      0x00,
      "stpcw",    "PC,(%Sd)",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)

#define LDPCWD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_DWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_TPC_D(_res);              \
  SET_NPC_D(_res);              \
}
  DEFUOP(LDPCWD,      0x00,
      "ldpcd",    "PC,(%Sd)",
      FU_LD,      F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_RETN,
      DNA,
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define LDPCDD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  dword_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_DWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_TPC_D(_res);              \
  SET_NPC_D(_res);              \
}
  DEFUOP(LDPCDD,      0x00,
      "ldpcd",    "PC,(%Sd)",
      FU_LD,      F_MEM|F_LOAD|F_CTRL|F_UNCOND|F_RETN,
      DNA,
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define STPCD_IMPL              \
{                  \
  dword_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = NPC;                \
  _addr = GPR_D(URS);              \
  WRITE_DWORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(STPCD,      0x00,
      "stpcd",    "PC,(%Sd)",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)

  /* used by BT* instructions that access memory */
#define BGENW_IMPL              \
{                  \
  word_t _res, _src1, _src2;            \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 + ((_src2 >> LOGBITSIZE_W) << LOGSIZE_W);    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(BGENW,      0x00,
      "bgenw",    "%Dw,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DNA, DNA)

  /* used by BT* instructions that access memory */
#define BGENWI_IMPL              \
{                  \
  word_t _res, _src1;              \
  byte_t _src2;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = UIMMB;              \
  _res = _src1 + ((_src2 >> LOGBITSIZE_W) << LOGSIZE_W);    \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(BGENWI,      0x00,
      "bgenw",    "%Dw,%Sw,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

  /* used by BT* instructions that access memory */
#define BGEND_IMPL              \
{                  \
  dword_t _res, _src1, _src2;            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 + ((_src2 >> LOGBITSIZE_W) << LOGSIZE_W);    \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(BGEND,      0x00,
      "bgend",    "%Dd,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DNA, DNA)

  /* used by BT* instructions that access memory */
#define BGENDI_IMPL              \
{                  \
  dword_t _res, _src1;              \
  byte_t _src2;              \
  \
  _src1 = GPR_D(URS);              \
  _src2 = UIMMB;              \
  _res = _src1 + ((_src2 >> LOGBITSIZE_W) << LOGSIZE_W);    \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(BGENDI,      0x00,
      "bgend",    "%Dd,%Sd,%Ib",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)

  /* same as above BGEN uops, but treated as as STA w.r.t.
     store queue allocation and exec-port assignment. */

#define STA_BGENW_IMPL   BGENW_IMPL
  DEFUOP(STA_BGENW,      0x00,
      "bgenw",    "%Dw,%Sw,%Tw",
      FU_STA,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_W(URD)/*PRD*/,
      DNA, DNA)
#define STA_BGENWI_IMPL  BGENWI_IMPL
  DEFUOP(STA_BGENWI,      0x00,
      "bgenw",    "%Dw,%Sw,%Ib",
      FU_STA,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)
#define STA_BGEND_IMPL   BGEND_IMPL
  DEFUOP(STA_BGEND,      0x00,
      "bgend",    "%Dd,%Sd,%Td",
      FU_STA,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_D(URT), DNA,
      DNA, DNA)
#define STA_BGENDI_IMPL  BGENDI_IMPL
  DEFUOP(STA_BGENDI,      0x00,
      "bgend",    "%Dd,%Sd,%Ib",
      FU_STA,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)

  /* control instructions */

#define JCCB_IMPL              \
{                  \
  dword_t _aflags;              \
  \
  SET_TPC(CPC + UIMMB + URS);            \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  if (CC_EVAL(UCC, _aflags))            \
  SET_NPC(CPC + UIMMB + URS);          \
}
  DEFUOP(JCCB,      0x00,
      "j%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DNA, DNA, DNA,
      DNA, DAFLAGS(OF|SF|ZF|CF|PF))

#define JCCW_IMPL              \
{                  \
  dword_t _aflags;              \
  \
  SET_TPC(CPC + UIMMW + URS);            \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  if (CC_EVAL(UCC, _aflags))            \
  SET_NPC(CPC + UIMMW + URS);          \
}
  DEFUOP(JCCW,      0x00,
      "j%cc",      "%Jw",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DNA, DNA, DNA,
      DNA, DAFLAGS(OF|SF|ZF|CF|PF))

#define JCCD_IMPL              \
{                  \
  dword_t _aflags;              \
  \
  SET_TPC(CPC + UIMMD + URS);            \
  \
  _aflags = AFLAGS(OF|SF|ZF|CF|PF);          \
  if (CC_EVAL(UCC, _aflags))            \
  SET_NPC(CPC + UIMMD + URS);          \
}
  DEFUOP(JCCD,      0x00,
      "j%cc",      "%Jd",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DNA, DNA, DNA,
      DNA, DAFLAGS(OF|SF|ZF|CF|PF))

#define BRCCB_IMPL              \
{                  \
  byte_t _src1, _src2 = 0;            \
  dword_t _aflags;              \
  \
  SET_TPC(CPC + UIMMB + URT);            \
  \
  _src1 = GPR_B(URS);              \
  _aflags = AFLAGS_SUBB(_src1, _src1, _src2);        \
  if (CC_EVAL(UCC, _aflags))            \
  SET_NPC(CPC + UIMMB + URT);          \
}
  DEFUOP(BRCCB,      0x00,
      "br%cc",    "%Sb,%Kb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR_B(URS), DNA, DNA,
      DNA, DNA)

#define BRCCW_IMPL              \
{                  \
  word_t _src1, _src2 = 0;            \
  dword_t _aflags;              \
  \
  SET_TPC(CPC + UIMMB + URT);            \
  \
  _src1 = GPR_W(URS);              \
  _aflags = AFLAGS_SUBW(_src1, _src1, _src2);        \
  if (CC_EVAL(UCC, _aflags))            \
  SET_NPC(CPC + UIMMB + URT);          \
}
  DEFUOP(BRCCW,      0x00,
      "br%cc",    "%Sw,%Kb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR_W(URS), DNA, DNA,
      DNA, DNA)

#define BRCCD_IMPL              \
{                  \
  dword_t _src1, _src2, _aflags;          \
  \
  SET_TPC(CPC + UIMMB + URT);            \
  \
  _src1 = GPR_D(URS);              \
  _src2 = 0; \
  _aflags = AFLAGS_SUBD(_src1, _src1, _src2);        \
  if (CC_EVAL(UCC, _aflags))            \
  SET_NPC(CPC + UIMMB + URT);          \
}
  DEFUOP(BRCCD,      0x00,
      "br%cc",    "%Sd,%Kb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)

#define JMPB_IMPL              \
{                  \
  SET_TPC(CPC + UIMMB + URS);            \
  SET_NPC(CPC + UIMMB + URS);            \
}
  DEFUOP(JMPB,      0x00,
      "jmp",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define JMPW_IMPL              \
{                  \
  SET_TPC(CPC + UIMMW + URS);            \
  SET_NPC(CPC + UIMMW + URS);            \
}
  DEFUOP(JMPW,      0x00,
      "jmp",      "%Jw",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define JMPD_IMPL              \
{                  \
  SET_TPC(CPC + UIMMD + URS);            \
  SET_NPC(CPC + UIMMD + URS);            \
}
  DEFUOP(JMPD,      0x00,
      "jmp",      "%Jd",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DNA, DNA, DNA,
      DNA, DNA)

#define JMPRW_IMPL              \
{                  \
  md_addr_t _targ;              \
  \
  _targ = (md_addr_t)GPR_W(URD);          \
  SET_TPC(_targ);              \
  SET_NPC(_targ);              \
}
  DEFUOP(JMPRW,      0x00,
      "jmpr",      "%Dw",
      FU_JEU,                 F_CTRL|F_UNCOND|F_INDIRJMP,
      DNA,
      DGPR_W(URD), DNA, DNA,
      DNA, DNA)

#define JMPRD_IMPL              \
{                  \
  md_addr_t _targ;              \
  \
  _targ = GPR_D(URD);              \
  SET_TPC(_targ);              \
  SET_NPC(_targ);              \
}
  DEFUOP(JMPRD,      0x00,
      "jmpr",      "%Dd",
      FU_JEU,                 F_CTRL|F_UNCOND|F_INDIRJMP,
      DNA,
      DGPR_D(URD), DNA, DNA,
      DNA, DNA)


  /* operand conversions */

#define SEXTW_IMPL              \
{                  \
  byte_t _src;              \
  word_t _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_B(URS);              \
  _res = (sword_t)(sbyte_t)_src;          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(SEXTW,      0x00,
      "sextw",    "%Dw,%Sb",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_B(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

#define SEXTD_IMPL              \
{                  \
  word_t _src;              \
  dword_t _res;              \
  \
  _src = GPR_W(URS);              \
  _res = (sdword_t)(sword_t)_src;          \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(SEXTD,      0x00,
      "sextd",    "%Dd,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_W(URS), DNA, DNA,
      DNA, DNA)

#define SIGNW_IMPL              \
{                  \
  word_t _src, _res;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = GPR_W(URS);              \
  _res = (_src & 0x8000) ? 0xffff : 0x0000;        \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _res);            \
}
  DEFUOP(SIGNW,      0x00,
      "signw",    "%Dw,%Sw",
      FU_IEU,      F_ICOMP,
      DGPR_W(URD),
      DGPR_W(URS), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

#define SIGND_IMPL              \
{                  \
  dword_t _src, _res;              \
  \
  _src = GPR_D(URS);              \
  _res = (_src & 0x80000000) ? 0xffffffff : 0x00000000;    \
  SET_GPR_D(URD, _res);            \
}
  DEFUOP(SIGND,      0x00,
      "signd",    "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DNA, DNA,
      DNA, DNA)


  /* flags accessors */

#define MOVFB_IMPL              \
{                  \
  byte_t _src;              \
  \
  _src = GPR_B(URD);              \
  SET_AFLAGS((((dword_t)_src) & UIMMB), UIMMB);      \
}
  DEFUOP(MOVFB,      0x00,
      "movfb",    "%Db,%Ib",
      FU_IEU,      F_TRAP,
      DNA,
      DGPR_B(URD), DNA, DNA,
      DAFLAGS(UIMMB), DNA)

#define MOVBF_IMPL              \
{                  \
  byte_t _src;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src = (byte_t)AFLAGS(UIMMB);          \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _src|2);            \
}
  DEFUOP(MOVBF,      0x00,
      "movbf",    "%Db,%Ib",
      FU_IEU,      F_TRAP,
      DGPR_B(URD),
      DGPR_B(URD)/*PRD*/, DNA, DNA,
      DNA, DAFLAGS(UIMMB))

#define MOVFW_IMPL              \
{                  \
  word_t _src;              \
  \
  _src = GPR_W(URD);              \
  SET_AFLAGS((((dword_t)_src) & UIMMW), UIMMW);      \
}
  DEFUOP(MOVFW,      0x00,
      "movfw",    "%Dw,%Iw",
      FU_IEU,      F_TRAP,
      DNA,
      DGPR_W(URD), DNA, DNA,
      DAFLAGS(UIMMW), DNA)

#define MOVWF_IMPL              \
{                  \
  word_t _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = (word_t)AFLAGS(UIMMW);          \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _src|2);            \
}
  DEFUOP(MOVWF,      0x00,
      "movwf",    "%Dw,%Iw",
      FU_IEU,      F_TRAP,
      DGPR_W(URD),
      DGPR_W(URD)/*PRD*/, DNA, DNA,
      DNA, DAFLAGS(UIMMW))


  /* non-architectural widgets */

#define CMPCCB_IMPL              \
{                  \
  byte_t _src1, _src2, _res, _flag;          \
  dword_t _aflags;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_B(URS);              \
  _src2 = GPR_B(URT);              \
  _res = _src1 - _src2;            \
  _aflags = AFLAGS_SUBB(_res, _src1, _src2);        \
  _flag = !!CC_EVAL(ULIT, _aflags);          \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _flag);            \
}
  DEFUOP(CMPCCB,      0x00,
      "cmp%cc",    "%Db,%Sb,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_B(URS), DGPR_B(URT), DGPR_B(URD)/*PRD*/,
      DNA, DNA)

#define CMPCCW_IMPL              \
{                  \
  word_t _src1, _src2, _res;            \
  dword_t _aflags;              \
  byte_t _flag;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_W(URS);              \
  _src2 = GPR_W(URT);              \
  _res = _src1 - _src2;            \
  _aflags = AFLAGS_SUBW(_res, _src1, _src2);        \
  _flag = !!CC_EVAL(ULIT, _aflags);          \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
}
  DEFUOP(CMPCCW,      0x00,
      "cmp%cc",    "%Db,%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_W(URS), DGPR_W(URT), DGPR_B(URD)/*PRD*/,
      DNA, DNA)

#define CMPCCD_IMPL              \
{                  \
  dword_t _src1, _src2, _res, _aflags;          \
  byte_t _flag;              \
  dword_t _orig = GPR_DB(URD);             \
  \
  _src1 = GPR_D(URS);              \
  _src2 = GPR_D(URT);              \
  _res = _src1 - _src2;            \
  _aflags = AFLAGS_SUBD(_res, _src1, _src2);        \
  _flag = !!CC_EVAL(ULIT, _aflags);          \
  SET_GPR_DB(URD, _orig);            \
  SET_GPR_B(URD, _res);            \
}
  DEFUOP(CMPCCD,      0x00,
      "cmp%cc",    "%Db,%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD),
      DGPR_D(URS), DGPR_D(URT), DGPR_B(URD)/*PRD*/,
      DNA, DNA)


  /* floating point operations */

#define ADDE_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _res = _src1 + _src2;            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(ADDE,      0x00,
      "adde",      "%De,%Se,%Te%st",
      FU_FADD,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define MULE_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _res = _src1 * _src2;            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(MULE,      0x00,
      "mule",      "%De,%Se,%Te%st",
      FU_FMUL,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define COM_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(COM,      0x00,
      "com",      "%Se,%Te%st",
      FU_FADD,    F_FCOMP,
      DCREG(MD_REG_FSW),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define UCOM_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  SET_FSW(FSW_FUCOM(_src1, _src2), C0|C2|C3);        \
  /*FPSTACK_OP(ULIT);*/              \
}

  DEFUOP(UCOM,      0x00,
      "ucom",      "%Se,%Te%st",
      FU_FADD,    F_FCOMP,
      DCREG(MD_REG_FSW),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define COMI_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  SET_AFLAGS(AFLAGS_FCOMI(_src1, _src2), ZF|PF|CF);      \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(COMI,      0x00,
      "comi",      "%Se,%Te%st",
      FU_FADD,    F_FCOMP,
      DNA,
      DFPR(URS), DFPR(URT), DNA,
      DAFLAGS(ZF|PF|CF), DNA)

#define UCOMI_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  SET_AFLAGS(AFLAGS_FUCOMI(_src1, _src2), ZF|PF|CF);      \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(UCOMI,      0x00,
      "ucomi",    "%Se,%Te%st",
      FU_FADD,    F_FCOMP,
      DNA,
      DFPR(URS), DFPR(URT), DNA,
      DAFLAGS(ZF|PF|CF), DNA)

#define SUBE_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _res = _src1 - _src2;            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(SUBE,      0x00,
      "sube",      "%De,%Se,%Te%st",
      FU_FADD,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define DIVE_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = _src1 / _src2;            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(DIVE,      0x00,
      "dive",      "%De,%Se,%Te%st",
      FU_FDIV,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define MOVE_IMPL              \
{                  \
  efloat_t _src;              \
  \
  _src = FPR(URS);              \
  SET_FPR(URD, _src);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(MOVE,      0x00,
      "move",      "%De,%Se%st",
      FU_FADD,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define CHS_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = -_src;              \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(CHS,      0x00,
      "chs",      "%De,%Se%st",
      FU_FADD,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define ABS_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = fabs(_src);              \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(ABS,      0x00,
      "abs",      "%De,%Se%st",
      FU_FADD,    F_FCOMP,
      DFPR(URD), 
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define TST_IMPL              \
{                  \
  efloat_t _src1, _src2;            \
  \
  _src1 = FPR(URD);              \
  _src2 = (efloat_t)0.0;            \
  SET_FSW(FSW_FCOM(_src1, _src2), C0|C2|C3);        \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(TST,      0x00,
      "tst",      "%Se%st",
      FU_FADD,    F_FCOMP,
      DCREG(MD_REG_FSW),
      DFPR(URD), DNA, DNA,
      DNA, DNA)

#define XAM_IMPL              \
{                  \
  efloat_t _src;              \
  word_t _fsw = 0;              \
  \
  _src = FPR(URD);              \
  if (_src < 0.0)              \
  _fsw |= C1;              \
  if (isnan(_src))              \
  _fsw |= C0;              \
  else if (isinf(_src))            \
  _fsw |= (C2|C0);              \
  else if (_src == 0.0)            \
  _fsw |= C3;              \
  else                \
  _fsw |= C2;              \
  SET_FSW(_fsw, C0|C1|C2|C3);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(XAM,      0x00,
      "xam",      "%Se%st",
      FU_FADD,    F_FCOMP,
      DCREG(MD_REG_FSW),
      DFPR(URD), DNA, DNA,
      DNA, DNA)

#define TWOXM1_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = pow(2.0, _src) - 1.0;          \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(TWOXM1,      0x00,
      "twoxm1",    "%De,%Se%st",
      FU_FMUL,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define YL2X_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _res = _src2 * (log(_src1)/log(2.0));        \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(YL2X,      0x00,
      "yl2x",      "%De,%Se,%Te%st",
      FU_FMUL,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define TAN_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = tan(_src);              \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(TAN,      0x00,
      "tan",      "%De,%Se%st",
      FU_FCPLX,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define ATAN_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _res = atan(_src2/_src1);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(ATAN,      0x00,
      "atan",      "%De,%Se,%Te%st",
      FU_FCPLX,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define REM1_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = drem(_src1, _src2);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(REM1,      0x00,
      "rem1",      "%De,%Se,%Te%st",
      FU_FDIV,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define REM_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  \
  if (_src2 == 0)              \
    SET_FSW(FSW(ZE), FSW(ZE) | (ZE & !CWD(ZM)));            \
  \
  _res = fmod(_src1, _src2);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(REM,      0x00,
      "rem",      "%De,%Se,%Te%st",
      FU_FDIV,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define YL2XP1_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _res = _src2 * (log(_src1 + 1.0)/log(2.0));        \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(YL2XP1,      0x00,
      "yl2xp1",    "%De,%Se,%Te%st",
      FU_FMUL,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

#define SQRT_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = sqrt(_src);              \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(SQRT,      0x00,
      "sqrt",      "%De,%Se%st",
      FU_FCPLX,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define SIN_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = sin(_src);              \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(SIN,      0x00,
      "sin",      "%De,%Se%st",
      FU_FCPLX,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define COS_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = cos(_src);              \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(COS,      0x00,
      "cos",      "%De,%Se%st",
      FU_FCPLX,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define RNDINT_IMPL              \
{                  \
  efloat_t _res, _src;            \
  \
  _src = FPR(URS);              \
  _res = rint(_src);              \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(RNDINT,      0x00,
      "rndint",    "%De,%Se%st",
      FU_FADD,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DNA, DNA,
      DNA, DNA)

#define SCL_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _res = _src1 * pow(2.0, _src2);          \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(SCL,      0x00,
      "scl",      "%De,%Se,%Te%st",
      FU_FMUL,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DNA)

  /* NOTE: CMOVE cannot update the FP stack (ULIT is in use) */
#define CMOVE_IMPL              \
{                  \
  efloat_t _res, _src1, _src2;          \
  dword_t _aflags;              \
  \
  _src1 = FPR(URS);              \
  _src2 = FPR(URT);              \
  _aflags = AFLAGS(ZF|CF|PF);            \
  _res = FCC_EVAL(ULIT, _aflags) ? _src2 : _src1;      \
  SET_FPR(URD, _res);              \
}
  DEFUOP(CMOVE,      0x00,
      "cmove",    "%De,%Se,%Te",
      FU_FADD,    F_FCOMP,
      DFPR(URD),
      DFPR(URS), DFPR(URT), DNA,
      DNA, DAFLAGS(ZF|CF|PF))

#define FCLEX_UOP_IMPL              \
{  \
  SET_FSW(0, IE|DE|ZE|OE|UE|PE|FSF|ES);        \
}
  DEFUOP(FCLEX_UOP,      0x00,
      "fclex",    "",
      FU_FADD,    F_FCOMP,
      DCREG(MD_REG_FSW),
      DCREG(MD_REG_FSW), DNA, DNA,
      DAFLAGS(IE|DE|ZE|OE|UE|PE|FSF|ES), DNA)

  /* floating point memory operations */

#define FLDWS_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDWS,      0x00,
      "flds",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FLDDS_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_S2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDDS,      0x00,
      "flds",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FSTS_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_E2S(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FSTS,      0x00,
      "fsts",      "%De,(%Sd)%st",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DFPR(URD), DNA,
      DNA, DNA)

#define FLDWT_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDWT,      0x00,
      "fldt",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FLDDT_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_T2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDDT,      0x00,
      "fldt",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FSTT_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_E2T(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FSTT,      0x00,
      "fstt",      "%De,(%Sd)%st",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DFPR(URD), DNA,
      DNA, DNA)

#define FLDWW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDWW,      0x00,
      "fldw",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FLDDW_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_W2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDDW,      0x00,
      "fldw",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FSTW_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_E2W(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FSTW,      0x00,
      "fstw",      "%De,(%Sd)%st",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DFPR(URD), DNA,
      DNA, DNA)

#define FLDWD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDWD,      0x00,
      "fldd",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FLDDD_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_D2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDDD,      0x00,
      "fldd",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FSTD_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_E2D(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FSTD,      0x00,
      "fstd",      "%De,(%Sd)%st",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DFPR(URD), DNA,
      DNA, DNA)

#define FLDWQ_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_Q2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDWQ,      0x00,
      "fldq",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FLDDQ_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  efloat_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_Q2E(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDDQ,      0x00,
      "fldq",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FSTQ_IMPL              \
{                  \
  efloat_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(URD);              \
  _addr = GPR_D(URS);              \
  WRITE_E2Q(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FSTQ,      0x00,
      "fstq",      "%De,(%Sd)%st",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DFPR(URD), DNA,
      DNA, DNA)

#define FLDWE_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  qword_t _src1;              \
  dword_t _src2;              \
  efloat_t _res;              \
  word_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_W(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _src1 = READ_QWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = READ_DWORD(_addr+8, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _res = QW2E(_src1, _src2);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDWE,      0x00,
      "flde",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FLDDE_IMPL              \
{                  \
  enum md_fault_type _fault;            \
  qword_t _src1;              \
  dword_t _src2;              \
  efloat_t _res;              \
  dword_t _base, _index, _seg;            \
  md_addr_t _addr;              \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _src1 = READ_QWORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _src2 = READ_DWORD(_addr+8, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  _res = QW2E(_src1, _src2);            \
  SET_FPR(URD, _res);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FLDDE,      0x00,
      "flde",      "%De,(%Sd)%st",
      FU_LD,      F_MEM|F_LOAD,
      DFPR(URD),
      DGPR_D(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FSTE_IMPL              \
{                  \
  efloat_t _src;              \
  qword_t _src1;              \
  dword_t _src2;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = FPR(URD);              \
  _src1 = E2Qw(_src);              \
  _src2 = E2qW(_src);              \
  _addr = GPR_D(URS);              \
  WRITE_QWORD(_src1, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  WRITE_DWORD2(_src2, _addr+8, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FSTE,      0x00,
      "fste",      "%De,(%Sd)%st",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URS), DFPR(URD), DNA,
      DNA, DNA)

#define LDC_IMPL              \
{                  \
  efloat_t _src;              \
  \
  _src = FPCONST(URS);            \
  SET_FPR(URD, _src);              \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(LDC,      0x00,
      "ld%lc",    "%De%st",
      FU_FADD,    F_FCOMP,
      DFPR(URD),
      DNA, DNA, DNA,
      DNA, DNA)

#define FLDCWW_IMPL              \
{                  \
  word_t _base, _index, _seg, _res;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _base = GPR_W(URS);              \
  _index = GPR_W(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_A(_seg, _base, _index, ULIT, UIMMW);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);            \
  SET_CWD(_res,0xffff);            \
}
  DEFUOP(FLDCWW,      0x00,
      "fldcw",    "",
      FU_LD,      F_MEM|F_LOAD,
      DCREG(MD_REG_CWD),
      DGPR(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)

#define FLDCDW_IMPL              \
{                  \
  dword_t _base, _index, _seg, _res;            \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _base = GPR_D(URS);              \
  _index = GPR_D(URT);            \
  _seg = (USG != SEG_DEF) ? SEG_W(USG) : 0;                    \
  _addr = AGEN_D(_seg, _base, _index, ULIT, UIMMD);      \
  \
  _res = READ_WORD(_addr, _fault);          \
  if (_fault != md_fault_none)          \
    DECLARE_FAULT(_fault);            \
  SET_CWD(_res,0xffff);            \
}
  DEFUOP(FLDCDW,      0x00,
      "fldcw",    "",
      FU_LD,      F_MEM|F_LOAD,
      DCREG(MD_REG_CWD),
      DGPR(URS), DGPR(URT), DSEG(USG),
      DNA, DNA)


#define FSTCWW_IMPL              \
{                  \
  word_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = CWD(0xffff);              \
  _addr = GPR_W(URD);              \
  WRITE_WORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(FSTCWW,      0x00,
      "fstcw",    "",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_W(URD), DCREG(MD_REG_CWD), DNA,
      DNA, DNA)

#define FSTCDW_IMPL              \
{                  \
  word_t _src;              \
  md_addr_t _addr;              \
  enum md_fault_type _fault;            \
  \
  _src = CWD(0xffff);              \
  _addr = GPR_D(URD);              \
  WRITE_WORD(_src, _addr, _fault);          \
  if (_fault != md_fault_none)          \
  DECLARE_FAULT(_fault);            \
}
  DEFUOP(FSTCDW,      0x00,
      "fstcw",    "",
      FU_STD,      F_MEM|F_STORE,
      DNA,
      DGPR_D(URD), DCREG(MD_REG_CWD), DNA,
      DNA, DNA)

#define FSTSW_IMPL              \
{                  \
  word_t _src;              \
  dword_t _orig = GPR_D(URD);             \
  \
  _src = FSW(C0|C1|C2|C3);            \
  SET_GPR_D(URD, _orig);            \
  SET_GPR_W(URD, _src);            \
  /*FPSTACK_OP(ULIT);*/              \
}
  DEFUOP(FSTSW,      0x00,
      "fstsw",    "%Dw%st",
      FU_IEU,           F_FCOMP,
      DGPR_W(URD),
      DCREG(MD_REG_FSW), DGPR_W(URD)/*PRD*/, DNA,
      DNA, DNA)

  /*================================================================*/
  /* The remaining uops are for supporting core-level issues:
     handling of REPs, merging partial-register writes, BOUND inst  */
  /*================================================================*/

  /* The REP[NZ|Z|.]_MICROBR uops are used to implement the
     micro-control flow for REP instructions.  There are
     _D and _W versions depending on inst.mode & MODE_ADDR32. */
#define REPNZ_MICROBR_D_IMPL      \
{                           \
  if(GPR_D(MD_REG_eCX) && !AFLAGS(ZF)) \
  SET_NPC(CPC);                    \
}
  DEFUOP(REPNZ_MICROBR_D,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_eCX), DNA, DNA,
      DNA, DAFLAGS(ZF))

#define REPZ_MICROBR_D_IMPL      \
{                           \
  if(GPR_D(MD_REG_eCX) && AFLAGS(ZF)) \
  SET_NPC(CPC);                    \
}
  DEFUOP(REPZ_MICROBR_D,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_eCX), DNA, DNA,
      DNA, DAFLAGS(ZF))

#define REP_MICROBR_D_IMPL      \
{                           \
  if(GPR_D(MD_REG_eCX)) \
  SET_NPC(CPC);                    \
}
  DEFUOP(REP_MICROBR_D,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_eCX), DNA, DNA,
      DNA, DNA)

#define REPNZ_MICROBR_W_IMPL      \
{                           \
  if(GPR_W(MD_REG_CX) && !AFLAGS(ZF)) \
  SET_NPC(CPC);                    \
}
  DEFUOP(REPNZ_MICROBR_W,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_CX), DNA, DNA,
      DNA, DAFLAGS(ZF))

#define REPZ_MICROBR_W_IMPL      \
{                           \
  if(GPR_W(MD_REG_CX) && AFLAGS(ZF)) \
  SET_NPC(CPC);                    \
}
  DEFUOP(REPZ_MICROBR_W,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_CX), DNA, DNA,
      DNA, DAFLAGS(ZF))

#define REP_MICROBR_W_IMPL      \
{                           \
  if(GPR_W(MD_REG_CX)) \
  SET_NPC(CPC);                    \
}
  DEFUOP(REP_MICROBR_W,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_CX), DNA, DNA,
      DNA, DNA)

  /* This REPFIRST is just a place-holder uop.  Before the
     main REP sequence, we need a branch to check if there
     are *any* REP's at all (i.e. REP with zero count).
     This uop does not actually modify any state (i.e. the PC)
     because modifying the NPC before the actual instruction
     seems to break some things (REP'd branch?).  */
#define REPFIRST_MICROBR_D_IMPL      \
{                           \
  /* just a place-holder uop */ \
}
  DEFUOP(REPFIRST_MICROBR_D,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_eCX), DNA, DNA,
      DNA, DNA)

#define REPFIRST_MICROBR_W_IMPL      \
{                           \
  /* just a place-holder uop */ \
}
  DEFUOP(REPFIRST_MICROBR_W,      0x00,
      "uj%cc",      "%Jb",
      FU_JEU,                 F_CTRL|F_COND|F_DIRJMP,
      DNA,
      DGPR(MD_REG_CX), DNA, DNA,
      DNA, DNA)

  /* This uop is simply used to assist in the enforcement of
     partial register write dependencies.  Most W and B insts
     just use an extra input dependency (those labeled PRD),
     but for uops that already have three input deps (such
     as ADC/SBB or the rotates with carry), we need to enforce
     the dependency with extra uops.  For an inst that (partial)
     writes to register R, you would do:
       mov tmp0 <-- R
       op tmp <-- src1, src2
       partial_merge R <-- tmp0, tmp1

     partial merge copies the full 32-bit original value, and
     then splices in the updated 8- or 16-bit portion.
   */
#define PARTIAL_MERGEW_IMPL              \
{                  \
  dword_t _src_whole;  \
  word_t _src_partial;            \
  \
  _src_whole = GPR_D(URS);              \
  _src_partial = GPR_W(URT);              \
  SET_GPR_D(URD, _src_whole);            \
  SET_GPR_W(URD, _src_partial);            \
}
  DEFUOP(PARTIAL_MERGEW,      0x00,
      "partial_merge",      "%Dd,%Sd,%Tw",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_D(URS), DGPR_W(URT), DNA,
      DNA, DNA)

#define PARTIAL_MERGEB_IMPL              \
{                  \
  dword_t _src_whole;  \
  byte_t _src_partial;  \
  \
  _src_whole = GPR_DB(URS);              \
  _src_partial = GPR_B(URT);              \
  SET_GPR_DB(URD, _src_whole);            \
  SET_GPR_B(URD, _src_partial);            \
}
  DEFUOP(PARTIAL_MERGEB,      0x00,
      "partial_merge",      "%Dd,%Sd,%Tb",
      FU_IEU,      F_ICOMP,
      DGPR_B(URD) /* need to do _B here to remap reg name */,
      DGPR_D(URS), DGPR_B(URT), DNA,
      DNA, DNA)

/* 32-bit mov, but interpret's the register name as 8-bit operand AH/AL/BH/... */
#define MOV_DB_IMPL              \
{                  \
  dword_t _src = GPR_DB(URS);              \
  SET_GPR_DB(URD, _src);            \
}
  DEFUOP(MOV_DB,      0x00,
      "mov_db",      "%Dd,%Sd",
      FU_IEU,      F_ICOMP,
      DGPR_D(URD),
      DGPR_B(URS), DNA, DNA,
      DNA, DNA)


  /* used for implementing the BOUND instruction */
#define BOUND_LOWERW_IMPL              \
{                  \
  word_t _index = GPR_W(URS);             \
  word_t _bound = GPR_W(URT);             \
  if (_index < _bound)              \
    DECLARE_FAULT(md_fault_break);            \
}
  DEFUOP(BOUND_LOWERW,      0x00,
      "bound_lower",    "%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DNA, 
      DGPR_W(URS), DGPR_W(URT), DNA,
      DNA, DNA)

#define BOUND_LOWERD_IMPL              \
{                  \
  dword_t _index = GPR_D(URS);             \
  dword_t _bound = GPR_D(URT);             \
  if (_index < _bound)              \
    DECLARE_FAULT(md_fault_break);            \
}
  DEFUOP(BOUND_LOWERD,      0x00,
      "bound_lower",    "%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DNA, 
      DGPR_D(URS), DGPR_D(URT), DNA,
      DNA, DNA)

#define BOUND_UPPERW_IMPL              \
{                  \
  word_t _index = GPR_W(URS);             \
  word_t _bound = GPR_W(URT);             \
  if (_index >= _bound)              \
    DECLARE_FAULT(md_fault_break);            \
}
  DEFUOP(BOUND_UPPERW,      0x00,
      "bound_upper",    "%Sw,%Tw",
      FU_IEU,      F_ICOMP,
      DNA, 
      DGPR_W(URS), DGPR_W(URT), DNA,
      DNA, DNA)

#define BOUND_UPPERD_IMPL              \
{                  \
  dword_t _index = GPR_D(URS);             \
  dword_t _bound = GPR_D(URT);             \
  if (_index >= _bound)              \
    DECLARE_FAULT(md_fault_break);            \
}
  DEFUOP(BOUND_UPPERD,      0x00,
      "bound_upper",    "%Sd,%Td",
      FU_IEU,      F_ICOMP,
      DNA, 
      DGPR_D(URS), DGPR_D(URT), DNA,
      DNA, DNA)


  /* clean up all definitions... */
#undef UPDATE_CALLGRAPH_CALL
#undef UPDATE_CALLGRAPH_RETURN
#undef DEFUOP
#undef DEFINST
#undef DEFLINK
#undef CONNECT
#undef ADD_ALIb_IMPL
#undef ADD_eAXIv_IMPL
#undef PUSH_NONSENSE_IMPL
#undef PUSHES_IMPL
#undef POP_NONSENSE_IMPL
#undef POPES_IMPL
#undef OR_ALIb_IMPL
#undef OR_eAXIv_IMPL
#undef PUSHCS_IMPL
#undef ADC_ALIb_IMPL
#undef ADC_eAXIv_IMPL
#undef PUSHSS_IMPL
#undef POPSS_IMPL
#undef SBB_ALIb_IMPL
#undef SBB_eAXIv_IMPL
#undef PUSHDS_IMPL
#undef POPDS_IMPL
#undef AND_ALIb_IMPL
#undef AND_eAXIv_IMPL
#undef SUB_ALIb_IMPL
#undef SUB_eAXIv_IMPL
#undef XOR_ALIb_IMPL
#undef XOR_eAXIv_IMPL
#undef CMP_ALIb_IMPL
#undef CMP_eAXIv_IMPL
#undef INC_ROv_IMPL
#undef DEC_ROv_IMPL
#undef PUSH_ROv_IMPL
#undef POP_ROv_IMPL
#undef DO_ONE_PUSHA
#undef PUSHA_IMPL
#undef DO_ONE_POPA
#undef POPA_IMPL
#undef PUSH_Iv_IMPL
#undef PUSH_Ib_IMPL
#undef JCC_Jb_IMPL
#undef NOP_IMPL
#undef XCHG_eAXRv_IMPL
#undef XCHG_eAXeCX_IMPL
#undef XCHG_eAXeDX_IMPL
#undef XCHG_eAXeBX_IMPL
#undef XCHG_eAXeSP_IMPL
#undef XCHG_eAXeBP_IMPL
#undef XCHG_eAXeSI_IMPL
#undef XCHG_eAXeDI_IMPL
#undef CBW_CWDE_IMPL
#undef CWD_CDQ_IMPL
#undef PUSHF_IMPL
#undef POPF_IMPL
#undef SAHF_IMPL
#undef LAHF_IMPL
#undef MOV_ALOb_IMPL
#undef MOV_eAXOv_IMPL
#undef MOV_ObAL_IMPL
#undef MOV_OveAX_IMPL
#undef MOVSB_XbYb_IMPL
#undef MOVSB_XvYv_IMPL
#undef CMPSB_XbYb_IMPL
#undef CMPSB_XvYv_IMPL
#undef TEST_ALIb_IMPL
#undef TEST_eAXIv_IMPL
#undef STOSB_ALYb_IMPL
#undef STOSV_eAXYv_IMPL
#undef LODSB_ALXb_IMPL
#undef LODSV_eAXXv_IMPL
#undef SCASB_Yb_IMPL
#undef SCASV_Yv_IMPL
#undef MOV_RObIb_IMPL
#undef MOV_ROvIv_IMPL
#undef RETN_Iw_IMPL
#undef RETN_IMPL
#undef LEAVE_IMPL
#undef INT_Ib_IMPL
#undef LOOPNZ_Jb_IMPL
#undef LOOPZ_Jb_IMPL
#undef LOOP_Jb_IMPL
#undef JCXZ_Jb_IMPL
#undef CALLN_Jv_IMPL
#undef JMPN_Jv_IMPL
#undef JMPN_Jb_IMPL
#undef HLT_IMPL
#undef HLT_IMPL
#undef CMC_IMPL
#undef CLC_IMPL
#undef STC_IMPL
#undef CLD_IMPL
#undef STDF_IMPL
#undef LEA_RvMx_IMPL
#undef ADD_MbRb_IMPL
#undef ADD_RMbRb_IMPL
#undef XCHG_MvRv_IMPL
#undef XCHG_RMvRv_IMPL
#undef CMPXCHG_MvRv_IMPL
#undef CMPXCHG_RMvRv_IMPL
#undef XADD_MvRv_IMPL
#undef XADD_RMvRv_IMPL
#undef ADD_MvRv_IMPL
#undef ADD_RMvRv_IMPL
#undef ADD_RbMb_IMPL
#undef ADD_RbRMb_IMPL
#undef ADD_RvMv_IMPL
#undef ADD_RvRMv_IMPL
#undef OR_MbRb_IMPL
#undef OR_RMbRb_IMPL
#undef OR_MvRv_IMPL
#undef OR_RMvRv_IMPL
#undef OR_RbMb_IMPL
#undef OR_RbRMb_IMPL
#undef OR_RvMv_IMPL
#undef OR_RvRMv_IMPL
#undef ADC_MbRb_IMPL
#undef ADC_RMbRb_IMPL
#undef ADC_MvRv_IMPL
#undef ADC_RMvRv_IMPL
#undef ADC_RbMb_IMPL
#undef ADC_RbRMb_IMPL
#undef ADC_RvMv_IMPL
#undef ADC_RvRMv_IMPL
#undef SBB_MbRb_IMPL
#undef SBB_RMbRb_IMPL
#undef SBB_MvRv_IMPL
#undef SBB_RMvRv_IMPL
#undef SBB_RbMb_IMPL
#undef SBB_RbRMb_IMPL
#undef SBB_RvMv_IMPL
#undef SBB_RvRMv_IMPL
#undef AND_MbRb_IMPL
#undef AND_RMbRb_IMPL
#undef AND_MvRv_IMPL
#undef AND_RMvRv_IMPL
#undef AND_RbMb_IMPL
#undef AND_RbRMb_IMPL
#undef AND_RvMv_IMPL
#undef AND_RvRMv_IMPL
#undef SUB_MbRb_IMPL
#undef SUB_RMbRb_IMPL
#undef SUB_MvRv_IMPL
#undef SUB_RMvRv_IMPL
#undef SUB_RbMb_IMPL
#undef SUB_RbRMb_IMPL
#undef SUB_RvMv_IMPL
#undef SUB_RvRMv_IMPL
#undef XOR_MbRb_IMPL
#undef XOR_RMbRb_IMPL
#undef XOR_MvRv_IMPL
#undef XOR_RMvRv_IMPL
#undef XOR_RbMb_IMPL
#undef XOR_RbRMb_IMPL
#undef XOR_RvMv_IMPL
#undef XOR_RvRMv_IMPL
#undef CMP_MbRb_IMPL
#undef CMP_RMbRb_IMPL
#undef CMP_MvRv_IMPL
#undef CMP_RMvRv_IMPL
#undef CMP_RbMb_IMPL
#undef CMP_RbRMb_IMPL
#undef CMP_RvMv_IMPL
#undef CMP_RvRMv_IMPL
#undef BOUND_RvMv_IMPL
#undef IMUL_RvMvIv_IMPL
#undef IMUL_RvRMvIv_IMPL
#undef IMUL_RvMvIb_IMPL
#undef IMUL_RvRMvIb_IMPL
#undef ADD_MbIb_IMPL
#undef ADD_RMbIb_IMPL
#undef OR_MbIb_IMPL
#undef OR_RMbIb_IMPL
#undef ADC_MbIb_IMPL
#undef ADC_RMbIb_IMPL
#undef SBB_MbIb_IMPL
#undef SBB_RMbIb_IMPL
#undef AND_MbIb_IMPL
#undef AND_RMbIb_IMPL
#undef SUB_MbIb_IMPL
#undef SUB_RMbIb_IMPL
#undef XOR_MbIb_IMPL
#undef XOR_RMbIb_IMPL
#undef CMP_MbIb_IMPL
#undef CMP_RMbIb_IMPL
#undef ADD_MvIv_IMPL
#undef ADD_RMvIv_IMPL
#undef OR_MvIv_IMPL
#undef OR_RMvIv_IMPL
#undef ADC_MvIv_IMPL
#undef ADC_RMvIv_IMPL
#undef SBB_MvIv_IMPL
#undef SBB_RMvIv_IMPL
#undef AND_MvIv_IMPL
#undef AND_RMvIv_IMPL
#undef SUB_MvIv_IMPL
#undef SUB_RMvIv_IMPL
#undef XOR_MvIv_IMPL
#undef XOR_RMvIv_IMPL
#undef CMP_MvIv_IMPL
#undef CMP_RMvIv_IMPL
#undef ADD_MvIb_IMPL
#undef ADD_RMvIb_IMPL
#undef OR_MvIb_IMPL
#undef OR_RMvIb_IMPL
#undef ADC_MvIb_IMPL
#undef ADC_RMvIb_IMPL
#undef SBB_MvIb_IMPL
#undef SBB_RMvIb_IMPL
#undef AND_MvIb_IMPL
#undef AND_RMvIb_IMPL
#undef SUB_MvIb_IMPL
#undef SUB_RMvIb_IMPL
#undef XOR_MvIb_IMPL
#undef XOR_RMvIb_IMPL
#undef CMP_MvIb_IMPL
#undef CMP_RMvIb_IMPL
#undef TEST_MbRb_IMPL
#undef TEST_RMbRb_IMPL
#undef TEST_MvRv_IMPL
#undef TEST_RMvRv_IMPL
#undef XCHG_MbRb_IMPL
#undef XCHG_RMbRb_IMPL
#undef XCHG_MvRv_IMPL
#undef XCHG_RMvRv_IMPL
#undef MOV_MbRb_IMPL
#undef MOV_RMbRb_IMPL
#undef MOV_MvRv_IMPL
#undef MOV_RMvRv_IMPL
#undef MOV_RbMb_IMPL
#undef MOV_RbRMb_IMPL
#undef MOV_RvMv_IMPL
#undef MOV_RvRMv_IMPL
#undef MOV_SwMw_IMPL
#undef MOV_SwRMw_IMPL
#undef MOV_MwSw_IMPL
#undef MOV_RMwSw_IMPL
#undef POP_Mv_IMPL
#undef POP_RMv_IMPL
#undef ROL_MbIb_IMPL
#undef ROL_RMbIb_IMPL
#undef ROR_MbIb_IMPL
#undef ROR_RMbIb_IMPL
#undef RCL_MbIb_IMPL
#undef RCL_RMbIb_IMPL
#undef RCR_MbIb_IMPL
#undef RCR_RMbIb_IMPL
#undef SHL_MbIb_IMPL
#undef SHL_RMbIb_IMPL
#undef SHR_MbIb_IMPL
#undef SHR_RMbIb_IMPL
#undef SAR_MbIb_IMPL
#undef SAR_RMbIb_IMPL
#undef ROL_MvIb_IMPL
#undef ROL_RMvIb_IMPL
#undef ROR_MvIb_IMPL
#undef ROR_RMvIb_IMPL
#undef RCL_MvIb_IMPL
#undef RCL_RMvIb_IMPL
#undef RCR_MvIb_IMPL
#undef RCR_RMvIb_IMPL
#undef SHL_MvIb_IMPL
#undef SHL_RMvIb_IMPL
#undef SHR_MvIb_IMPL
#undef SHR_RMvIb_IMPL
#undef SAR_MvIb_IMPL
#undef SAR_RMvIb_IMPL
#undef MOV_MbIb_IMPL
#undef MOV_RMbIb_IMPL
#undef MOV_MvIv_IMPL
#undef MOV_RMvIv_IMPL
#undef ROL_Mb1_IMPL
#undef ROL_RMb1_IMPL
#undef ROR_Mb1_IMPL
#undef ROR_RMb1_IMPL
#undef RCL_Mb1_IMPL
#undef RCL_RMb1_IMPL
#undef RCR_Mb1_IMPL
#undef RCR_RMb1_IMPL
#undef SHL_Mb1_IMPL
#undef SHL_RMb1_IMPL
#undef SHR_Mb1_IMPL
#undef SHR_RMb1_IMPL
#undef SAR_Mb1_IMPL
#undef SAR_RMb1_IMPL
#undef ROL_Mv1_IMPL
#undef ROL_RMv1_IMPL
#undef ROR_Mv1_IMPL
#undef ROR_RMv1_IMPL
#undef RCL_Mv1_IMPL
#undef RCL_RMv1_IMPL
#undef RCR_Mv1_IMPL
#undef RCR_RMv1_IMPL
#undef SHL_Mv1_IMPL
#undef SHL_RMv1_IMPL
#undef SHR_Mv1_IMPL
#undef SHR_RMv1_IMPL
#undef SAR_Mv1_IMPL
#undef SAR_RMv1_IMPL
#undef ROL_MbCL_IMPL
#undef ROL_RMbCL_IMPL
#undef ROR_MbCL_IMPL
#undef ROR_RMbCL_IMPL
#undef RCL_MbCL_IMPL
#undef RCL_RMbCL_IMPL
#undef RCR_MbCL_IMPL
#undef RCR_RMbCL_IMPL
#undef SHL_MbCL_IMPL
#undef SHL_RMbCL_IMPL
#undef SHR_MbCL_IMPL
#undef SHR_RMbCL_IMPL
#undef SAR_MbCL_IMPL
#undef SAR_RMbCL_IMPL
#undef ROL_MvCL_IMPL
#undef ROL_RMvCL_IMPL
#undef ROR_MvCL_IMPL
#undef ROR_RMvCL_IMPL
#undef RCL_MvCL_IMPL
#undef RCL_RMvCL_IMPL
#undef RCR_MvCL_IMPL
#undef RCR_RMvCL_IMPL
#undef SHL_MvCL_IMPL
#undef SHL_RMvCL_IMPL
#undef SHR_MvCL_IMPL
#undef SHR_RMvCL_IMPL
#undef SAR_MvCL_IMPL
#undef SAR_RMvCL_IMPL
#undef TEST_MbIb_IMPL
#undef TEST_RMbIb_IMPL
#undef NOT_Mb_IMPL
#undef NOT_RMb_IMPL
#undef NEG_Mb_IMPL
#undef NEG_RMb_IMPL
#undef MUL_Mb_IMPL
#undef MUL_RMb_IMPL
#undef IMUL_Mb_IMPL
#undef IMUL_RMb_IMPL
#undef DIV_Mb_IMPL
#undef DIV_RMb_IMPL
#undef IDIV_Mb_IMPL
#undef IDIV_RMb_IMPL
#undef TEST_MvIv_IMPL
#undef TEST_RMvIv_IMPL
#undef NOT_Mv_IMPL
#undef NOT_RMv_IMPL
#undef NEG_Mv_IMPL
#undef NEG_RMv_IMPL
#undef MUL_Mv_IMPL
#undef MUL_RMv_IMPL
#undef IMUL_Mv_IMPL
#undef IMUL_RMv_IMPL
#undef DIV_Mv_IMPL
#undef DIV_RMv_IMPL
#undef IDIV_Mv_IMPL
#undef IDIV_RMv_IMPL
#undef INC_Mb_IMPL
#undef INC_RMb_IMPL
#undef DEC_Mb_IMPL
#undef DEC_RMb_IMPL
#undef CALLN_Mv_IMPL
#undef CALLN_RMv_IMPL
#undef JMPN_Mv_IMPL
#undef JMPN_RMv_IMPL
#undef INC_Mv_IMPL
#undef INC_RMv_IMPL
#undef DEC_Mv_IMPL
#undef DEC_RMv_IMPL
#undef PUSH_Mv_IMPL
#undef PUSH_RMv_IMPL
#undef STMXCSR_Mw_IMPL
#undef RDTSC_IMPL
#undef SYSENTER_IMPL
#undef JCC_Jv_IMPL
#undef PUSHFS_IMPL
#undef POPFS_IMPL
#undef CPUID_IMPL
#undef PUSHGS_IMPL
#undef POPGS_IMPL
#undef BSWAP_ROd_IMPL
#undef CMOV_RvMv_IMPL
#undef CMOV_RvRMv_IMPL
#undef SETCC_Mb_IMPL
#undef SETCC_RMb_IMPL
#undef BT_MvRv_IMPL
#undef BT_RMvRv_IMPL
#undef SHLD_MvRvIb_IMPL
#undef SHLD_RMvRvIb_IMPL
#undef SHLD_MvRvCL_IMPL
#undef SHLD_RMvRvCL_IMPL
#undef SHRD_MvRvIb_IMPL
#undef SHRD_RMvRvIb_IMPL
#undef SHRD_MvRvCL_IMPL
#undef SHRD_RMvRvCL_IMPL
#undef BTS_MvRv_IMPL
#undef BTS_RMvRv_IMPL
#undef IMUL_RvMv_IMPL
#undef IMUL_RvRMv_IMPL
#undef BTR_MvRv_IMPL
#undef BTR_RMvRv_IMPL
#undef BTC_MvRv_IMPL
#undef BTC_RMvRv_IMPL
#undef MOVZX_RvMb_IMPL
#undef MOVZX_RvRMb_IMPL
#undef MOVZX_RvMw_IMPL
#undef MOVZX_RvRMw_IMPL
#undef BT_MvIb_IMPL
#undef BT_RMvIb_IMPL
#undef BTS_MvIb_IMPL
#undef BTS_RMvIb_IMPL
#undef BTR_MvIb_IMPL
#undef BTR_RMvIb_IMPL
#undef BTC_MvIb_IMPL
#undef BTC_RMvIb_IMPL
#undef BSF_RvMv_IMPL
#undef BSF_RvRMv_IMPL
#undef BSR_RvMv_IMPL
#undef BSR_RvRMv_IMPL
#undef MOVSX_RvMb_IMPL
#undef MOVSX_RvRMb_IMPL
#undef MOVSX_RvMw_IMPL
#undef MOVSX_RvRMw_IMPL
#undef FADD_Ms_IMPL
#undef FADD_ST0STi_IMPL
#undef FMUL_Ms_IMPL
#undef FMUL_ST0STi_IMPL
#undef FCOM_Ms_IMPL
#undef FCOM_ST0STi_IMPL
#undef FCOMP_Ms_IMPL
#undef FCOMP_ST0STi_IMPL
#undef FSUB_Ms_IMPL
#undef FSUB_ST0STi_IMPL
#undef FSUBR_Ms_IMPL
#undef FSUBR_ST0STi_IMPL
#undef FDIV_Ms_IMPL
#undef FDIV_ST0STi_IMPL
#undef FDIVR_Ms_IMPL
#undef FDIVR_ST0STi_IMPL
#undef FLD_Ms_IMPL
#undef FLD_ST0STi_IMPL
#undef FXCH_ST0STi_IMPL
#undef FST_Ms_IMPL
#undef FNOP_IMPL
#undef FSTP_Ms_IMPL
#undef FCHS_IMPL
#undef FABS_IMPL
#undef FTST_IMPL
#undef FXAM_IMPL
#undef FLDCW_Mw_IMPL
#undef FLDC_IMPL
#undef F2XM1_IMPL
#undef FYL2X_IMPL
#undef FPTAN_IMPL
#undef FPATAN_IMPL
#undef FPREM1_IMPL
#undef FSTCW_Mw_IMPL
#undef FPREM_IMPL
#undef FYL2XP1_IMPL
#undef FSQRT_IMPL
#undef FSINCOS_IMPL
#undef FRNDINT_IMPL
#undef FSCALE_IMPL
#undef FSIN_IMPL
#undef FCOS_IMPL
#undef FIADD_Md_IMPL
#undef FCMOVB_ST0STi_IMPL
#undef FIMUL_Md_IMPL
#undef FCMOVE_ST0STi_IMPL
#undef FICOM_Md_IMPL
#undef FCMOVBE_ST0STi_IMPL
#undef FICOMP_Md_IMPL
#undef FCMOVU_ST0STi_IMPL
#undef FISUB_Md_IMPL
#undef FISUBR_Md_IMPL
#undef FUCOMPP_IMPL
#undef FIDIV_Md_IMPL
#undef FIDIVR_Md_IMPL
#undef FILD_Md_IMPL
#undef FCMOVNB_ST0STi_IMPL
#undef FCMOVNE_ST0STi_IMPL
#undef FIST_Md_IMPL
#undef FCMOVNBE_ST0STi_IMPL
#undef FISTP_Md_IMPL
#undef FCMOVNU_ST0STi_IMPL
#undef FCLEX_IMPL
#undef FLD_Me_IMPL
#undef FUCOMI_ST0STi_IMPL
#undef FCOMI_ST0STi_IMPL
#undef FSTP_Me_IMPL
#undef FADD_Mt_IMPL
#undef FADD_STiST0_IMPL
#undef FMUL_Mt_IMPL
#undef FMUL_STiST0_IMPL
#undef FCOM_Mt_IMPL
#undef FCOMP_Mt_IMPL
#undef FSUB_Mt_IMPL
#undef FSUBR_STiST0_IMPL
#undef FSUBR_Mt_IMPL
#undef FSUB_STiST0_IMPL
#undef FDIV_Mt_IMPL
#undef FDIVR_STiST0_IMPL
#undef FDIVR_Mt_IMPL
#undef FDIV_STiST0_IMPL
#undef FSTSW_Mw_IMPL
#undef FLD_Mt_IMPL
#undef FST_Mt_IMPL
#undef FST_STi_IMPL
#undef FSTP_Mt_IMPL
#undef FSTP_STi_IMPL
#undef FUCOM_STi_IMPL
#undef FUCOMP_STi_IMPL
#undef FIADD_Mw_IMPL
#undef FADDP_STiST0_IMPL
#undef FIMUL_Mw_IMPL
#undef FMULP_STiST0_IMPL
#undef FICOM_Mw_IMPL
#undef FICOMP_Mw_IMPL
#undef FCOMPP_IMPL
#undef FISUB_Mw_IMPL
#undef FSUBRP_STiST0_IMPL
#undef FISUBR_Mw_IMPL
#undef FSUBP_STiST0_IMPL
#undef FIDIV_Mw_IMPL
#undef FDIVRP_STiST0_IMPL
#undef FIDIVR_Mw_IMPL
#undef FDIVP_STiST0_IMPL
#undef FILD_Mw_IMPL
#undef FIST_Mw_IMPL
#undef FISTP_Mw_IMPL
#undef FSTSW_AX_IMPL
#undef FILD_Mq_IMPL
#undef FUCOMIP_ST0STi_IMPL
#undef FCOMIP_ST0STi_IMPL
#undef FISTP_Mq_IMPL
#undef ADDB_IMPL
#undef ADDBI_IMPL
#undef SETFLAGSW_IMPL
#undef GETFLAGSW_IMPL
#undef SETFLAGSD_IMPL
#undef GETFLAGSD_IMPL
#undef CPUID1_IMPL
#undef CPUID2_IMPL
#undef CPUID3_IMPL
#undef CPUID4_IMPL
#undef RDTSC1_IMPL
#undef RDTSC2_IMPL
#undef CMPXCHGW_ORIG_IMPL
#undef CMPXCHG1W_IMPL
#undef CMPXCHG2W_IMPL
#undef CMPXCHG3W_IMPL
#undef CMPXCHG1D_IMPL
#undef CMPXCHG2D_IMPL
#undef CMPXCHG3D_IMPL
#undef CMPXCHGMEM_CMOVW_IMPL
#undef CMPXCHGMEM_CMOVNW_IMPL
#undef CMPXCHGMEM_CMOVD_IMPL
#undef CMPXCHGMEM_CMOVND_IMPL
#undef ADDSSW_IMPL
#undef ADDSW_IMPL
#undef ADDW_IMPL
#undef ADDWI_IMPL
#undef ADDSSD_IMPL
#undef ADDSD_IMPL
#undef ADDD_IMPL
#undef ADDDI_IMPL
#undef ORB_IMPL
#undef ORBI_IMPL
#undef ORW_IMPL
#undef ORWI_IMPL
#undef ORD_IMPL
#undef ORDI_IMPL
#undef ADCB_IMPL
#undef ADCBI_IMPL
#undef ADCW_IMPL
#undef ADCWI_IMPL
#undef ADCD_IMPL
#undef ADCDI_IMPL
#undef SBBB_IMPL
#undef SBBBI_IMPL
#undef SBBW_IMPL
#undef SBBWI_IMPL
#undef SBBD_IMPL
#undef SBBDI_IMPL
#undef ANDB_IMPL
#undef ANDBI_IMPL
#undef ANDW_IMPL
#undef ANDWI_IMPL
#undef ANDD_IMPL
#undef ANDDI_IMPL
#undef SUBB_IMPL
#undef SUBBI_IMPL
#undef SUBW_IMPL
#undef SUBWI_IMPL
#undef SUBD_IMPL
#undef SUBDI_IMPL
#undef XORB_IMPL
#undef XORBI_IMPL
#undef XORW_IMPL
#undef XORWI_IMPL
#undef XORD_IMPL
#undef XORDI_IMPL
#undef INCB_IMPL
#undef INCW_IMPL
#undef INCD_IMPL
#undef DECB_IMPL
#undef DECW_IMPL
#undef DECD_IMPL
#undef ROLB_IMPL
#undef ROLBI_IMPL
#undef ROLW_IMPL
#undef ROLWI_IMPL
#undef ROLD_IMPL
#undef ROLDI_IMPL
#undef RORB_IMPL
#undef RORBI_IMPL
#undef RORW_IMPL
#undef RORWI_IMPL
#undef RORD_IMPL
#undef RORDI_IMPL
#undef RCLB_IMPL
#undef RCLBI_IMPL
#undef RCLW_IMPL
#undef RCLWI_IMPL
#undef RCLD_IMPL
#undef RCLDI_IMPL
#undef RCRB_IMPL
#undef RCRBI_IMPL
#undef RCRW_IMPL
#undef RCRWI_IMPL
#undef RCRD_IMPL
#undef RCRDI_IMPL
#undef SHLB_IMPL
#undef SHLBI_IMPL
#undef SHLW_IMPL
#undef SHLWI_IMPL
#undef SHLD_IMPL
#undef SHLDI_IMPL
#undef SHRB_IMPL
#undef SHRBI_IMPL
#undef SHRW_IMPL
#undef SHRWI_IMPL
#undef SHRD_IMPL
#undef SHRDI_IMPL
#undef SARB_IMPL
#undef SARBI_IMPL
#undef SARW_IMPL
#undef SARWI_IMPL
#undef SARD_IMPL
#undef SARDI_IMPL
#undef NOTB_IMPL
#undef NOTW_IMPL
#undef NOTD_IMPL
#undef NEGB_IMPL
#undef NEGW_IMPL
#undef NEGD_IMPL
#undef IMULB_IMPL
#undef IMULBI_IMPL
#undef IMULW_IMPL
#undef IMULWI_IMPL
#undef IMULD_IMPL
#undef IMULDI_IMPL
#undef MULB_IMPL
#undef MULBI_IMPL
#undef QUOB_IMPL
#undef QUOW_IMPL
#undef QUOD_IMPL
#undef REMB_IMPL
#undef REMW_IMPL
#undef REMD_IMPL
#undef IQUOB_IMPL
#undef IQUOW_IMPL
#undef IQUOD_IMPL
#undef IREMB_IMPL
#undef IREMW_IMPL
#undef IREMD_IMPL
#undef MULHIW_IMPL
#undef MULHID_IMPL
#undef MULLOW_IMPL
#undef MULLOD_IMPL
#undef IMULHIW_IMPL
#undef IMULHID_IMPL
#undef IMULLOW_IMPL
#undef IMULLOD_IMPL
#undef BSWAP_IMPL
#undef CMOVW_IMPL
#undef CMOVD_IMPL
#undef SETCC_IMPL
#undef BTSW_IMPL
#undef BTSWI_IMPL
#undef BTSD_IMPL
#undef BTSDI_IMPL
#undef BTRW_IMPL
#undef BTRWI_IMPL
#undef BTRD_IMPL
#undef BTRDI_IMPL
#undef BTCW_IMPL
#undef BTCWI_IMPL
#undef BTCD_IMPL
#undef BTCDI_IMPL
#undef MOVSXBW_IMPL
#undef MOVSXBD_IMPL
#undef MOVSXWW_IMPL
#undef MOVSXWD_IMPL
#undef MOVZXBW_IMPL
#undef MOVZXBD_IMPL
#undef MOVZXWW_IMPL
#undef MOVZXWD_IMPL
#undef BSFW_IMPL
#undef BSFD_IMPL
#undef BSRW_IMPL
#undef BSRD_IMPL
#undef INT_IMPL
#undef SHLDW_IMPL
#undef SHLDWI_IMPL
#undef SHLDD_IMPL
#undef SHLDDI_IMPL
#undef SHRDW_IMPL
#undef SHRDWI_IMPL
#undef SHRDD_IMPL
#undef SHRDDI_IMPL
#undef UHLT_IMPL
#undef ADDFW_IMPL
#undef ADDFD_IMPL
#undef AGENW_IMPL
#undef AGEND_IMPL
#undef STAW_IMPL
#undef STAD_IMPL
#undef LDWB_IMPL
#undef LDDB_IMPL
#undef STB_IMPL
#undef LDSWW_IMPL
#undef LDSDW_IMPL
#undef LDWW_IMPL
#undef LDDW_IMPL
#undef STSW_IMPL
#undef STW_IMPL
#undef LDSWD_IMPL
#undef LDSDD_IMPL
#undef LDWD_IMPL
#undef LDDD_IMPL
#undef STSD_IMPL
#undef STD_IMPL
#undef LDPCWW_IMPL
#undef LDPCDW_IMPL
#undef STPCW_IMPL
#undef LDPCWD_IMPL
#undef LDPCDD_IMPL
#undef STPCD_IMPL
#undef BGENW_IMPL
#undef BGENWI_IMPL
#undef BGEND_IMPL
#undef BGENDI_IMPL
#undef STA_BGENW_IMPL
#undef STA_BGENWI_IMPL
#undef STA_BGEND_IMPL
#undef STA_BGENDI_IMPL
#undef JCCB_IMPL
#undef JCCW_IMPL
#undef JCCD_IMPL
#undef BRCCB_IMPL
#undef BRCCW_IMPL
#undef BRCCD_IMPL
#undef JMPB_IMPL
#undef JMPW_IMPL
#undef JMPD_IMPL
#undef JMPRW_IMPL
#undef JMPRD_IMPL
#undef SEXTW_IMPL
#undef SEXTD_IMPL
#undef SIGNW_IMPL
#undef SIGND_IMPL
#undef MOVFB_IMPL
#undef MOVBF_IMPL
#undef MOVFW_IMPL
#undef MOVWF_IMPL
#undef CMPCCB_IMPL
#undef CMPCCW_IMPL
#undef CMPCCD_IMPL
#undef ADDE_IMPL
#undef MULE_IMPL
#undef COM_IMPL
#undef UCOM_IMPL
#undef COMI_IMPL
#undef UCOMI_IMPL
#undef SUBE_IMPL
#undef DIVE_IMPL
#undef MOVE_IMPL
#undef CHS_IMPL
#undef ABS_IMPL
#undef TST_IMPL
#undef XAM_IMPL
#undef TWOXM1_IMPL
#undef YL2X_IMPL
#undef TAN_IMPL
#undef ATAN_IMPL
#undef REM1_IMPL
#undef REM_IMPL
#undef YL2XP1_IMPL
#undef SQRT_IMPL
#undef SIN_IMPL
#undef COS_IMPL
#undef RNDINT_IMPL
#undef SCL_IMPL
#undef CMOVE_IMPL
#undef FLDWS_IMPL
#undef FLDDS_IMPL
#undef FSTS_IMPL
#undef FLDWT_IMPL
#undef FLDDT_IMPL
#undef FSTT_IMPL
#undef FLDWW_IMPL
#undef FLDDW_IMPL
#undef FSTW_IMPL
#undef FLDWD_IMPL
#undef FLDDD_IMPL
#undef FSTD_IMPL
#undef FLDWQ_IMPL
#undef FLDDQ_IMPL
#undef FSTQ_IMPL
#undef FLDWE_IMPL
#undef FLDDE_IMPL
#undef FSTE_IMPL
#undef LDC_IMPL
#undef FLDCWW_IMPL
#undef FLDCDW_IMPL
#undef FSTCWW_IMPL
#undef FSTCDW_IMPL
#undef FSTSW_IMPL
#undef REPNZ_MICROBR_D_IMPL
#undef REPZ_MICROBR_D_IMPL
#undef REP_MICROBR_D_IMPL
#undef REPNZ_MICROBR_W_IMPL
#undef REPZ_MICROBR_W_IMPL
#undef REP_MICROBR_W_IMPL
#undef REPFIRST_MICROBR_D_IMPL
#undef REPFIRST_MICROBR_W_IMPL
#undef PARTIAL_MERGEW_IMPL
#undef PARTIAL_MERGEB_IMPL
#undef MOV_DB_IMPL
#undef BOUND_LOWERW_IMPL
#undef BOUND_LOWERD_IMPL
#undef BOUND_UPPERW_IMPL
#undef BOUND_UPPERD_IMPL
#undef DAS_IMPL
#undef AAM_Ib_IMPL
#undef AAD_Ib_IMPL
#undef IN_ALIb_IMPL
#undef IN_eAXIb_IMPL
#undef OUT_IbAL_IMPL
#undef OUT_IbeAX_IMPL
#undef IN_ALDX_IMPL
#undef IN_eAXDX_IMPL
#undef OUT_DXAL_IMPL
#undef OUT_DXeAX_IMPL
