<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>LCOV - iris.info - tests/MersenneTwister.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LTP GCOV extension - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
        <tr>
          <td class="headerItem" width="20%">Current&nbsp;view:</td>
          <td class="headerValue" width="80%" colspan=4><a href="../index.html">directory</a> - <a href="index.html">tests</a> - MersenneTwister.h</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Test:</td>
          <td class="headerValue" width="80%" colspan=4>iris.info</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="20%">2010-05-24</td>
          <td width="20%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="20%">165</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="headerValue" width="20%">43.0 %</td>
          <td width="20%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="20%">71</td>
        </tr>
        </table>
      </td>
    </tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td><pre class="source">
<span class="lineNum">       1 </span>                : // MersenneTwister.h
<span class="lineNum">       2 </span>                : // Mersenne Twister random number generator -- a C++ class MTRand
<span class="lineNum">       3 </span>                : // Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
<span class="lineNum">       4 </span>                : // Richard J. Wagner  v1.1  28 September 2009  wagnerr@umich.edu
<span class="lineNum">       5 </span>                : 
<span class="lineNum">       6 </span>                : // The Mersenne Twister is an algorithm for generating random numbers.  It
<span class="lineNum">       7 </span>                : // was designed with consideration of the flaws in various other generators.
<span class="lineNum">       8 </span>                : // The period, 2^19937-1, and the order of equidistribution, 623 dimensions,
<span class="lineNum">       9 </span>                : // are far greater.  The generator is also fast; it avoids multiplication and
<span class="lineNum">      10 </span>                : // division, and it benefits from caches and pipelines.  For more information
<span class="lineNum">      11 </span>                : // see the inventors' web page at
<span class="lineNum">      12 </span>                : // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
<span class="lineNum">      13 </span>                : 
<span class="lineNum">      14 </span>                : // Reference
<span class="lineNum">      15 </span>                : // M. Matsumoto and T. Nishimura, &quot;Mersenne Twister: A 623-Dimensionally
<span class="lineNum">      16 </span>                : // Equidistributed Uniform Pseudo-Random Number Generator&quot;, ACM Transactions on
<span class="lineNum">      17 </span>                : // Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.
<span class="lineNum">      18 </span>                : 
<span class="lineNum">      19 </span>                : // Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
<span class="lineNum">      20 </span>                : // Copyright (C) 2000 - 2009, Richard J. Wagner
<span class="lineNum">      21 </span>                : // All rights reserved.
<span class="lineNum">      22 </span>                : // 
<span class="lineNum">      23 </span>                : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">      24 </span>                : // modification, are permitted provided that the following conditions
<span class="lineNum">      25 </span>                : // are met:
<span class="lineNum">      26 </span>                : // 
<span class="lineNum">      27 </span>                : //   1. Redistributions of source code must retain the above copyright
<span class="lineNum">      28 </span>                : //      notice, this list of conditions and the following disclaimer.
<span class="lineNum">      29 </span>                : //
<span class="lineNum">      30 </span>                : //   2. Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      31 </span>                : //      notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      32 </span>                : //      documentation and/or other materials provided with the distribution.
<span class="lineNum">      33 </span>                : //
<span class="lineNum">      34 </span>                : //   3. The names of its contributors may not be used to endorse or promote 
<span class="lineNum">      35 </span>                : //      products derived from this software without specific prior written 
<span class="lineNum">      36 </span>                : //      permission.
<span class="lineNum">      37 </span>                : // 
<span class="lineNum">      38 </span>                : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<span class="lineNum">      39 </span>                : // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      40 </span>                : // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      41 </span>                : // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
<span class="lineNum">      42 </span>                : // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
<span class="lineNum">      43 </span>                : // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
<span class="lineNum">      44 </span>                : // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
<span class="lineNum">      45 </span>                : // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
<span class="lineNum">      46 </span>                : // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
<span class="lineNum">      47 </span>                : // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
<span class="lineNum">      48 </span>                : // POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      49 </span>                : 
<span class="lineNum">      50 </span>                : // The original code included the following notice:
<span class="lineNum">      51 </span>                : // 
<span class="lineNum">      52 </span>                : //     When you use this, send an email to: m-mat@math.sci.hiroshima-u.ac.jp
<span class="lineNum">      53 </span>                : //     with an appropriate reference to your work.
<span class="lineNum">      54 </span>                : // 
<span class="lineNum">      55 </span>                : // It would be nice to CC: wagnerr@umich.edu and Cokus@math.washington.edu
<span class="lineNum">      56 </span>                : // when you write.
<span class="lineNum">      57 </span>                : 
<span class="lineNum">      58 </span>                : #ifndef MERSENNETWISTER_H
<span class="lineNum">      59 </span>                : #define MERSENNETWISTER_H
<span class="lineNum">      60 </span>                : 
<span class="lineNum">      61 </span>                : // Not thread safe (unless auto-initialization is avoided and each thread has
<span class="lineNum">      62 </span>                : // its own MTRand object)
<span class="lineNum">      63 </span>                : 
<span class="lineNum">      64 </span>                : #include &lt;iostream&gt;
<span class="lineNum">      65 </span>                : #include &lt;climits&gt;
<span class="lineNum">      66 </span>                : #include &lt;cstdio&gt;
<span class="lineNum">      67 </span>                : #include &lt;ctime&gt;
<span class="lineNum">      68 </span>                : #include &lt;cmath&gt;
<span class="lineNum">      69 </span>                : 
<span class="lineNum">      70 </span>                : class MTRand {
<span class="lineNum">      71 </span>                : // Data
<span class="lineNum">      72 </span>                : public:
<span class="lineNum">      73 </span>                :         typedef unsigned long uint32;  // unsigned integer type, at least 32 bits
<span class="lineNum">      74 </span>                :         
<span class="lineNum">      75 </span>                :         enum { N = 624 };       // length of state vector
<span class="lineNum">      76 </span>                :         enum { SAVE = N + 1 };  // length of array for save()
<span class="lineNum">      77 </span>                : 
<span class="lineNum">      78 </span>                : protected:
<span class="lineNum">      79 </span>                :         enum { M = 397 };  // period parameter
<span class="lineNum">      80 </span>                :         
<span class="lineNum">      81 </span>                :         uint32 state[N];   // internal state
<span class="lineNum">      82 </span>                :         uint32 *pNext;     // next value to get from state
<span class="lineNum">      83 </span>                :         int left;          // number of values left before reload needed
<span class="lineNum">      84 </span>                : 
<span class="lineNum">      85 </span>                : // Methods
<span class="lineNum">      86 </span>                : public:
<span class="lineNum">      87 </span>                :         MTRand( const uint32 oneSeed );  // initialize with a simple uint32
<span class="lineNum">      88 </span>                :         MTRand( uint32 *const bigSeed, uint32 const seedLength = N );  // or array
<span class="lineNum">      89 </span>                :         MTRand();  // auto-initialize with /dev/urandom or time() and clock()
<span class="lineNum">      90 </span>                :         MTRand( const MTRand&amp; o );  // copy
<span class="lineNum">      91 </span>                :         
<span class="lineNum">      92 </span>                :         // Do NOT use for CRYPTOGRAPHY without securely hashing several returned
<span class="lineNum">      93 </span>                :         // values together, otherwise the generator state can be learned after
<span class="lineNum">      94 </span>                :         // reading 624 consecutive values.
<span class="lineNum">      95 </span>                :         
<span class="lineNum">      96 </span>                :         // Access to 32-bit random numbers
<span class="lineNum">      97 </span>                :         uint32 randInt();                     // integer in [0,2^32-1]
<span class="lineNum">      98 </span>                :         uint32 randInt( const uint32 n );     // integer in [0,n] for n &lt; 2^32
<span class="lineNum">      99 </span>                :         double rand();                        // real number in [0,1]
<span class="lineNum">     100 </span>                :         double rand( const double n );        // real number in [0,n]
<span class="lineNum">     101 </span>                :         double randExc();                     // real number in [0,1)
<span class="lineNum">     102 </span>                :         double randExc( const double n );     // real number in [0,n)
<span class="lineNum">     103 </span>                :         double randDblExc();                  // real number in (0,1)
<span class="lineNum">     104 </span>                :         double randDblExc( const double n );  // real number in (0,n)
<span class="lineNum">     105 </span>                :         double operator()();                  // same as rand()
<span class="lineNum">     106 </span>                :         
<span class="lineNum">     107 </span>                :         // Access to 53-bit random numbers (capacity of IEEE double precision)
<span class="lineNum">     108 </span>                :         double rand53();  // real number in [0,1)
<span class="lineNum">     109 </span>                :         
<span class="lineNum">     110 </span>                :         // Access to nonuniform random number distributions
<span class="lineNum">     111 </span>                :         double randNorm( const double mean = 0.0, const double stddev = 1.0 );
<span class="lineNum">     112 </span>                :         
<span class="lineNum">     113 </span>                :         // Re-seeding functions with same behavior as initializers
<span class="lineNum">     114 </span>                :         void seed( const uint32 oneSeed );
<span class="lineNum">     115 </span>                :         void seed( uint32 *const bigSeed, const uint32 seedLength = N );
<span class="lineNum">     116 </span>                :         void seed();
<span class="lineNum">     117 </span>                :         
<span class="lineNum">     118 </span>                :         // Saving and loading generator state
<span class="lineNum">     119 </span>                :         void save( uint32* saveArray ) const;  // to array of size SAVE
<span class="lineNum">     120 </span>                :         void load( uint32 *const loadArray );  // from such array
<span class="lineNum">     121 </span>                :         friend std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const MTRand&amp; mtrand );
<span class="lineNum">     122 </span>                :         friend std::istream&amp; operator&gt;&gt;( std::istream&amp; is, MTRand&amp; mtrand );
<span class="lineNum">     123 </span>                :         MTRand&amp; operator=( const MTRand&amp; o );
<span class="lineNum">     124 </span>                : 
<span class="lineNum">     125 </span>                : protected:
<span class="lineNum">     126 </span>                :         void initialize( const uint32 oneSeed );
<span class="lineNum">     127 </span>                :         void reload();
<span class="lineNum">     128 </span><span class="lineCov">      369268848 :         uint32 hiBit( const uint32 u ) const { return u &amp; 0x80000000UL; }</span>
<span class="lineNum">     129 </span><span class="lineCov">      369268848 :         uint32 loBit( const uint32 u ) const { return u &amp; 0x00000001UL; }</span>
<span class="lineNum">     130 </span><span class="lineCov">      369268848 :         uint32 loBits( const uint32 u ) const { return u &amp; 0x7fffffffUL; }</span>
<span class="lineNum">     131 </span><span class="lineNoCov">              0 :         uint32 mixBits( const uint32 u, const uint32 v ) const</span>
<span class="lineNum">     132 </span><span class="lineCov">      369268848 :                 { return hiBit(u) | loBits(v); }</span>
<span class="lineNum">     133 </span><span class="lineNoCov">              0 :         uint32 magic( const uint32 u ) const</span>
<span class="lineNum">     134 </span><span class="lineCov">      369268848 :                 { return loBit(u) ? 0x9908b0dfUL : 0x0UL; }</span>
<span class="lineNum">     135 </span><span class="lineNoCov">              0 :         uint32 twist( const uint32 m, const uint32 s0, const uint32 s1 ) const</span>
<span class="lineNum">     136 </span><span class="lineCov">      738537696 :                 { return m ^ (mixBits(s0,s1)&gt;&gt;1) ^ magic(s1); }</span>
<span class="lineNum">     137 </span>                :         static uint32 hash( time_t t, clock_t c );
<span class="lineNum">     138 </span>                : };
<span class="lineNum">     139 </span>                : 
<span class="lineNum">     140 </span>                : // Functions are defined in order of usage to assist inlining
<span class="lineNum">     141 </span>                : 
<span class="lineNum">     142 </span><span class="lineNoCov">              0 : inline MTRand::uint32 MTRand::hash( time_t t, clock_t c )</span>
<span class="lineNum">     143 </span>                : {
<span class="lineNum">     144 </span>                :         // Get a uint32 from t and c
<span class="lineNum">     145 </span>                :         // Better than uint32(x) in case x is floating point in [0,1]
<span class="lineNum">     146 </span>                :         // Based on code by Lawrence Kirby (fred@genesis.demon.co.uk)
<span class="lineNum">     147 </span>                :         
<span class="lineNum">     148 </span>                :         static uint32 differ = 0;  // guarantee time-based seeds will change
<span class="lineNum">     149 </span>                :         
<span class="lineNum">     150 </span><span class="lineNoCov">              0 :         uint32 h1 = 0;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">              0 :         unsigned char *p = (unsigned char *) &amp;t;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">              0 :         for( size_t i = 0; i &lt; sizeof(t); ++i )</span>
<span class="lineNum">     153 </span>                :         {
<span class="lineNum">     154 </span><span class="lineNoCov">              0 :                 h1 *= UCHAR_MAX + 2U;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">              0 :                 h1 += p[i];</span>
<span class="lineNum">     156 </span>                :         }
<span class="lineNum">     157 </span><span class="lineNoCov">              0 :         uint32 h2 = 0;</span>
<span class="lineNum">     158 </span><span class="lineNoCov">              0 :         p = (unsigned char *) &amp;c;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">              0 :         for( size_t j = 0; j &lt; sizeof(c); ++j )</span>
<span class="lineNum">     160 </span>                :         {
<span class="lineNum">     161 </span><span class="lineNoCov">              0 :                 h2 *= UCHAR_MAX + 2U;</span>
<span class="lineNum">     162 </span><span class="lineNoCov">              0 :                 h2 += p[j];</span>
<span class="lineNum">     163 </span>                :         }
<span class="lineNum">     164 </span><span class="lineNoCov">              0 :         return ( h1 + differ++ ) ^ h2;</span>
<span class="lineNum">     165 </span>                : }
<span class="lineNum">     166 </span>                : 
<span class="lineNum">     167 </span><span class="lineNoCov">              0 : inline void MTRand::initialize( const uint32 seed )</span>
<span class="lineNum">     168 </span>                : {
<span class="lineNum">     169 </span>                :         // Initialize generator state with seed
<span class="lineNum">     170 </span>                :         // See Knuth TAOCP Vol 2, 3rd Ed, p.106 for multiplier.
<span class="lineNum">     171 </span>                :         // In previous versions, most significant bits (MSBs) of the seed affect
<span class="lineNum">     172 </span>                :         // only MSBs of the state array.  Modified 9 Jan 2002 by Makoto Matsumoto.
<span class="lineNum">     173 </span><span class="lineCov">         591777 :         register uint32 *s = state;</span>
<span class="lineNum">     174 </span><span class="lineCov">         591777 :         register uint32 *r = state;</span>
<span class="lineNum">     175 </span><span class="lineCov">         591777 :         register int i = 1;</span>
<span class="lineNum">     176 </span><span class="lineCov">         591777 :         *s++ = seed &amp; 0xffffffffUL;</span>
<span class="lineNum">     177 </span><span class="lineCov">      368677071 :         for( ; i &lt; N; ++i )</span>
<span class="lineNum">     178 </span>                :         {
<span class="lineNum">     179 </span><span class="lineCov">      368677071 :                 *s++ = ( 1812433253UL * ( *r ^ (*r &gt;&gt; 30) ) + i ) &amp; 0xffffffffUL;</span>
<span class="lineNum">     180 </span><span class="lineCov">      368677071 :                 r++;</span>
<span class="lineNum">     181 </span>                :         }
<span class="lineNum">     182 </span><span class="lineNoCov">              0 : }</span>
<span class="lineNum">     183 </span>                : 
<span class="lineNum">     184 </span><span class="lineCov">         591777 : inline void MTRand::reload()</span>
<span class="lineNum">     185 </span>                : {
<span class="lineNum">     186 </span>                :         // Generate N new values in state
<span class="lineNum">     187 </span>                :         // Made clearer and faster by Matthew Bellew (matthew.bellew@home.com)
<span class="lineNum">     188 </span>                :         static const int MmN = int(M) - int(N);  // in case enums are unsigned
<span class="lineNum">     189 </span><span class="lineCov">         591777 :         register uint32 *p = state;</span>
<span class="lineNum">     190 </span>                :         register int i;
<span class="lineNum">     191 </span><span class="lineCov">      134925156 :         for( i = N - M; i--; ++p )</span>
<span class="lineNum">     192 </span><span class="lineCov">      268666758 :                 *p = twist( p[M], p[0], p[1] );</span>
<span class="lineNum">     193 </span><span class="lineCov">      234935469 :         for( i = M; --i; ++p )</span>
<span class="lineNum">     194 </span><span class="lineCov">      468687384 :                 *p = twist( p[MmN], p[0], p[1] );</span>
<span class="lineNum">     195 </span><span class="lineCov">        1183554 :         *p = twist( p[MmN], p[0], state[0] );</span>
<span class="lineNum">     196 </span>                :         
<span class="lineNum">     197 </span><span class="lineCov">         591777 :         left = N, pNext = state;</span>
<span class="lineNum">     198 </span><span class="lineCov">         591777 : }</span>
<span class="lineNum">     199 </span>                : 
<span class="lineNum">     200 </span><span class="lineNoCov">              0 : inline void MTRand::seed( const uint32 oneSeed )</span>
<span class="lineNum">     201 </span>                : {
<span class="lineNum">     202 </span>                :         // Seed the generator with a simple uint32
<span class="lineNum">     203 </span>                :         initialize(oneSeed);
<span class="lineNum">     204 </span><span class="lineNoCov">              0 :         reload();</span>
<span class="lineNum">     205 </span><span class="lineNoCov">              0 : }</span>
<span class="lineNum">     206 </span>                : 
<span class="lineNum">     207 </span><span class="lineCov">         591777 : inline void MTRand::seed( uint32 *const bigSeed, const uint32 seedLength )</span>
<span class="lineNum">     208 </span>                : {
<span class="lineNum">     209 </span>                :         // Seed the generator with an array of uint32's
<span class="lineNum">     210 </span>                :         // There are 2^19937-1 possible initial states.  This function allows
<span class="lineNum">     211 </span>                :         // all of those to be accessed by providing at least 19937 bits (with a
<span class="lineNum">     212 </span>                :         // default seed length of N = 624 uint32's).  Any bits above the lower 32
<span class="lineNum">     213 </span>                :         // in each element are discarded.
<span class="lineNum">     214 </span>                :         // Just call seed() if you want to get array from /dev/urandom
<span class="lineNum">     215 </span>                :         initialize(19650218UL);
<span class="lineNum">     216 </span><span class="lineCov">         591777 :         register int i = 1;</span>
<span class="lineNum">     217 </span><span class="lineCov">         591777 :         register uint32 j = 0;</span>
<span class="lineNum">     218 </span><span class="lineCov">         591777 :         register int k = ( N &gt; seedLength ? N : seedLength );</span>
<span class="lineNum">     219 </span><span class="lineCov">      369860625 :         for( ; k; --k )</span>
<span class="lineNum">     220 </span>                :         {
<span class="lineNum">     221 </span>                :                 state[i] =
<span class="lineNum">     222 </span><span class="lineCov">      369268848 :                 state[i] ^ ( (state[i-1] ^ (state[i-1] &gt;&gt; 30)) * 1664525UL );</span>
<span class="lineNum">     223 </span><span class="lineCov">      369268848 :                 state[i] += ( bigSeed[j] &amp; 0xffffffffUL ) + j;</span>
<span class="lineNum">     224 </span><span class="lineCov">      369268848 :                 state[i] &amp;= 0xffffffffUL;</span>
<span class="lineNum">     225 </span><span class="lineCov">      369268848 :                 ++i;  ++j;</span>
<span class="lineNum">     226 </span><span class="lineCov">      369268848 :                 if( i &gt;= N ) { state[0] = state[N-1];  i = 1; }</span>
<span class="lineNum">     227 </span><span class="lineCov">      369268848 :                 if( j &gt;= seedLength ) j = 0;</span>
<span class="lineNum">     228 </span>                :         }
<span class="lineNum">     229 </span><span class="lineCov">      369268848 :         for( k = N - 1; k; --k )</span>
<span class="lineNum">     230 </span>                :         {
<span class="lineNum">     231 </span>                :                 state[i] =
<span class="lineNum">     232 </span><span class="lineCov">      368677071 :                 state[i] ^ ( (state[i-1] ^ (state[i-1] &gt;&gt; 30)) * 1566083941UL );</span>
<span class="lineNum">     233 </span><span class="lineCov">      368677071 :                 state[i] -= i;</span>
<span class="lineNum">     234 </span><span class="lineCov">      368677071 :                 state[i] &amp;= 0xffffffffUL;</span>
<span class="lineNum">     235 </span><span class="lineCov">      368677071 :                 ++i;</span>
<span class="lineNum">     236 </span><span class="lineCov">      368677071 :                 if( i &gt;= N ) { state[0] = state[N-1];  i = 1; }</span>
<span class="lineNum">     237 </span>                :         }
<span class="lineNum">     238 </span><span class="lineCov">         591777 :         state[0] = 0x80000000UL;  // MSB is 1, assuring non-zero initial array</span>
<span class="lineNum">     239 </span><span class="lineCov">         591777 :         reload();</span>
<span class="lineNum">     240 </span><span class="lineCov">         591777 : }</span>
<span class="lineNum">     241 </span>                : 
<span class="lineNum">     242 </span><span class="lineCov">         591777 : inline void MTRand::seed()</span>
<span class="lineNum">     243 </span>                : {
<span class="lineNum">     244 </span>                :         // Seed the generator with an array from /dev/urandom if available
<span class="lineNum">     245 </span>                :         // Otherwise use a hash of time() and clock() values
<span class="lineNum">     246 </span>                :         
<span class="lineNum">     247 </span>                :         // First try getting an array from /dev/urandom
<span class="lineNum">     248 </span><span class="lineCov">         591777 :         FILE* urandom = fopen( &quot;/dev/urandom&quot;, &quot;rb&quot; );</span>
<span class="lineNum">     249 </span><span class="lineCov">         591777 :         if( urandom )</span>
<span class="lineNum">     250 </span>                :         {
<span class="lineNum">     251 </span>                :                 uint32 bigSeed[N];
<span class="lineNum">     252 </span><span class="lineCov">         591777 :                 register uint32 *s = bigSeed;</span>
<span class="lineNum">     253 </span><span class="lineCov">         591777 :                 register int i = N;</span>
<span class="lineNum">     254 </span><span class="lineCov">         591777 :                 register bool success = true;</span>
<span class="lineNum">     255 </span><span class="lineCov">      370452402 :                 while( success &amp;&amp; i-- )</span>
<span class="lineNum">     256 </span><span class="lineCov">      738537696 :                         success = fread( s++, sizeof(uint32), 1, urandom );</span>
<span class="lineNum">     257 </span><span class="lineCov">         591777 :                 fclose(urandom);</span>
<span class="lineNum">     258 </span><span class="lineCov">         591777 :                 if( success ) { seed( bigSeed, N );  return; }</span>
<span class="lineNum">     259 </span>                :         }
<span class="lineNum">     260 </span>                :         
<span class="lineNum">     261 </span>                :         // Was not successful, so use time() and clock() instead
<span class="lineNum">     262 </span><span class="lineNoCov">              0 :         seed( hash( time(NULL), clock() ) );</span>
<span class="lineNum">     263 </span>                : }
<span class="lineNum">     264 </span>                : 
<span class="lineNum">     265 </span><span class="lineNoCov">              0 : inline MTRand::MTRand( const uint32 oneSeed )</span>
<span class="lineNum">     266 </span><span class="lineNoCov">              0 :         { seed(oneSeed); }</span>
<span class="lineNum">     267 </span>                : 
<span class="lineNum">     268 </span><span class="lineNoCov">              0 : inline MTRand::MTRand( uint32 *const bigSeed, const uint32 seedLength )</span>
<span class="lineNum">     269 </span><span class="lineNoCov">              0 :         { seed(bigSeed,seedLength); }</span>
<span class="lineNum">     270 </span>                : 
<span class="lineNum">     271 </span><span class="lineNoCov">              0 : inline MTRand::MTRand()</span>
<span class="lineNum">     272 </span><span class="lineCov">         591777 :         { seed(); }</span>
<span class="lineNum">     273 </span>                : 
<span class="lineNum">     274 </span><span class="lineNoCov">              0 : inline MTRand::MTRand( const MTRand&amp; o )</span>
<span class="lineNum">     275 </span>                : {
<span class="lineNum">     276 </span><span class="lineNoCov">              0 :         register const uint32 *t = o.state;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">              0 :         register uint32 *s = state;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">              0 :         register int i = N;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">              0 :         for( ; i--; *s++ = *t++ ) {}</span>
<span class="lineNum">     280 </span><span class="lineNoCov">              0 :         left = o.left;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">              0 :         pNext = &amp;state[N-left];</span>
<span class="lineNum">     282 </span><span class="lineNoCov">              0 : }</span>
<span class="lineNum">     283 </span>                : 
<span class="lineNum">     284 </span><span class="lineCov">         308899 : inline MTRand::uint32 MTRand::randInt()</span>
<span class="lineNum">     285 </span>                : {
<span class="lineNum">     286 </span>                :         // Pull a 32-bit integer from the generator state
<span class="lineNum">     287 </span>                :         // Every other access function simply transforms the numbers extracted here
<span class="lineNum">     288 </span>                :         
<span class="lineNum">     289 </span><span class="lineCov">         308899 :         if( left == 0 ) reload();</span>
<span class="lineNum">     290 </span><span class="lineCov">         308899 :         --left;</span>
<span class="lineNum">     291 </span>                :         
<span class="lineNum">     292 </span>                :         register uint32 s1;
<span class="lineNum">     293 </span><span class="lineCov">         308899 :         s1 = *pNext++;</span>
<span class="lineNum">     294 </span><span class="lineCov">         308899 :         s1 ^= (s1 &gt;&gt; 11);</span>
<span class="lineNum">     295 </span><span class="lineCov">         308899 :         s1 ^= (s1 &lt;&lt;  7) &amp; 0x9d2c5680UL;</span>
<span class="lineNum">     296 </span><span class="lineCov">         308899 :         s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000UL;</span>
<span class="lineNum">     297 </span><span class="lineCov">         308899 :         return ( s1 ^ (s1 &gt;&gt; 18) );</span>
<span class="lineNum">     298 </span>                : }
<span class="lineNum">     299 </span>                : 
<span class="lineNum">     300 </span><span class="lineCov">         301864 : inline MTRand::uint32 MTRand::randInt( const uint32 n )</span>
<span class="lineNum">     301 </span>                : {
<span class="lineNum">     302 </span>                :         // Find which bits are used in n
<span class="lineNum">     303 </span>                :         // Optimized by Magnus Jonsson (magnus@smartelectronix.com)
<span class="lineNum">     304 </span><span class="lineCov">         301864 :         uint32 used = n;</span>
<span class="lineNum">     305 </span><span class="lineCov">         301864 :         used |= used &gt;&gt; 1;</span>
<span class="lineNum">     306 </span><span class="lineCov">         301864 :         used |= used &gt;&gt; 2;</span>
<span class="lineNum">     307 </span><span class="lineCov">         301864 :         used |= used &gt;&gt; 4;</span>
<span class="lineNum">     308 </span><span class="lineCov">         301864 :         used |= used &gt;&gt; 8;</span>
<span class="lineNum">     309 </span><span class="lineCov">         301864 :         used |= used &gt;&gt; 16;</span>
<span class="lineNum">     310 </span>                :         
<span class="lineNum">     311 </span>                :         // Draw numbers until one is found in [0,n]
<span class="lineNum">     312 </span>                :         uint32 i;
<span class="lineNum">     313 </span><span class="lineCov">         308899 :         do</span>
<span class="lineNum">     314 </span><span class="lineCov">         308899 :                 i = randInt() &amp; used;  // toss unused bits to shorten search</span>
<span class="lineNum">     315 </span>                :         while( i &gt; n );
<span class="lineNum">     316 </span><span class="lineCov">         301864 :         return i;</span>
<span class="lineNum">     317 </span>                : }
<span class="lineNum">     318 </span>                : 
<span class="lineNum">     319 </span><span class="lineNoCov">              0 : inline double MTRand::rand()</span>
<span class="lineNum">     320 </span><span class="lineNoCov">              0 :         { return double(randInt()) * (1.0/4294967295.0); }</span>
<span class="lineNum">     321 </span>                : 
<span class="lineNum">     322 </span><span class="lineNoCov">              0 : inline double MTRand::rand( const double n )</span>
<span class="lineNum">     323 </span><span class="lineNoCov">              0 :         { return rand() * n; }</span>
<span class="lineNum">     324 </span>                : 
<span class="lineNum">     325 </span><span class="lineNoCov">              0 : inline double MTRand::randExc()</span>
<span class="lineNum">     326 </span><span class="lineNoCov">              0 :         { return double(randInt()) * (1.0/4294967296.0); }</span>
<span class="lineNum">     327 </span>                : 
<span class="lineNum">     328 </span><span class="lineNoCov">              0 : inline double MTRand::randExc( const double n )</span>
<span class="lineNum">     329 </span><span class="lineNoCov">              0 :         { return randExc() * n; }</span>
<span class="lineNum">     330 </span>                : 
<span class="lineNum">     331 </span><span class="lineNoCov">              0 : inline double MTRand::randDblExc()</span>
<span class="lineNum">     332 </span><span class="lineNoCov">              0 :         { return ( double(randInt()) + 0.5 ) * (1.0/4294967296.0); }</span>
<span class="lineNum">     333 </span>                : 
<span class="lineNum">     334 </span><span class="lineNoCov">              0 : inline double MTRand::randDblExc( const double n )</span>
<span class="lineNum">     335 </span><span class="lineNoCov">              0 :         { return randDblExc() * n; }</span>
<span class="lineNum">     336 </span>                : 
<span class="lineNum">     337 </span><span class="lineNoCov">              0 : inline double MTRand::rand53()</span>
<span class="lineNum">     338 </span>                : {
<span class="lineNum">     339 </span><span class="lineNoCov">              0 :         uint32 a = randInt() &gt;&gt; 5, b = randInt() &gt;&gt; 6;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">              0 :         return ( a * 67108864.0 + b ) * (1.0/9007199254740992.0);  // by Isaku Wada</span>
<span class="lineNum">     341 </span>                : }
<span class="lineNum">     342 </span>                : 
<span class="lineNum">     343 </span><span class="lineNoCov">              0 : inline double MTRand::randNorm( const double mean, const double stddev )</span>
<span class="lineNum">     344 </span>                : {
<span class="lineNum">     345 </span>                :         // Return a real number from a normal (Gaussian) distribution with given
<span class="lineNum">     346 </span>                :         // mean and standard deviation by polar form of Box-Muller transformation
<span class="lineNum">     347 </span>                :         double x, y, r;
<span class="lineNum">     348 </span><span class="lineNoCov">              0 :         do</span>
<span class="lineNum">     349 </span>                :         {
<span class="lineNum">     350 </span><span class="lineNoCov">              0 :                 x = 2.0 * rand() - 1.0;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">              0 :                 y = 2.0 * rand() - 1.0;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">              0 :                 r = x * x + y * y;</span>
<span class="lineNum">     353 </span>                :         }
<span class="lineNum">     354 </span>                :         while ( r &gt;= 1.0 || r == 0.0 );
<span class="lineNum">     355 </span><span class="lineNoCov">              0 :         double s = sqrt( -2.0 * log(r) / r );</span>
<span class="lineNum">     356 </span><span class="lineNoCov">              0 :         return mean + x * s * stddev;</span>
<span class="lineNum">     357 </span>                : }
<span class="lineNum">     358 </span>                : 
<span class="lineNum">     359 </span><span class="lineNoCov">              0 : inline double MTRand::operator()()</span>
<span class="lineNum">     360 </span>                : {
<span class="lineNum">     361 </span><span class="lineNoCov">              0 :         return rand();</span>
<span class="lineNum">     362 </span>                : }
<span class="lineNum">     363 </span>                : 
<span class="lineNum">     364 </span><span class="lineNoCov">              0 : inline void MTRand::save( uint32* saveArray ) const</span>
<span class="lineNum">     365 </span>                : {
<span class="lineNum">     366 </span><span class="lineNoCov">              0 :         register const uint32 *s = state;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">              0 :         register uint32 *sa = saveArray;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">              0 :         register int i = N;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">              0 :         for( ; i--; *sa++ = *s++ ) {}</span>
<span class="lineNum">     370 </span><span class="lineNoCov">              0 :         *sa = left;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">              0 : }</span>
<span class="lineNum">     372 </span>                : 
<span class="lineNum">     373 </span><span class="lineNoCov">              0 : inline void MTRand::load( uint32 *const loadArray )</span>
<span class="lineNum">     374 </span>                : {
<span class="lineNum">     375 </span><span class="lineNoCov">              0 :         register uint32 *s = state;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">              0 :         register uint32 *la = loadArray;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">              0 :         register int i = N;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">              0 :         for( ; i--; *s++ = *la++ ) {}</span>
<span class="lineNum">     379 </span><span class="lineNoCov">              0 :         left = *la;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">              0 :         pNext = &amp;state[N-left];</span>
<span class="lineNum">     381 </span><span class="lineNoCov">              0 : }</span>
<span class="lineNum">     382 </span>                : 
<span class="lineNum">     383 </span><span class="lineNoCov">              0 : inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const MTRand&amp; mtrand )</span>
<span class="lineNum">     384 </span>                : {
<span class="lineNum">     385 </span><span class="lineNoCov">              0 :         register const MTRand::uint32 *s = mtrand.state;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">              0 :         register int i = mtrand.N;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">              0 :         for( ; i--; os &lt;&lt; *s++ &lt;&lt; &quot;\t&quot; ) {}</span>
<span class="lineNum">     388 </span><span class="lineNoCov">              0 :         return os &lt;&lt; mtrand.left;</span>
<span class="lineNum">     389 </span>                : }
<span class="lineNum">     390 </span>                : 
<span class="lineNum">     391 </span><span class="lineNoCov">              0 : inline std::istream&amp; operator&gt;&gt;( std::istream&amp; is, MTRand&amp; mtrand )</span>
<span class="lineNum">     392 </span>                : {
<span class="lineNum">     393 </span><span class="lineNoCov">              0 :         register MTRand::uint32 *s = mtrand.state;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">              0 :         register int i = mtrand.N;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">              0 :         for( ; i--; is &gt;&gt; *s++ ) {}</span>
<span class="lineNum">     396 </span><span class="lineNoCov">              0 :         is &gt;&gt; mtrand.left;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">              0 :         mtrand.pNext = &amp;mtrand.state[mtrand.N-mtrand.left];</span>
<span class="lineNum">     398 </span><span class="lineNoCov">              0 :         return is;</span>
<span class="lineNum">     399 </span>                : }
<span class="lineNum">     400 </span>                : 
<span class="lineNum">     401 </span><span class="lineNoCov">              0 : inline MTRand&amp; MTRand::operator=( const MTRand&amp; o )</span>
<span class="lineNum">     402 </span>                : {
<span class="lineNum">     403 </span><span class="lineNoCov">              0 :         if( this == &amp;o ) return (*this);</span>
<span class="lineNum">     404 </span><span class="lineNoCov">              0 :         register const uint32 *t = o.state;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">              0 :         register uint32 *s = state;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">              0 :         register int i = N;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">              0 :         for( ; i--; *s++ = *t++ ) {}</span>
<span class="lineNum">     408 </span><span class="lineNoCov">              0 :         left = o.left;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">              0 :         pNext = &amp;state[N-left];</span>
<span class="lineNum">     410 </span><span class="lineNoCov">              0 :         return (*this);</span>
<span class="lineNum">     411 </span>                : }
<span class="lineNum">     412 </span>                : 
<span class="lineNum">     413 </span>                : #endif  // MERSENNETWISTER_H
<span class="lineNum">     414 </span>                : 
<span class="lineNum">     415 </span>                : // Change log:
<span class="lineNum">     416 </span>                : //
<span class="lineNum">     417 </span>                : // v0.1 - First release on 15 May 2000
<span class="lineNum">     418 </span>                : //      - Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
<span class="lineNum">     419 </span>                : //      - Translated from C to C++
<span class="lineNum">     420 </span>                : //      - Made completely ANSI compliant
<span class="lineNum">     421 </span>                : //      - Designed convenient interface for initialization, seeding, and
<span class="lineNum">     422 </span>                : //        obtaining numbers in default or user-defined ranges
<span class="lineNum">     423 </span>                : //      - Added automatic seeding from /dev/urandom or time() and clock()
<span class="lineNum">     424 </span>                : //      - Provided functions for saving and loading generator state
<span class="lineNum">     425 </span>                : //
<span class="lineNum">     426 </span>                : // v0.2 - Fixed bug which reloaded generator one step too late
<span class="lineNum">     427 </span>                : //
<span class="lineNum">     428 </span>                : // v0.3 - Switched to clearer, faster reload() code from Matthew Bellew
<span class="lineNum">     429 </span>                : //
<span class="lineNum">     430 </span>                : // v0.4 - Removed trailing newline in saved generator format to be consistent
<span class="lineNum">     431 </span>                : //        with output format of built-in types
<span class="lineNum">     432 </span>                : //
<span class="lineNum">     433 </span>                : // v0.5 - Improved portability by replacing static const int's with enum's and
<span class="lineNum">     434 </span>                : //        clarifying return values in seed(); suggested by Eric Heimburg
<span class="lineNum">     435 </span>                : //      - Removed MAXINT constant; use 0xffffffffUL instead
<span class="lineNum">     436 </span>                : //
<span class="lineNum">     437 </span>                : // v0.6 - Eliminated seed overflow when uint32 is larger than 32 bits
<span class="lineNum">     438 </span>                : //      - Changed integer [0,n] generator to give better uniformity
<span class="lineNum">     439 </span>                : //
<span class="lineNum">     440 </span>                : // v0.7 - Fixed operator precedence ambiguity in reload()
<span class="lineNum">     441 </span>                : //      - Added access for real numbers in (0,1) and (0,n)
<span class="lineNum">     442 </span>                : //
<span class="lineNum">     443 </span>                : // v0.8 - Included time.h header to properly support time_t and clock_t
<span class="lineNum">     444 </span>                : //
<span class="lineNum">     445 </span>                : // v1.0 - Revised seeding to match 26 Jan 2002 update of Nishimura and Matsumoto
<span class="lineNum">     446 </span>                : //      - Allowed for seeding with arrays of any length
<span class="lineNum">     447 </span>                : //      - Added access for real numbers in [0,1) with 53-bit resolution
<span class="lineNum">     448 </span>                : //      - Added access for real numbers from normal (Gaussian) distributions
<span class="lineNum">     449 </span>                : //      - Increased overall speed by optimizing twist()
<span class="lineNum">     450 </span>                : //      - Doubled speed of integer [0,n] generation
<span class="lineNum">     451 </span>                : //      - Fixed out-of-range number generation on 64-bit machines
<span class="lineNum">     452 </span>                : //      - Improved portability by substituting literal constants for long enum's
<span class="lineNum">     453 </span>                : //      - Changed license from GNU LGPL to BSD
<span class="lineNum">     454 </span>                : //
<span class="lineNum">     455 </span>                : // v1.1 - Corrected parameter label in randNorm from &quot;variance&quot; to &quot;stddev&quot;
<span class="lineNum">     456 </span>                : //      - Changed randNorm algorithm from basic to polar form for efficiency
<span class="lineNum">     457 </span>                : //      - Updated includes from deprecated &lt;xxxx.h&gt; to standard &lt;cxxxx&gt; forms
<span class="lineNum">     458 </span>                : //      - Cleaned declarations and definitions to please Intel compiler
<span class="lineNum">     459 </span>                : //      - Revised twist() operator to work on ones'-complement machines
<span class="lineNum">     460 </span>                : //      - Fixed reload() function to work when N and M are unsigned
<span class="lineNum">     461 </span>                : //      - Added copy constructor and copy operator from Salvador Espana
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
  <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LTP GCOV extension version 1.6</a></td></tr>
  </table>
  <br>

</body>
</html>
